%---------------------------------------------------------------------------%
% vim: ts=4 sw=4 et ft=mercury
%---------------------------------------------------------------------------%
% Copyright (C) 2005-2008, 2010-2012 The University of Melbourne.
% Copyright (C) 2014-2015, 2017-2018, 2021-2025 The Mercury team.
% This file is distributed under the terms specified in COPYING.LIB.
%---------------------------------------------------------------------------%
%
% File: read_trace_counts.m.
% Main author: wangp.
% Modifications by zs and maclarty.
%
% This module defines predicates to read in the execution trace summaries
% generated by programs compiled using the compiler's tracing options.
%
%---------------------------------------------------------------------------%

:- module mdbcomp.read_trace_counts.
:- interface.

:- import_module mdbcomp.trace_counts.

:- import_module io.
:- import_module list.
:- import_module map.
:- import_module maybe.
:- import_module set.

%---------------------------------------------------------------------------%
% NOTE: read_trace_counts_source, read_trace_counts_list, and
% read_and_union_trace_counts all build extra functionality
% on the top of read_trace_counts.
%---------------------------------------------------------------------------%

:- type read_trace_counts_list_result
    --->    list_ok(trace_count_file_type, trace_counts)
    ;       list_error_message(string).

    % read_trace_counts_source(FileName, Result, !IO):
    %
    % Read in trace counts stored in a given trace count file.
    %
:- pred read_trace_counts_source(string::in,
    read_trace_counts_list_result::out, io::di, io::uo) is det.

    % read_trace_counts_list(ShowProgress, FileName, Result, !IO):
    %
    % Read the trace_counts in the files whose names appear in FileName.
    % The result is a union of all the trace counts.
    % If ShowProgress is yes(Stream) then print to Stream the name of
    % each file just before it is read.
    %
:- pred read_trace_counts_list(maybe(io.text_output_stream)::in, string::in,
    read_trace_counts_list_result::out, io::di, io::uo) is det.

%---------------------%

    % read_and_union_trace_counts(ShowProgress, FileNames, NumTests, TestKinds,
    %   TraceCounts, MaybeError, !IO):
    %
    % Invoke read_trace_counts_source for each of the supplied filenames, and
    % union the resulting trace counts. If there is a problem with reading in
    % the trace counts, MaybeError will be `yes' wrapped around the error
    % message. Otherwise, MaybeError will be `no', TraceCounts will contain
    % the union of the trace counts and NumTests will contain the number of
    % tests the trace counts come from.
    %
    % If the source is a list of files and ShowProgress is yes then
    % the name of each file read will be printed to the current output
    % stream just before it is read.
    %
:- pred read_and_union_trace_counts(maybe(io.text_output_stream)::in,
    list(string)::in, int::out, set(trace_count_file_type)::out,
    trace_counts::out, maybe(string)::out, io::di, io::uo) is det.

%---------------------%

:- type read_trace_counts_result
    --->    ok(trace_count_file_type, trace_counts)
    ;       syntax_error(string)
    ;       error_message(string)
    ;       open_error(io.error)
    ;       io_error(io.error).

    % read_trace_counts(FileName, Result, !IO):
    %
    % Read in the trace counts stored in FileName.
    %
:- pred read_trace_counts(string::in, read_trace_counts_result::out,
    io::di, io::uo) is det.

%---------------------------------------------------------------------------%
%---------------------------------------------------------------------------%

:- implementation.

:- import_module mdbcomp.goal_path.
:- import_module mdbcomp.prim_data.
:- import_module mdbcomp.sym_name.

:- import_module exception.
:- import_module int.
:- import_module integer.
:- import_module io.call_system.
:- import_module mercury_term_lexer.
:- import_module require.
:- import_module string.
:- import_module univ.

%---------------------------------------------------------------------------%

read_trace_counts_source(FileName, Result, !IO) :-
    read_trace_counts(FileName, ReadTCResult, !IO),
    (
        ReadTCResult = ok(FileType, TraceCount),
        Result = list_ok(FileType, TraceCount)
    ;
        ReadTCResult = io_error(IOError),
        IOErrorMsg = io.error_message(IOError),
        string.format("I/O error reading file `%s': %s",
            [s(FileName), s(IOErrorMsg)], ErrorMsg),
        Result = list_error_message(ErrorMsg)
    ;
        ReadTCResult = open_error(IOError),
        IOErrorMsg = io.error_message(IOError),
        string.format("I/O error opening file `%s': %s",
            [s(FileName), s(IOErrorMsg)], ErrorMsg),
        Result = list_error_message(ErrorMsg)
    ;
        ReadTCResult = syntax_error(SyntaxMsg),
        string.format("Syntax error in file `%s': %s",
            [s(FileName), s(SyntaxMsg)], ErrorMsg),
        Result = list_error_message(ErrorMsg)
    ;
        ReadTCResult = error_message(ErrMsg),
        string.format("Error reading trace counts from in file `%s': %s",
            [s(FileName), s(ErrMsg)], ErrorMsg),
        Result = list_error_message(ErrorMsg)
    ).

read_trace_counts_list(ShowProgress, FileName, Result, !IO) :-
    io.open_input(FileName, OpenResult, !IO),
    (
        OpenResult = ok(FileStream),
        read_trace_counts_list_stream(ShowProgress, union_file(0, []),
            map.init, FileName, FileStream, Result, !IO)
        % XXX Is there some reason why we do not close FileStream?
    ;
        OpenResult = error(IOError),
        IOErrorMsg = io.error_message(IOError),
        string.format("Error opening file `%s': %s",
            [s(FileName), s(IOErrorMsg)], ErrorMsg),
        Result = list_error_message(ErrorMsg)
    ).

    % Same as read_trace_counts_list/5, but read the filenames containing
    % the trace_counts from the given stream. MainFileName is the
    % name of the file being read and is only used for error messages.
    %
:- pred read_trace_counts_list_stream(maybe(io.text_output_stream)::in,
    trace_count_file_type::in, trace_counts::in, string::in,
    io.text_input_stream::in, read_trace_counts_list_result::out,
    io::di, io::uo) is det.

read_trace_counts_list_stream(ShowProgress, FileType0, TraceCounts0,
        MainFileName, Stream, Result, !IO) :-
    io.read_line_as_string(Stream, ReadResult, !IO),
    (
        ReadResult = ok(Line),
        % Remove trailing whitespace:
        FileName = string.rstrip(Line),
        ( if FileName = "" then
            % Ignore blank lines.
            read_trace_counts_list_stream(ShowProgress, FileType0,
                TraceCounts0, MainFileName, Stream, Result, !IO)
        else
            (
                ShowProgress = yes(ProgressStream),
                io.write_string(ProgressStream, FileName, !IO),
                io.nl(ProgressStream, !IO)
            ;
                ShowProgress = no
            ),
            read_trace_counts(FileName, ReadTCResult, !IO),
            (
                ReadTCResult = ok(FileType1, TraceCounts1),
                summarize_trace_counts_list([TraceCounts0, TraceCounts1],
                    TraceCounts),
                FileType = sum_trace_count_file_type(FileType0, FileType1),
                read_trace_counts_list_stream(ShowProgress, FileType,
                    TraceCounts, MainFileName, Stream, Result, !IO)
            ;
                ReadTCResult = io_error(IOError),
                ErrMsg = io.error_message(IOError),
                Result = list_error_message("I/O error reading file " ++
                    "`" ++ FileName ++ "': " ++ ErrMsg)
            ;
                ReadTCResult = open_error(IOError),
                ErrMsg = io.error_message(IOError),
                Result = list_error_message("I/O error opening file " ++
                    "`" ++ FileName ++ "': " ++ ErrMsg)
            ;
                ReadTCResult = syntax_error(ErrMsg),
                Result = list_error_message("Syntax error in file `" ++
                    FileName ++ "': " ++ ErrMsg)
            ;
                ReadTCResult = error_message(ErrMsg),
                Result = list_error_message("Error reading trace counts " ++
                    "from file `" ++ FileName ++ "': " ++ ErrMsg)
            )
        )
    ;
        ReadResult = error(Error),
        Result = list_error_message("IO error reading file " ++ "`" ++
            MainFileName ++ "': " ++ string.string(Error))
    ;
        ReadResult = eof,
        Result = list_ok(FileType0, TraceCounts0)
    ).

:- pred string_to_goal_path(string::in, reverse_goal_path::out) is semidet.

string_to_goal_path(String, Path) :-
    string.prefix(String, "<"),
    string.suffix(String, ">"),
    string.length(String, Length),
    string.between(String, 1, Length - 1, SubString),
    rev_goal_path_from_string(SubString, Path).

:- pred decimal_token_to_int(token::in, int::out) is semidet.

decimal_token_to_int(Token, Int) :-
    Token = integer(base_10, Integer, signed, size_word),
    integer.to_int(Integer, Int).

%---------------------------------------------------------------------------%

read_and_union_trace_counts(ShowProgress, Files, NumTests, TestKinds,
        TraceCounts, MaybeError, !IO) :-
    read_and_union_trace_counts_2(ShowProgress, Files,
        union_file(0, []), FileType, map.init, TraceCounts, MaybeError, !IO),
    (
        FileType = union_file(NumTests, TestKindList),
        set.list_to_set(TestKindList, TestKinds)
    ;
        FileType = single_file(_),
        error("read_and_union_trace_counts: single_file")
    ;
        FileType = diff_file(_, _),
        error("read_and_union_trace_counts: diff_file")
    ).

:- pred read_and_union_trace_counts_2(maybe(io.text_output_stream)::in,
    list(string)::in, trace_count_file_type::in, trace_count_file_type::out,
    trace_counts::in, trace_counts::out, maybe(string)::out,
    io::di, io::uo) is det.

read_and_union_trace_counts_2(_, [], !FileType, !TraceCounts, no, !IO).
read_and_union_trace_counts_2(ShowProgress, [FileName | FileNames],
        !FileType, !TraceCounts, MaybeError, !IO) :-
    (
        ShowProgress = yes(ProgressStream),
        io.write_string(ProgressStream, FileName, !IO),
        io.nl(ProgressStream, !IO)
    ;
        ShowProgress = no
    ),
    read_trace_counts_source(FileName, TCResult, !IO),
    (
        TCResult = list_ok(FileType, NewTraceCounts),
        summarize_trace_counts_list([!.TraceCounts, NewTraceCounts],
            !:TraceCounts),
        !:FileType = sum_trace_count_file_type(!.FileType, FileType),
        read_and_union_trace_counts_2(ShowProgress, FileNames,
            !FileType, !TraceCounts, MaybeError, !IO)
    ;
        TCResult = list_error_message(Message),
        MaybeError = yes(Message)
    ).

%---------------------------------------------------------------------------%

read_trace_counts(FileName, ReadResult, !IO) :-
    % XXX We should be using zcat here, to avoid deleting the gzipped file
    % and having to recreate it again. Unfortunately, Mercury does not have
    % any facilities equivalent to popen in Unix, and I don't know how to
    % write one in a way that is portable to Windows. zs.
    % XXX ... and we certainly shouldn't be hardcoding the names of the
    % gzip / gunzip executables. juliensf.
    ( if string.remove_suffix(FileName, ".gz", BaseName) then
        io.call_system.call_system("gunzip " ++ FileName, _UnzipResult, !IO),
        ActualFileName = BaseName,
        GzipCmd = "gzip " ++ BaseName
    else
        ActualFileName = FileName,
        GzipCmd = ""
    ),
    io.open_input(ActualFileName, Result, !IO),
    (
        Result = ok(FileStream),
        io.read_line_as_string(FileStream, IdReadResult, !IO),
        ( if
            IdReadResult = ok(FirstLine),
            string.rstrip(FirstLine) = trace_count_file_id
        then
            promise_equivalent_solutions [ReadResult, !:IO] (
                read_trace_counts_from_stream(FileStream, ReadResult, !IO)
            )
        else
            ReadResult = syntax_error("no trace count file id")
        ),
        io.close_input(FileStream, !IO)
    ;
        Result = error(IOError),
        ReadResult = open_error(IOError)
    ),
    ( if GzipCmd = "" then
        true
    else
        io.call_system.call_system(GzipCmd, _ZipResult, !IO)
    ).

:- pred read_trace_counts_from_stream(io.text_input_stream::in,
    read_trace_counts_result::out, io::di, io::uo) is cc_multi.

read_trace_counts_from_stream(InputStream, ReadResult, !IO) :-
    io.read(InputStream, FileTypeResult, !IO),
    (
        FileTypeResult = ok(FileType),
        io.read_line_as_string(InputStream, NewlineResult, !IO),
        ( if NewlineResult = ok("\n") then
            try_io(read_trace_counts_setup(InputStream, map.init),
                Result, !IO),
            (
                Result = succeeded(TraceCounts),
                ReadResult = ok(FileType, TraceCounts)
            ;
                Result = exception(Exception),
                ( if Exception = univ(IOError) then
                    ReadResult = io_error(IOError)
                else if Exception = univ(Message) then
                    ReadResult = error_message(Message)
                else if Exception = univ(trace_count_syntax_error(Error)) then
                    ReadResult = syntax_error(Error)
                else
                    unexpected($pred,
                        "unexpected exception type: " ++ string(Exception))
                )
            )
        else
            ReadResult = syntax_error("no info on trace count file type")
        )
    ;
        ( FileTypeResult = eof
        ; FileTypeResult = error(_, _)
        ),
        ReadResult = syntax_error("no info on trace count file type")
    ).

:- pred read_trace_counts_setup(io.text_input_stream::in,
    trace_counts::in, trace_counts::out, io::di, io::uo) is det.

read_trace_counts_setup(InputStream, !TraceCounts, !IO) :-
    io.get_line_number(InputStream, LineNumber, !IO),
    io.read_line_as_string(InputStream, Result, !IO),
    (
        Result = ok(Line),
        % The code in mercury_trace_counts.c always generates output that will
        % cause read_proc_trace_counts below to override these dummy module
        % and file names before they are referenced.
        CurModuleNameSym = unqualified(""),
        CurFileName = "",
        read_proc_trace_counts(InputStream, LineNumber, Line,
            CurModuleNameSym, CurFileName, !TraceCounts, !IO)
    ;
        Result = eof
    ;
        Result = error(Error),
        throw(Error)
    ).

:- type trace_count_syntax_error
    --->    trace_count_syntax_error(string).

:- pred read_proc_trace_counts(io.text_input_stream::in, int::in, string::in,
    sym_name::in, string::in, trace_counts::in, trace_counts::out,
    io::di, io::uo) is det.

read_proc_trace_counts(InputStream, HeaderLineNumber, HeaderLine,
        CurModuleNameSym, CurFileName, !TraceCounts, !IO) :-
    mercury_term_lexer.string_get_token_list_max(HeaderLine,
        string.length(HeaderLine), TokenList, posn(HeaderLineNumber, 1, 0), _),
    ( if TokenList = token_cons(name(TokenName), _, TokenListRest) then
        ( if
            TokenName = "module",
            TokenListRest =
                token_cons(name(NextModuleName), _,
                token_nil)
        then
            NextModuleNameSym = string_to_sym_name(NextModuleName),
            io.read_line_as_string(InputStream, Result, !IO),
            (
                Result = ok(Line),
                io.get_line_number(InputStream, LineNumber, !IO),
                read_proc_trace_counts(InputStream, LineNumber, Line,
                    NextModuleNameSym, CurFileName, !TraceCounts, !IO)
            ;
                Result = eof
            ;
                Result = error(Error),
                throw(Error)
            )
        else if
            TokenName = "file",
            TokenListRest =
                token_cons(name(NextFileName), _,
                token_nil)
        then
            io.read_line_as_string(InputStream, Result, !IO),
            (
                Result = ok(Line),
                io.get_line_number(InputStream, LineNumber, !IO),
                read_proc_trace_counts(InputStream, LineNumber, Line,
                    CurModuleNameSym, NextFileName, !TraceCounts, !IO)
            ;
                Result = eof
            ;
                Result = error(Error),
                throw(Error)
            )
        else if
            % At the moment runtime/mercury_trace_base.c doesn't write out
            % data for unify, compare, index or init procedures.
            (
                TokenName = "pproc",
                TokenListRest =
                    token_cons(name(Name), _,
                    token_cons(ArityToken, _,
                    token_cons(ModeToken, _,
                    token_nil))),
                decimal_token_to_int(ArityToken, Arity),
                decimal_token_to_int(ModeToken, Mode),
                ProcLabel = ordinary_proc_label(CurModuleNameSym, pf_predicate,
                    CurModuleNameSym, Name, Arity, Mode)
            ;
                TokenName = "fproc",
                TokenListRest =
                    token_cons(name(Name), _,
                    token_cons(ArityToken, _,
                    token_cons(ModeToken, _,
                    token_nil))),
                decimal_token_to_int(ArityToken, Arity),
                decimal_token_to_int(ModeToken, Mode),
                ProcLabel = ordinary_proc_label(CurModuleNameSym, pf_function,
                    CurModuleNameSym, Name, Arity, Mode)
            ;
                TokenName = "pprocdecl",
                TokenListRest =
                    token_cons(name(DeclModuleName), _,
                    token_cons(name(Name), _,
                    token_cons(ArityToken, _,
                    token_cons(ModeToken, _,
                    token_nil)))),
                decimal_token_to_int(ArityToken, Arity),
                decimal_token_to_int(ModeToken, Mode),
                DeclModuleNameSym = string_to_sym_name(DeclModuleName),
                ProcLabel = ordinary_proc_label(CurModuleNameSym, pf_predicate,
                    DeclModuleNameSym, Name, Arity, Mode)
            ;
                TokenName = "fprocdecl",
                TokenListRest =
                    token_cons(name(DeclModuleName), _,
                    token_cons(name(Name), _,
                    token_cons(ArityToken, _,
                    token_cons(ModeToken, _,
                    token_nil)))),
                decimal_token_to_int(ArityToken, Arity),
                decimal_token_to_int(ModeToken, Mode),
                DeclModuleNameSym = string_to_sym_name(DeclModuleName),
                ProcLabel = ordinary_proc_label(CurModuleNameSym, pf_function,
                    DeclModuleNameSym, Name, Arity, Mode)
            )
        then
            ProcLabelInContext = proc_label_in_context(CurModuleNameSym,
                CurFileName, ProcLabel),
            % For whatever reason some of the trace counts for a single
            % procedure or function can be split over multiple spans.
            % We collate them as if they appeared in a single span.
            ( if map.remove(ProcLabelInContext, ProbeCounts, !TraceCounts) then
                StartCounts = ProbeCounts
            else
                StartCounts = map.init
            ),
            read_proc_trace_counts_2(InputStream, ProcLabelInContext,
                StartCounts, !TraceCounts, !IO)
        else
            string.format("parse error on line %d of execution trace",
                [i(HeaderLineNumber)], Message),
            throw(trace_count_syntax_error(Message))
        )
    else
        string.format("parse error on line %d of execution trace",
            [i(HeaderLineNumber)], Message),
        throw(trace_count_syntax_error(Message))
    ).

:- pred read_proc_trace_counts_2(io.text_input_stream::in,
    proc_label_in_context::in, proc_trace_counts::in,
    trace_counts::in, trace_counts::out, io::di, io::uo) is det.

read_proc_trace_counts_2(InputStream, ProcLabelInContext,
        ProcCounts0, !TraceCounts, !IO) :-
    io.read_line_as_string(InputStream, Result, !IO),
    (
        Result = ok(Line),
        ( if
            parse_path_port_line(Line, PathPort, LineNumber, ExecCount,
                NumTests)
        then
            LineNoAndCount =
                line_no_and_count(LineNumber, ExecCount, NumTests),
            map.det_insert(PathPort, LineNoAndCount, ProcCounts0, ProcCounts),
            read_proc_trace_counts_2(InputStream, ProcLabelInContext,
                ProcCounts, !TraceCounts, !IO)
        else
            map.det_insert(ProcLabelInContext, ProcCounts0, !TraceCounts),
            io.get_line_number(InputStream, LineNumber, !IO),
            CurModuleNameSym = ProcLabelInContext ^ context_module_symname,
            CurFileName = ProcLabelInContext ^ context_filename,
            read_proc_trace_counts(InputStream, LineNumber, Line,
                CurModuleNameSym, CurFileName, !TraceCounts, !IO)
        )
    ;
        Result = eof,
        map.det_insert(ProcLabelInContext, ProcCounts0, !TraceCounts)
    ;
        Result = error(Error),
        throw(Error)
    ).

:- pred parse_path_port_line(string::in, path_port::out, int::out, int::out,
    int::out) is semidet.

parse_path_port_line(Line, PathPort, LineNumber, ExecCount, NumTests) :-
    Words = string.words(Line),
    ( if
        Words = [Word1, LineNumberStr | Rest],
        ( if string_to_trace_port(Word1, Port) then
            PathPortPrime = port_only(Port)
        else if string_to_goal_path(Word1, Path) then
            PathPortPrime = path_only(Path)
        else
            fail
        ),
        string.to_int(LineNumberStr, LineNumberPrime),
        parse_path_port_line_rest(Rest, ExecCountPrime, NumTestsPrime)
    then
        PathPort = PathPortPrime,
        LineNumber = LineNumberPrime,
        ExecCount = ExecCountPrime,
        NumTests = NumTestsPrime
    else
        Words = [PortStr, PathStr, LineNumberStr | Rest],
        string_to_trace_port(PortStr, Port),
        string_to_goal_path(PathStr, Path),
        PathPort = port_and_path(Port, Path),
        string.to_int(LineNumberStr, LineNumber),
        parse_path_port_line_rest(Rest, ExecCount, NumTests)
    ).

:- pred parse_path_port_line_rest(list(string)::in, int::out, int::out)
    is semidet.

parse_path_port_line_rest(Rest, ExecCount, NumTests) :-
    (
        Rest = [],
        ExecCount = 0,
        NumTests = 1
    ;
        Rest = [ExecCountStr],
        string.to_int(ExecCountStr, ExecCount),
        NumTests = 1
    ;
        Rest = [ExecCountStr, NumTestsStr],
        string.to_int(ExecCountStr, ExecCount),
        string.to_int(NumTestsStr, NumTests)
    ).

%---------------------------------------------------------------------------%
:- end_module mdbcomp.read_trace_counts.
%---------------------------------------------------------------------------%
