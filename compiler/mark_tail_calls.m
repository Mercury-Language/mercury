%---------------------------------------------------------------------------%
% vim: ft=mercury ts=4 sw=4 et
%---------------------------------------------------------------------------%
% Copyright (C) 2001-2008, 2010-2012 The University of Melbourne.
% Copyright (C) 2014-2017 The Mercury Team.
% This file may only be copied under the terms of the GNU General
% Public License - see the file COPYING in the Mercury distribution.
%---------------------------------------------------------------------------%
%
% File: mark_tail_calls.m.
% Main author: zs.
%
% This module adds a feature to all self-recursive calls that can be
% implemented as tail calls.
%
% Since an assignment unification that simply renames an output of a recursive
% call may prevent that call from being recognized as a tail call, you probably
% want to run excess assign elimination just before invoking this module.
%
% This module also contains code to detect recursive calls which are not
% *tail* recursive, and generating warnings for them. The point of this
% is to point out to the programmer the calls may lead to stack usage
% that is proportional to the size of the input, and may thus lead to
% stack exhaustion for large inputs.
%
% We use the code for warning about such non-tail recursive calls only in
% compilations that invoke the LLDS backend. This is because with the LLDS
% backend, figuring out which recursive calls will end up being *tail*
% recursive is simple and easily predictable: any call to a procedure in
% the caller's SCC whose output arguments are identical to the caller's
% output arguments will end up as tail recursive calls. With the MLDS backend,
% things are not as simple. This is why compilations that use that backend
% use a version of the tail-call-detection code that operates on the MLDS
% code actually generated by the code generator. That code is in ml_tailcall.m.
% To ensure a consistent experience for the compiler user, both modules
% use the same predicates (which are in this module) to actually generate
% the error messages themselves.
%
%---------------------------------------------------------------------------%

:- module hlds.mark_tail_calls.
:- interface.

:- import_module hlds.hlds_dependency_graph.
:- import_module hlds.hlds_module.
:- import_module hlds.hlds_pred.
:- import_module libs.
:- import_module libs.compiler_util.
:- import_module libs.dependency_graph.
:- import_module parse_tree.
:- import_module parse_tree.error_util.
:- import_module parse_tree.prog_data.

:- import_module list.

%---------------------------------------------------------------------------%

    % Mark both self and mutual tail recursive calls in the module.
    %
    % Unlike the predicates below serving the LLDS code generator,
    % this predicate never generates any error messages, and it never
    % restricts it attention to only *self* tail recursive calls.
    %
:- pred mark_self_and_mutual_tail_rec_calls_in_module(hlds_dependency_info::in,
    module_info::in, module_info::out) is det.

%---------------------%

    % Mark tail calls as needed by the LLDS code generator.
    %
    % This can mean
    %
    % - marking self-tail-recursive calls so that the code generator can emit
    %   TAIL events and tail recursive calls instead of non tail recursive
    %   calls followed by an EXIT event. This is needed only if we are
    %   generating code for the debugger.
    %
    % - generating warnings for recursive calls that are not *tail* recursive,
    %   if the warn_non_tail_recursion option is set.
    %
    % It can also mean both, or neither.
    %
    % The LLDS code generator can be invoked to compile procedures either
    % by phases, or by procedures; the two do the same jobs, but in different
    % order. It calls the in_pred version when compiling procedures by phases,
    % and it calls the in_proc version when compiling procedures by procedures.
    %
:- pred mark_tail_rec_calls_in_pred_for_llds_code_gen(
    scc_map(pred_proc_id)::in, pred_id::in, module_info::in, module_info::out,
    pred_info::in, pred_info::out,
    list(error_spec)::in, list(error_spec)::out) is det.
:- pred mark_tail_rec_calls_in_proc_for_llds_code_gen(module_info::in,
    pred_id::in, proc_id::in, pred_info::in,
    scc_map(pred_proc_id)::in, proc_info::in, proc_info::out,
    list(error_spec)::in, list(error_spec)::out) is det.

%---------------------------------------------------------------------------%
%
% These predicates are exported for ml_tailcall.m; see above for the reason.
%

    % add_message_for_nontail_self_recursive_call(SimpleCallId, ProcId,
    %    Context, WarnOrError, !Specs):
    %
    % Add an error_spec to !Specs reporting that the recursive call inside
    % the procedure described by SimpleCallId and ProcId at Context
    % is not *tail* recursive. Set its severity based on WarnOrError.
    %
:- pred add_message_for_nontail_self_recursive_call(simple_call_id::in,
    proc_id::in, prog_context::in, warning_or_error::in,
    list(error_spec)::in, list(error_spec)::out) is det.

    % add_message_for_nontail_mutual_recursive_call(CallerCallId, CallerProcId,
    %    CalleeCallId, WarnOrError, Context, !Specs):
    %
    % Add an error_spec to !Specs reporting that the mutually recursive call
    % inside the procedure described by SimpleCallId and ProcId at Context
    % is not *tail* recursive. Set its severity based on WarnOrError.
    %
:- pred add_message_for_nontail_mutual_recursive_call(simple_call_id::in,
    proc_id::in, simple_call_id::in, warning_or_error::in, prog_context::in,
    list(error_spec)::in, list(error_spec)::out) is det.

    % add_message_for_no_tail_or_nontail_recursive_calls(SimpleCallId, Context,
    %   !Specs):
    %
    % Add warning to !Specs reporting that the procedure described by
    % SimpleCallId contains no recursive calls at all, tail-recursive or
    % otherwise. The Context should be the context of the pragma that asked
    % for warnings about non-tail-recursive recursive calls.
    %
:- pred add_message_for_no_tail_or_nontail_recursive_calls(simple_call_id::in,
    prog_context::in, list(error_spec)::in, list(error_spec)::out) is det.

%---------------------------------------------------------------------------%
%---------------------------------------------------------------------------%

:- implementation.

:- import_module check_hlds.
:- import_module check_hlds.mode_util.
:- import_module check_hlds.type_util.
:- import_module hlds.hlds_goal.
:- import_module hlds.vartypes.
:- import_module libs.globals.
:- import_module libs.options.
:- import_module mdbcomp.
:- import_module mdbcomp.sym_name.
:- import_module parse_tree.prog_data_pragma.

:- import_module bool.
:- import_module int.
:- import_module map.
:- import_module maybe.
:- import_module require.
:- import_module set.

%---------------------------------------------------------------------------%
%---------------------------------------------------------------------------%

mark_self_and_mutual_tail_rec_calls_in_module(DepInfo, !ModuleInfo) :-
    AddGoalFeature = add_goal_feature_self_or_mutual,
    WarnNonTailRecParams = no_warnings_non_tail_rec_params,
    get_bottom_up_sccs_with_entry_points(!.ModuleInfo, DepInfo,
        BottomUpSCCsEntryPoints),
    mark_tail_rec_calls_in_sccs(AddGoalFeature, WarnNonTailRecParams,
        BottomUpSCCsEntryPoints, !ModuleInfo).

:- pred mark_tail_rec_calls_in_sccs(add_goal_feature::in,
    warn_non_tail_rec_params::in,
    list(scc_with_entry_points)::in, module_info::in, module_info::out) is det.

mark_tail_rec_calls_in_sccs(_AddGoalFeature, _WarnNonTailRecParams,
        [], !ModuleInfo).
mark_tail_rec_calls_in_sccs(AddGoalFeature, WarnNonTailRecParams,
        [SCCEntry | SCCEntries], !ModuleInfo) :-
    SCCEntry = scc_with_entry_points(SCC, _CalledFromHigherSCC, _Exported),
    mark_tail_rec_calls_in_scc(AddGoalFeature, WarnNonTailRecParams,
        SCC, set.to_sorted_list(SCC), !ModuleInfo),
    mark_tail_rec_calls_in_sccs(AddGoalFeature, WarnNonTailRecParams,
        SCCEntries, !ModuleInfo).

:- pred mark_tail_rec_calls_in_scc(add_goal_feature::in,
    warn_non_tail_rec_params::in,
    set(pred_proc_id)::in, list(pred_proc_id)::in,
    module_info::in, module_info::out) is det.

mark_tail_rec_calls_in_scc(_AddGoalFeature, _WarnNonTailRecParams, _SCC,
        [], !ModuleInfo).
mark_tail_rec_calls_in_scc(AddGoalFeature, WarnNonTailRecParams, SCC,
        [PredProcId | PredProcIds], !ModuleInfo) :-
    PredProcId = proc(PredId, ProcId),
    module_info_get_preds(!.ModuleInfo, PredTable0),
    map.lookup(PredTable0, PredId, PredInfo0),
    pred_info_get_proc_table(PredInfo0, ProcTable0),
    map.lookup(ProcTable0, ProcId, ProcInfo0),

    maybe_override_warn_params_for_proc(ProcInfo0,
        WarnNonTailRecParams, WarnNonTailRecParamsForProc),

    do_mark_tail_rec_calls_in_proc(AddGoalFeature, WarnNonTailRecParamsForProc,
        !.ModuleInfo, SCC, PredId, ProcId, PredInfo0, ProcInfo0, ProcInfo,
        _WasProcChanged, [], _Specs),

    map.det_update(ProcId, ProcInfo, ProcTable0, ProcTable),
    pred_info_set_proc_table(ProcTable, PredInfo0, PredInfo),
    map.det_update(PredId, PredInfo, PredTable0, PredTable),
    module_info_set_preds(PredTable, !ModuleInfo),

    mark_tail_rec_calls_in_scc(AddGoalFeature, WarnNonTailRecParams, SCC,
        PredProcIds, !ModuleInfo).

%---------------------------------------------------------------------------%
%---------------------------------------------------------------------------%

:- pred mark_tail_rec_call_options_for_llds_code_gen(globals::in,
    add_goal_feature::out, warn_non_tail_rec_params::out) is det.

mark_tail_rec_call_options_for_llds_code_gen(Globals, AddGoalFeature,
        WarnNonTailRecParams) :-
    globals.lookup_bool_option(Globals, exec_trace_tail_rec,
        ExecTraceTailRec),
    (
        ExecTraceTailRec = yes,
        AddGoalFeature = add_goal_feature_self_for_debug
    ;
        ExecTraceTailRec = no,
        AddGoalFeature = do_not_add_goal_feature
    ),
    globals.lookup_bool_option(Globals, warn_non_tail_recursion_self,
        WarnNonTailSelfRecBool),
    (
        WarnNonTailSelfRecBool = yes,
        WarnNonTailSelfRecOpt = warn_non_tail_self_rec
    ;
        WarnNonTailSelfRecBool = no,
        WarnNonTailSelfRecOpt = do_not_warn_non_tail_self_rec
    ),
    globals.lookup_bool_option(Globals, warn_non_tail_recursion_mutual,
        WarnNonTailMutualRecBool),
    (
        WarnNonTailMutualRecBool = yes,
        WarnNonTailMutualRecOpt = warn_non_tail_mutual_rec
    ;
        WarnNonTailMutualRecBool = no,
        WarnNonTailMutualRecOpt = do_not_warn_non_tail_mutual_rec
    ),
    WarnNonTailRecParams = warn_non_tail_rec_params(we_warning,
        WarnNonTailSelfRecOpt, WarnNonTailMutualRecOpt).

    % maybe_override_warn_params_for_proc(ProcInfo, WarnParams,
    %   WarnParamsForProc):
    %
    % If the given procedure has a pragma that governs what non-tail recursion
    % warnings (if any) we should generate for its code, return a value for
    % WarnParamsForProc that reflects this pragma. Otherwise, return the
    % WarnParams, the parameters that apply by default.
    %
:- pred maybe_override_warn_params_for_proc(proc_info::in,
    warn_non_tail_rec_params::in, warn_non_tail_rec_params::out) is det.

maybe_override_warn_params_for_proc(ProcInfo, WarnParams, WarnParamsForProc) :-
    proc_info_get_maybe_require_tailrec_info(ProcInfo, MaybeRequireTailRec),
    (
        MaybeRequireTailRec = no,
        WarnParamsForProc = WarnParams
    ;
        MaybeRequireTailRec = yes(Pragma),
        (
            Pragma = suppress_tailrec_warnings(_),
            WarnParamsForProc = no_warnings_non_tail_rec_params
        ;
            Pragma = enable_tailrec_warnings(WarnOrError, RecType, _Context),
            (
                RecType = only_self_recursion_must_be_tail,
                SelfRec = warn_non_tail_self_rec,
                MutualRec = do_not_warn_non_tail_mutual_rec
            ;
                RecType = both_self_and_mutual_recursion_must_be_tail,
                SelfRec = warn_non_tail_self_rec,
                MutualRec = warn_non_tail_mutual_rec
            ),
            WarnParamsForProc =
                warn_non_tail_rec_params(WarnOrError, SelfRec, MutualRec)
        )
    ).

%---------------------------------------------------------------------------%

mark_tail_rec_calls_in_pred_for_llds_code_gen(SCCMap, PredId, !ModuleInfo,
        !PredInfo, !Specs) :-
    % We don't update ModuleInfo. Nevertheless, the passes_aux traversal
    % that our caller uses to call us requires us to pass back a new
    % ModuleInfo, even though it will itself put the updated PredInfo
    % back into ModuleInfo.
    module_info_get_globals(!.ModuleInfo, Globals),
    mark_tail_rec_call_options_for_llds_code_gen(Globals, AddGoalFeature,
        WarnNonTailRecParams),
    ProcIds = pred_info_non_imported_procids(!.PredInfo),
    mark_tail_rec_calls_in_procs_for_llds_code_gen(AddGoalFeature,
        WarnNonTailRecParams, !.ModuleInfo, SCCMap, PredId, ProcIds,
        !PredInfo, !Specs).

:- pred mark_tail_rec_calls_in_procs_for_llds_code_gen(add_goal_feature::in,
    warn_non_tail_rec_params::in, module_info::in,
    scc_map(pred_proc_id)::in, pred_id::in, list(proc_id)::in,
    pred_info::in, pred_info::out,
    list(error_spec)::in, list(error_spec)::out) is det.

mark_tail_rec_calls_in_procs_for_llds_code_gen(_AddGoalFeature,
        _WarnNonTailRecParams, _ModuleInfo,
        _SCCMap, _PredId, [], !PredInfo, !Specs).
mark_tail_rec_calls_in_procs_for_llds_code_gen(AddGoalFeature,
        WarnNonTailRecParams, ModuleInfo, SCCMap,
        PredId, [ProcId | ProcIds], !PredInfo, !Specs) :-
    pred_info_proc_info(!.PredInfo, ProcId, ProcInfo0),
    maybe_override_warn_params_for_proc(ProcInfo0, WarnNonTailRecParams,
        WarnNonTailRecParamsForProc),
    map.lookup(SCCMap, proc(PredId, ProcId), SCC),
    do_mark_tail_rec_calls_in_proc(AddGoalFeature, WarnNonTailRecParamsForProc,
        ModuleInfo, SCC, PredId, ProcId, !.PredInfo, ProcInfo0, ProcInfo,
        WasProcChanged, !Specs),
    (
        WasProcChanged = proc_was_not_changed
    ;
        WasProcChanged = proc_may_have_been_changed,
        pred_info_set_proc_info(ProcId, ProcInfo, !PredInfo)
    ),
    mark_tail_rec_calls_in_procs_for_llds_code_gen(AddGoalFeature,
        WarnNonTailRecParams, ModuleInfo, SCCMap,
        PredId, ProcIds, !PredInfo, !Specs).

%---------------------------------------------------------------------------%

mark_tail_rec_calls_in_proc_for_llds_code_gen(ModuleInfo, PredId, ProcId,
        PredInfo, SCCMap, !ProcInfo, !Specs) :-
    module_info_get_globals(ModuleInfo, Globals),
    mark_tail_rec_call_options_for_llds_code_gen(Globals, AddGoalFeature,
        WarnNonTailRecParams),
    maybe_override_warn_params_for_proc(!.ProcInfo, WarnNonTailRecParams,
        WarnNonTailRecParamsForProc),
    map.lookup(SCCMap, proc(PredId, ProcId), SCC),
    % mark_tail_rec_call_options_for_llds_code_gen is called only when we are
    % doing proc-by-proc, as opposed to phase-by-phase, code generation.
    % For this, we don't need to put the new proc_info back into its pred_info.
    do_mark_tail_rec_calls_in_proc(AddGoalFeature, WarnNonTailRecParamsForProc,
        ModuleInfo, SCC, PredId, ProcId, PredInfo, !ProcInfo,
        _WasProcChanged, !Specs).

%---------------------------------------------------------------------------%
%---------------------------------------------------------------------------%

:- type add_goal_feature
    --->    do_not_add_goal_feature
    ;       add_goal_feature_self_for_debug
    ;       add_goal_feature_self_or_mutual.

:- type was_proc_changed
    --->    proc_was_not_changed
    ;       proc_may_have_been_changed.

:- pred do_mark_tail_rec_calls_in_proc(add_goal_feature::in,
    warn_non_tail_rec_params::in, module_info::in, set(pred_proc_id)::in,
    pred_id::in, proc_id::in, pred_info::in, proc_info::in, proc_info::out,
    was_proc_changed::out, list(error_spec)::in, list(error_spec)::out) is det.

do_mark_tail_rec_calls_in_proc(AddGoalFeature, WarnNonTailRecParams,
        ModuleInfo, SCC, PredId, ProcId, PredInfo, !ProcInfo,
        WasProcChanged, !Specs) :-
    proc_info_interface_determinism(!.ProcInfo, Detism),
    determinism_components(Detism, _CanFail, SolnCount),
    (
        % In at_most_many procedures, we cannot in general know at compile time
        % whether we can delete the current stack frame at a tail call.
        %
        % For at_most_zero procedures, there is no point in handling tail calls
        % specially.
        ( SolnCount = at_most_many
        ; SolnCount = at_most_zero
        ),
        WasProcChanged = proc_was_not_changed
    ;
        ( SolnCount = at_most_one
        ; SolnCount = at_most_many_cc
        ),

        % It is reasonably common that we don't need to check for tail calls
        % at all.
        ( if
            AddGoalFeature = do_not_add_goal_feature,
            WarnNonTailRecParams = warn_non_tail_rec_params(_WarnOrError,
                do_not_warn_non_tail_self_rec, do_not_warn_non_tail_mutual_rec)
        then
            WasProcChanged = proc_was_not_changed
        else
            pred_info_get_arg_types(PredInfo, Types),
            proc_info_get_goal(!.ProcInfo, Goal0),
            proc_info_get_argmodes(!.ProcInfo, Modes),
            proc_info_get_headvars(!.ProcInfo, HeadVars),
            proc_info_get_vartypes(!.ProcInfo, VarTypes),
            find_maybe_output_args(ModuleInfo, Types, Modes, HeadVars,
                Outputs),

            Info0 = mark_tail_rec_calls_info(AddGoalFeature, ModuleInfo,
                PredInfo, proc(PredId, ProcId), SCC, VarTypes,
                WarnNonTailRecParams,
                not_found_any_rec_calls, not_found_self_tail_rec_calls, []),
            mark_tail_rec_calls_in_goal(Goal0, Goal, at_tail(Outputs), _,
                Info0, Info),
            Info = mark_tail_rec_calls_info(_, _, _, _, _, _, _,
                FoundAnyRecCalls, FoundSelfTailRecCalls, GoalSpecs),

            proc_info_set_goal(Goal, !ProcInfo),
            (
                FoundAnyRecCalls = not_found_any_rec_calls,
                proc_info_get_maybe_require_tailrec_info(!.ProcInfo,
                    MaybeRequireTailRec),
                (
                    MaybeRequireTailRec = no
                ;
                    MaybeRequireTailRec = yes(RequireTailRecInfo),
                    (
                        RequireTailRecInfo = enable_tailrec_warnings(_, _,
                            Context)
                    ;
                        RequireTailRecInfo = suppress_tailrec_warnings(Context)
                    ),
                    PredOrFunc = pred_info_is_pred_or_func(PredInfo),
                    pred_info_get_name(PredInfo, PredName),
                    pred_info_get_orig_arity(PredInfo, PredArity),
                    SimpleCallId = simple_call_id(PredOrFunc,
                        unqualified(PredName), PredArity),
                    add_message_for_no_tail_or_nontail_recursive_calls(
                        SimpleCallId, Context, !Specs)
                )
            ;
                FoundAnyRecCalls = found_any_rec_calls
            ),
            (
                FoundSelfTailRecCalls = not_found_self_tail_rec_calls,
                TailCallEvents = has_no_tail_call_event
            ;
                FoundSelfTailRecCalls = found_self_tail_rec_calls,
                TailCallEvents = has_tail_call_event
            ),
            (
                ( AddGoalFeature = do_not_add_goal_feature
                ; AddGoalFeature = add_goal_feature_self_or_mutual
                )
            ;
                AddGoalFeature = add_goal_feature_self_for_debug,
                proc_info_set_has_tail_call_event(TailCallEvents, !ProcInfo)
            ),
            !:Specs = GoalSpecs ++ !.Specs,
            WasProcChanged = proc_may_have_been_changed
        )
    ).

:- pred find_maybe_output_args(module_info::in,
     list(mer_type)::in, list(mer_mode)::in, list(prog_var)::in,
     list(maybe(prog_var))::out) is det.

find_maybe_output_args(ModuleInfo, Types, Modes, Vars, Outputs) :-
    ( if
        find_maybe_output_args_2(ModuleInfo, Types, Modes, Vars, OutputsPrime)
    then
        Outputs = OutputsPrime
    else
        unexpected($module, $pred, "list length mismatch")
    ).

:- pred find_maybe_output_args_2(module_info::in,
    list(mer_type)::in, list(mer_mode)::in, list(prog_var)::in,
    list(maybe(prog_var))::out) is semidet.

find_maybe_output_args_2(_, [], [], [], []).
find_maybe_output_args_2(ModuleInfo, [Type | Types], [Mode | Modes],
        [Var | Vars], [OutputVar | OutputVars]) :-
    require_det (
        mode_to_top_functor_mode(ModuleInfo, Mode, Type, TopFunctorMode),
        (
            ( TopFunctorMode = top_in
            ; TopFunctorMode = top_unused
            ),
            OutputVar = no
        ;
            TopFunctorMode = top_out,
            IsDummy = check_dummy_type(ModuleInfo, Type),
            (
                IsDummy = is_not_dummy_type,
                OutputVar = yes(Var)
            ;
                IsDummy = is_dummy_type,
                OutputVar = no
            )
        )
    ),
    find_maybe_output_args_2(ModuleInfo, Types, Modes, Vars, OutputVars).

%---------------------------------------------------------------------------%

    % Is the current position within the procedure a tail position?
    % If it is, what are the output arguments?
    %
:- type at_tail
    --->    at_tail(list(maybe(prog_var)))
    ;       not_at_tail(later_rec_call).

:- type later_rec_call
    --->    have_seen_later_rec_call
    ;       have_not_seen_later_rec_call.

:- type maybe_warn_non_tail_self_rec
    --->    do_not_warn_non_tail_self_rec
    ;       warn_non_tail_self_rec.

:- type maybe_warn_non_tail_mutual_rec
    --->    do_not_warn_non_tail_mutual_rec
    ;       warn_non_tail_mutual_rec.

:- type warn_non_tail_rec_params
    --->    warn_non_tail_rec_params(
                warning_or_error,
                maybe_warn_non_tail_self_rec,
                maybe_warn_non_tail_mutual_rec
            ).

:- func no_warnings_non_tail_rec_params = warn_non_tail_rec_params.

no_warnings_non_tail_rec_params = Params :-
    % Since neither SelfRec nor MutualRec is set, the value of
    % WarnOrError does not matter.
    Params = warn_non_tail_rec_params(we_warning,
        do_not_warn_non_tail_self_rec, do_not_warn_non_tail_mutual_rec).

    % Has any self-recursive tail call been found so far?
    %
    % We use this to set the has_tail_call_event field in the procedure's
    % proc_info. The LLDS debugger uses this field's value to decide
    % whether to prepare for any TAIL events in the procedure body.
    %
    % For the time being, the debugger supports TAIL events only for
    % *self*-tail-recursive calls, and not for mutually-tail-recursive calls.
    %
:- type found_self_tail_rec_calls
    --->    not_found_self_tail_rec_calls
    ;       found_self_tail_rec_calls.

    % Have we found any recursive call been found so far?
    %
    % We use this to generate warnings about pragmas that intend to control
    % how recursive calls that are not *tail* recursive should be treated,
    % when the procedure they are about contains no recursive calls at all,
    % either self-recursive or (if we have SCC information) mutually recursive.
    %
:- type found_any_rec_calls
    --->    not_found_any_rec_calls
    ;       found_any_rec_calls.

:- type call_is_self_or_mutual_rec
    --->    call_is_self_rec
    ;       call_is_mutual_rec.

:- type mark_tail_rec_calls_info
    --->    mark_tail_rec_calls_info(
                mtc_add_feature             :: add_goal_feature,
                mtc_module                  :: module_info,
                mtc_pred_info               :: pred_info,
                mtc_cur_proc                :: pred_proc_id,
                mtc_cur_scc                 :: set(pred_proc_id),
                mtc_vartypes                :: vartypes,
                mtc_warn_params             :: warn_non_tail_rec_params,
                mtc_any_rec_calls           :: found_any_rec_calls,
                mtc_self_tail_rec_calls     :: found_self_tail_rec_calls,
                mtc_error_specs             :: list(error_spec)
            ).

%---------------------------------------------------------------------------%

    % mark_tail_rec_calls_in_goal(Goal0, Goal, !AtTail, !Info):
    %
    % This predicate performs a backwards traversal of Goal0.
    % It can transform Goal0 into Goal
    %
    % - by adding the feature feature_debug_self_tail_rec_call feature to
    %   self-tail-recursive calls, i.e. calls to !.Info ^ mtc_cur_proc,
    %   if !.Info ^ mtc_add_feature is add_goal_feature_self_for_debug, or
    %
    % - by adding the feature feature_self_or_mutual_tail_rec_call to
    %   either self- or mutually-tail-recursive calls, i.e. calls to either
    %   !.Info ^ mtc_cur_proc or to a procedure in !.Info ^ mtc_cur_scc,
    %   if !.Info ^ mtc_add_feature is add_goal_feature_self_or_mutual, or
    %
    % It adds nothing to the goal if !.Info ^ mtc_add_feature is
    % do_not_add_goal_feature.
    %
    % If the value of !.Info ^ mtc_warn_params calls for it, we generate
    % warnings for non-tail recursive calls, and add them to !Info.
    %
    % Since we do a *backward* traversal, AtTail0 describes the situation
    % *after* Goal0, and the value of AtTail we return describes the situation
    % *before* Goal0 (which is also the situation before its marked-up twin
    % Goal).
    %
    % When the backwards traversal starts, the value of AtTail0 is initialized
    % to at_tail(MaybeOutputArgs). If Goal0 neither is a tailcall nor contains
    % a tailcall, but could actually follow a tailcall (which is possible
    % if it is either an assignment unification that simply renames an output
    % variable, or a conjunction of such unifications), then we return AtTail
    % as at_tail, but with a value of MaybeOutputArgs that is updated
    % to account for the renaming. We want this because Goal0 is a tail
    % recursive call only if (a) AtTail0 is at_tail(MaybeOutputArgs),
    % it is a call to !.Info ^ mtc_cur_proc or to a procedure in !.Info ^
    % mtc_cur_scc whose argument list matches MaybeOutputArgs in the
    % output argument positions, i.e. the positions in which MaybeOutputArgs
    % has a yes(_).
    %
    % When we see a goal that cannot follow a tail call (a goal which may be
    % a tail call itself), we return not_at_tail as the value of AtTail.
    % Its argument will say whether we have seen a recursive call (tail
    % or otherwise) earlier on the backwards traversal, i.e. in Goal or
    % in code that follows Goal.
    %
    % We record whether we have found any (self or mutual) recursive calls
    % in the mtc_any_rec_calls and mtc_self_tail_rec_calls fields.
    %
:- pred mark_tail_rec_calls_in_goal(hlds_goal::in, hlds_goal::out,
    at_tail::in, at_tail::out,
    mark_tail_rec_calls_info::in, mark_tail_rec_calls_info::out) is det.

mark_tail_rec_calls_in_goal(Goal0, Goal, AtTail0, AtTail, !Info) :-
    Goal0 = hlds_goal(GoalExpr0, GoalInfo0),
    (
        ( GoalExpr0 = call_foreign_proc(_, _, _, _, _, _, _)
        ; GoalExpr0 = generic_call(_, _, _, _, _)
        % Note: we don't give tailcall warnings for negated goals, maybe we
        % should?
        ; GoalExpr0 = negation(_)
        ),
        Goal = Goal0,
        not_at_tail(AtTail0, AtTail)
    ;
        GoalExpr0 = scope(Reason, SubGoal0),
        (
            Reason = disable_warnings(HeadWarning, TailWarnings),
            ( if
                ( HeadWarning = goal_warning_non_tail_recursive_calls
                ; list.member(goal_warning_non_tail_recursive_calls,
                    TailWarnings)
                )
            then
                OldWarnParams = !.Info ^ mtc_warn_params,
                InnerWarnParams = no_warnings_non_tail_rec_params,
                InnerInfo0 = !.Info ^ mtc_warn_params := InnerWarnParams,
                mark_tail_rec_calls_in_goal(SubGoal0, SubGoal, AtTail0, AtTail,
                    InnerInfo0, InnerInfo),
                !:Info = InnerInfo ^ mtc_warn_params := OldWarnParams
            else
                mark_tail_rec_calls_in_goal(SubGoal0, SubGoal, AtTail0, AtTail,
                    !Info)
            )
        ;
            ( Reason = exist_quant(_)
            ; Reason = promise_solutions(_, _)
            ; Reason = commit(_)
            ),
            not_at_tail(AtTail0, AtTail1),
            mark_tail_rec_calls_in_goal(SubGoal0, SubGoal, AtTail1, AtTail,
                !Info)
        ;
            ( Reason = promise_purity(_)
            ; Reason = barrier(_)
            ; Reason = from_ground_term(_, _)
            ; Reason = trace_goal(_, _, _, _, _)
            ; Reason = loop_control(_, _, _)
            ),
            mark_tail_rec_calls_in_goal(SubGoal0, SubGoal, AtTail0, AtTail,
                !Info)
        ;
            ( Reason = require_detism(_)
            ; Reason = require_complete_switch(_)
            ; Reason = require_switch_arms_detism(_, _)
            ),
            unexpected($file, $pred, "unexpected scope kind")
        ),
        Goal = hlds_goal(scope(Reason, SubGoal), GoalInfo0)
    ;
        GoalExpr0 = unify(LHS, _, _, Unify0, _),
        Goal = Goal0,
        ModuleInfo = !.Info ^ mtc_module,
        VarTypes = !.Info ^ mtc_vartypes,
        ( if var_is_of_dummy_type(ModuleInfo, VarTypes, LHS) then
            % Unifications involving dummy type variables are no-ops,
            % and do not inhibit a preceding tail call.
            AtTail = AtTail0
        else
            (
                ( Unify0 = construct(_, _, _, _, _, _, _)
                ; Unify0 = deconstruct(_, _, _, _, _, _)
                ; Unify0 = simple_test(_, _)
                ; Unify0 = complicated_unify(_, _, _)
                ),
                not_at_tail(AtTail0, AtTail)
            ;
                Unify0 = assign(ToVar, FromVar),
                ( if
                    AtTail0 = at_tail(Outputs0),
                    is_output_arg_rename(ToVar, FromVar, Outputs0, Outputs)
                then
                    AtTail = at_tail(Outputs)
                else
                    AtTail = not_at_tail(have_not_seen_later_rec_call)
                )
            )
        )
    ;
        GoalExpr0 = plain_call(CalleePredId, CalleeProcId, Args, Builtin,
            _UnifyContext, _SymName),
        CalleePredProcId = proc(CalleePredId, CalleeProcId),
        CurPredProcId = !.Info ^ mtc_cur_proc,
        CurSCCPredProcIds = !.Info ^ mtc_cur_scc,
        ( if
            Builtin = not_builtin,
            ( if
                CalleePredProcId = CurPredProcId
            then
                SelfRecursion = call_is_self_rec
            else if
                set.member(CalleePredProcId, CurSCCPredProcIds)
            then
                SelfRecursion = call_is_mutual_rec
            else
                false
            )
        then
            !Info ^ mtc_any_rec_calls := found_any_rec_calls,
            ( if
                AtTail0 = at_tail(Outputs),
                match_output_args(Outputs, Args)
            then
                AddFeature = !.Info ^ mtc_add_feature,
                (
                    AddFeature = do_not_add_goal_feature,
                    Goal = Goal0
                ;
                    AddFeature = add_goal_feature_self_for_debug,
                    (
                        SelfRecursion = call_is_self_rec,
                        !Info ^ mtc_self_tail_rec_calls :=
                            found_self_tail_rec_calls,
                        goal_info_add_feature(feature_debug_self_tail_rec_call,
                            GoalInfo0, GoalInfo),
                        Goal = hlds_goal(GoalExpr0, GoalInfo)
                    ;
                        SelfRecursion = call_is_mutual_rec,
                        Goal = Goal0
                    )
                ;
                    AddFeature = add_goal_feature_self_or_mutual,
                    goal_info_add_feature(feature_self_or_mutual_tail_rec_call,
                        GoalInfo0, GoalInfo),
                    Goal = hlds_goal(GoalExpr0, GoalInfo)
                )
            else
                Goal = Goal0,
                Context = goal_info_get_context(GoalInfo0),
                maybe_report_nontail_recursive_call(CalleePredId,
                    SelfRecursion, Context, AtTail0, !Info)
            ),
            AtTail = not_at_tail(have_seen_later_rec_call)
        else
            Goal = Goal0,
            not_at_tail(AtTail0, AtTail)
        )
    ;
        GoalExpr0 = conj(ConjType, Goals0),
        (
            ConjType = plain_conj,
            AtTail1 = AtTail0
        ;
            ConjType = parallel_conj,
            % Tail calls in parallel conjunctions are only supported when
            % loop control is enabled. But loop control would have rewritten
            % the conjunction into a loop control scope, and therefore any
            % parallel conjunctions we find at *this* point cannot support
            % tail calls.
            not_at_tail(AtTail0, AtTail1)
        ),
        list.reverse(Goals0, RevGoals0),
        mark_tail_rec_calls_in_conj(RevGoals0, RevGoals, AtTail1, AtTail,
            !Info),
        list.reverse(RevGoals, Goals),
        GoalExpr = conj(ConjType, Goals),
        Goal = hlds_goal(GoalExpr, GoalInfo0)
    ;
        GoalExpr0 = disj(Disjs0),
        project_seen_later_rec_call(AtTail0, SeenLaterRecCall0),
        list.map_foldl2(mark_tail_rec_calls_in_disj(AtTail0), Disjs0, Disjs,
            SeenLaterRecCall0, SeenLaterRecCall, !Info),
        AtTail = not_at_tail(SeenLaterRecCall),
        GoalExpr = disj(Disjs),
        Goal = hlds_goal(GoalExpr, GoalInfo0)
    ;
        GoalExpr0 = switch(Var, CanFail, Cases0),
        project_seen_later_rec_call(AtTail0, SeenLaterRecCall0),
        list.map_foldl2(mark_tail_rec_calls_in_case(AtTail0), Cases0, Cases,
            SeenLaterRecCall0, SeenLaterRecCall, !Info),
        AtTail = not_at_tail(SeenLaterRecCall),
        GoalExpr = switch(Var, CanFail, Cases),
        Goal = hlds_goal(GoalExpr, GoalInfo0)
    ;
        GoalExpr0 = if_then_else(Vars, Cond0, Then0, Else0),
        mark_tail_rec_calls_in_goal(Then0, Then, AtTail0, AtTailBeforeThen,
            !Info),
        mark_tail_rec_calls_in_goal(Else0, Else, AtTail0, AtTailBeforeElse,
            !Info),
        project_seen_later_rec_call(AtTailBeforeThen, SeenRecCallInThen),
        project_seen_later_rec_call(AtTailBeforeElse, SeenRecCallInElse),
        ( if
            ( SeenRecCallInThen = have_seen_later_rec_call
            ; SeenRecCallInElse = have_seen_later_rec_call
            )
        then
            SeenRecCallAfterCond = have_seen_later_rec_call
        else
            SeenRecCallAfterCond = have_not_seen_later_rec_call
        ),
        AtTailAfterCond = not_at_tail(SeenRecCallAfterCond),
        mark_tail_rec_calls_in_goal(Cond0, Cond, AtTailAfterCond, AtTail,
            !Info),
        GoalExpr = if_then_else(Vars, Cond, Then, Else),
        Goal = hlds_goal(GoalExpr, GoalInfo0)
    ;
        GoalExpr0 = shorthand(_),
        unexpected($module, $pred, "shorthand")
    ).

:- pred is_output_arg_rename(prog_var::in, prog_var::in,
    list(maybe(prog_var))::in, list(maybe(prog_var))::out) is semidet.

is_output_arg_rename(ToVar, FromVar,
        [MaybeVar0 | MaybeVars0], [MaybeVar | MaybeVars]) :-
    (
        MaybeVar0 = yes(ToVar),
        MaybeVar = yes(FromVar),
        MaybeVars = MaybeVars0
    ;
        MaybeVar0 = no,
        MaybeVar = no,
        is_output_arg_rename(ToVar, FromVar, MaybeVars0, MaybeVars)
    ).

:- pred match_output_args(list(maybe(prog_var))::in, list(prog_var)::in)
    is semidet.

match_output_args([], []).
match_output_args([], [_ | _]) :-
    unexpected($module, $pred, "length mismatch").
match_output_args([_ | _], []) :-
    unexpected($module, $pred, "length mismatch").
match_output_args([MaybeOutputVar | MaybeOutputVars], [ArgVar | ArgVars]) :-
    (
        MaybeOutputVar = no
    ;
        MaybeOutputVar = yes(ArgVar)
    ),
    match_output_args(MaybeOutputVars, ArgVars).

:- pred mark_tail_rec_calls_in_conj(list(hlds_goal)::in, list(hlds_goal)::out,
    at_tail::in, at_tail::out,
    mark_tail_rec_calls_info::in, mark_tail_rec_calls_info::out) is det.

mark_tail_rec_calls_in_conj([], [], !AtTail, !Info).
mark_tail_rec_calls_in_conj([RevGoal0 | RevGoals0], [RevGoal | RevGoals],
        !AtTail, !Info) :-
    mark_tail_rec_calls_in_goal(RevGoal0, RevGoal, !AtTail, !Info),
    mark_tail_rec_calls_in_conj(RevGoals0, RevGoals, !AtTail, !Info).

:- pred mark_tail_rec_calls_in_disj(at_tail::in, hlds_goal::in, hlds_goal::out,
    later_rec_call::in, later_rec_call::out,
    mark_tail_rec_calls_info::in, mark_tail_rec_calls_info::out) is det.

mark_tail_rec_calls_in_disj(AtTail0, !Disjunct, !SeenLaterRecCall, !Info) :-
    mark_tail_rec_calls_in_goal(!Disjunct, AtTail0, AtTail, !Info),
    accumulate_seen_later_rec_call(AtTail, !SeenLaterRecCall).

:- pred mark_tail_rec_calls_in_case(at_tail::in, case::in, case::out,
    later_rec_call::in, later_rec_call::out,
    mark_tail_rec_calls_info::in, mark_tail_rec_calls_info::out) is det.

mark_tail_rec_calls_in_case(AtTail0, Case0, Case, !SeenLaterRecCall, !Info) :-
    Case0 = case(MainConsId, OtherConsIds, Goal0),
    mark_tail_rec_calls_in_goal(Goal0, Goal, AtTail0, AtTail, !Info),
    accumulate_seen_later_rec_call(AtTail, !SeenLaterRecCall),
    Case = case(MainConsId, OtherConsIds, Goal).

:- pred accumulate_seen_later_rec_call(at_tail::in,
    later_rec_call::in, later_rec_call::out) is det.

accumulate_seen_later_rec_call(AtTail, !SeenLaterRecCall) :-
    (
        AtTail = at_tail(_)
    ;
        AtTail = not_at_tail(AtTailSeenLaterRecCall),
        (
            AtTailSeenLaterRecCall = have_not_seen_later_rec_call
        ;
            AtTailSeenLaterRecCall = have_seen_later_rec_call,
            !:SeenLaterRecCall = have_seen_later_rec_call
        )
    ).

:- pred project_seen_later_rec_call(at_tail::in, later_rec_call::out) is det.

project_seen_later_rec_call(AtTail, SeenLaterRecCall) :-
    (
        AtTail = at_tail(_),
        SeenLaterRecCall = have_not_seen_later_rec_call
    ;
        AtTail = not_at_tail(SeenLaterRecCall)
    ).

:- pred not_at_tail(at_tail::in, at_tail::out) is det.

not_at_tail(Before, After) :-
    (
        Before = at_tail(_),
        After = not_at_tail(have_not_seen_later_rec_call)
    ;
        Before = not_at_tail(_),
        After = Before
    ).

%---------------------------------------------------------------------------%

:- pred maybe_report_nontail_recursive_call(pred_id::in,
    call_is_self_or_mutual_rec::in, prog_context::in, at_tail::in,
    mark_tail_rec_calls_info::in, mark_tail_rec_calls_info::out) is det.

maybe_report_nontail_recursive_call(CalleePredId, SelfOrMutualRec, Context,
        AtTail, !Info) :-
    !.Info ^ mtc_warn_params = warn_non_tail_rec_params(WarnOrError,
        WarnNonTailSelfRec, WarnNonTailMutualRec),
    ( if
        require_complete_switch [SelfOrMutualRec]
        (
            SelfOrMutualRec = call_is_self_rec,
            WarnNonTailSelfRec = warn_non_tail_self_rec
        ;
            SelfOrMutualRec = call_is_mutual_rec,
            WarnNonTailMutualRec = warn_non_tail_mutual_rec
        )
    then
        (
            ( AtTail = at_tail(_)
            ; AtTail = not_at_tail(have_not_seen_later_rec_call)
            ),
            report_nontail_recursive_call(CalleePredId, SelfOrMutualRec,
                WarnOrError, Context, !Info)
        ;
            AtTail = not_at_tail(have_seen_later_rec_call)
            % Never report calls that are followed by recursive calls.
            % NOTE: We could report these issues, doing so would help
            % programmers to ensure that they use constant stack space.
            % This was not part of the initial design for the pragma but
            % I (Paul) would like to add support for it with another option
            % in the near future.
        )
    else
        true
    ).

:- pred report_nontail_recursive_call(pred_id::in,
    call_is_self_or_mutual_rec::in, warning_or_error::in, prog_context::in,
    mark_tail_rec_calls_info::in, mark_tail_rec_calls_info::out) is det.

report_nontail_recursive_call(CalleePredId, SelfOrMutualRec, WarnOrError,
        Context, !Info) :-
    proc(_, CallerProcId) = !.Info ^ mtc_cur_proc,
    CallerPredInfo = !.Info ^ mtc_pred_info,
    CallerPredOrFunc = pred_info_is_pred_or_func(CallerPredInfo),
    CallerName = pred_info_name(CallerPredInfo),
    CallerArity = pred_info_orig_arity(CallerPredInfo),
    CallerId = simple_call_id(CallerPredOrFunc, unqualified(CallerName),
        CallerArity),
    Specs0 = !.Info ^ mtc_error_specs,
    (
        SelfOrMutualRec = call_is_self_rec,
        add_message_for_nontail_self_recursive_call(CallerId, CallerProcId,
            Context, WarnOrError, Specs0, Specs)
    ;
        SelfOrMutualRec = call_is_mutual_rec,
        module_info_pred_info(!.Info ^ mtc_module, CalleePredId,
            CalleePredInfo),
        CalleePredOrFunc = pred_info_is_pred_or_func(CalleePredInfo),
        CalleeName = qualified(pred_info_module(CalleePredInfo),
            pred_info_name(CalleePredInfo)),
        CalleeArity = pred_info_orig_arity(CalleePredInfo),
        CalleeId = simple_call_id(CalleePredOrFunc, CalleeName, CalleeArity),
        add_message_for_nontail_mutual_recursive_call(CallerId,
            CallerProcId, CalleeId, WarnOrError, Context, Specs0, Specs)
    ),
    !Info ^ mtc_error_specs := Specs.

%---------------------------------------------------------------------------%

add_message_for_nontail_self_recursive_call(SimpleCallId, ProcId, Context,
        WarnOrError, !Specs) :-
    woe_to_severity_and_string(WarnOrError, Severity, WarnOrErrorWord),
    proc_id_to_int(ProcId, ProcNumber0),
    ProcNumber = ProcNumber0 + 1,
    Pieces = [words("In mode number"), int_fixed(ProcNumber),
        words("of"), simple_call(SimpleCallId), suffix(":"), nl,
        WarnOrErrorWord,
        words("self-recursive call is not tail recursive."), nl],
    Msg = simple_msg(Context, [always(Pieces)]),
    Spec = error_spec(Severity, phase_code_gen, [Msg]),
    !:Specs = [Spec | !.Specs].

add_message_for_nontail_mutual_recursive_call(CallerId, CallerProcId,
        CalleeId, WarnOrError, Context, !Specs) :-
    woe_to_severity_and_string(WarnOrError, Severity, WarnOrErrorWord),
    proc_id_to_int(CallerProcId, ProcNumber0),
    ProcNumber = ProcNumber0 + 1,
    Pieces = [words("In mode number"), int_fixed(ProcNumber),
        words("of"), simple_call(CallerId), suffix(":"), nl,
        WarnOrErrorWord, words("mutually recursive call to"),
        simple_call(CalleeId), words("is not tail recursive."), nl],
    Msg = simple_msg(Context, [always(Pieces)]),
    Spec = error_spec(Severity, phase_code_gen, [Msg]),
    !:Specs = [Spec | !.Specs].

:- pred woe_to_severity_and_string(warning_or_error::in,
    error_severity::out, format_component::out) is det.

woe_to_severity_and_string(we_warning, severity_warning, words("warning:")).
woe_to_severity_and_string(we_error, severity_error, words("error:")).

add_message_for_no_tail_or_nontail_recursive_calls(SimpleCallId, Context,
        !Specs) :-
    SimpleCallId = simple_call_id(PredOrFunc, _, _),
    Pieces = [words("In"), pragma_decl("require_tail_recursion"),
        words("for"), simple_call(SimpleCallId), suffix(":"), nl,
        words("warning: the code defining this"), p_or_f(PredOrFunc),
        words("contains no recursive calls at all,"),
        words("tail-recursive or otherwise."), nl],
    Msg = simple_msg(Context, [always(Pieces)]),
    Spec = error_spec(severity_warning, phase_code_gen, [Msg]),
    !:Specs = [Spec | !.Specs].

%---------------------------------------------------------------------------%
:- end_module hlds.mark_tail_calls.
%---------------------------------------------------------------------------%
