record_syntax_errors.m:027: Error: `:- mode' declaration for [38;5;87mfunction[39;49m
record_syntax_errors.m:027:   [38;5;87m`field8'/1[39;49m [38;5;203mwithout[39;49m a corresponding `:- func'
record_syntax_errors.m:027:   declaration.
record_syntax_errors.m:027: Inferred :- func field8(record_syntax_errors.cons2)
record_syntax_errors.m:027:   = int.
record_syntax_errors.m:033: In DCG field update goal:
record_syntax_errors.m:033:   error: expected [38;5;40mfield name,[39;49m got [38;5;203m`Field'.[39;49m
record_syntax_errors.m:036: Error: expected [38;5;40m`^ field1 ^ ... ^ fieldN'[39;49m on the
record_syntax_errors.m:036:   left hand side of `:=' in DCG field update goal,
record_syntax_errors.m:036:   got [38;5;203m`X'.[39;49m
record_syntax_errors.m:047: In clause for predicate `construct_exist_cons'/1:
record_syntax_errors.m:047:   error: undefined symbol `field2 :='/2.
record_syntax_errors.m:010:   Field `field2' cannot be updated because the
record_syntax_errors.m:010:   existentially quantified type variable `T' occurs
record_syntax_errors.m:010:   in the types of field `field2' and some other
record_syntax_errors.m:010:   field in definition of constructor
record_syntax_errors.m:010:   `record_syntax_errors.exist_cons'/3.
record_syntax_errors.m:051: In clause for predicate `arg_type_error'/1:
record_syntax_errors.m:051:   in argument 2 of functor `field6 :=/2':
record_syntax_errors.m:051:   in unification of [38;5;87margument[39;49m
record_syntax_errors.m:051:   and term [38;5;87m`'field7 :='(V_10, V_9)':[39;49m
record_syntax_errors.m:051:   type error in argument of functor `field7 :='/2.
record_syntax_errors.m:051:   [38;5;87mArgument 2[39;49m has type
record_syntax_errors.m:051:     [38;5;203mstring,[39;49m
record_syntax_errors.m:051:   expected type was
record_syntax_errors.m:051:     [38;5;40mint.[39;49m
record_syntax_errors.m:053: Error: clause for [38;5;87mpredicate `term_type_error'/1[39;49m
record_syntax_errors.m:053:   [38;5;203mwithout[39;49m a corresponding `:- pred' declaration.
record_syntax_errors.m:055: In clause for predicate `term_type_error'/1:
record_syntax_errors.m:055:   in argument 2 of functor `field6 :=/2':
record_syntax_errors.m:055:   in unification of [38;5;87margument[39;49m
record_syntax_errors.m:055:   and term [38;5;87m`'field4 :='(V_10, V_9)':[39;49m
record_syntax_errors.m:055:   type error in argument of functor `field4 :='/2.
record_syntax_errors.m:055:   [38;5;87mArgument 1[39;49m has type
record_syntax_errors.m:055:     [38;5;203mrecord_syntax_errors.cons2,[39;49m
record_syntax_errors.m:055:   expected type was
record_syntax_errors.m:055:     [38;5;40mrecord_syntax_errors.cons.[39;49m
record_syntax_errors.m:059: In declaration of function `field4'/1:
record_syntax_errors.m:059:   error: [38;5;87ma field access function for an exported[39;49m
record_syntax_errors.m:059:   [38;5;87mfield[39;49m [38;5;203mmust also be exported.[39;49m
record_syntax_errors.m:062: Error: [38;5;203mclause for automatic generated field access[39;49m
record_syntax_errors.m:062:   [38;5;203mfunction[39;49m [38;5;87m`field4'/1.[39;49m
record_syntax_errors.m:062:   Clauses for field access functions are
record_syntax_errors.m:062:   automatically generated by the compiler. To
record_syntax_errors.m:062:   supply your own definition for a field access
record_syntax_errors.m:062:   function, for example to check the input to a
record_syntax_errors.m:062:   field update, give the field of the constructor a
record_syntax_errors.m:062:   different name.
