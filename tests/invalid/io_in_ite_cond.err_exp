io_in_ite_cond.m:013: In `foo'((unique >> clobbered), (free >> unique)):
io_in_ite_cond.m:013:   error: `semidet' is not a valid determinism for a
io_in_ite_cond.m:013:   predicate that has I/O state arguments. The valid
io_in_ite_cond.m:013:   determinisms for such predicates are `det', `cc_multi'
io_in_ite_cond.m:013:   and `erroneous', since the I/O state can be neither
io_in_ite_cond.m:013:   duplicated nor destroyed.
io_in_ite_cond.m:020: In clause for `main(di, uo)':
io_in_ite_cond.m:020:   in argument 1 of call to predicate
io_in_ite_cond.m:020:   `io_in_ite_cond.foo'/2:
io_in_ite_cond.m:020:   mode error: variable `STATE_VARIABLE_IO_0' has
io_in_ite_cond.m:020:   instantiatedness `mostly_unique',
io_in_ite_cond.m:020:   expected instantiatedness was `unique'.
io_in_ite_cond.m:020:   This kind of uniqueness mismatch is usually caused by
io_in_ite_cond.m:020:   doing input/output or some other kind of destructive
io_in_ite_cond.m:020:   update in a context where it can be backtracked over,
io_in_ite_cond.m:020:   such as the condition of an if-then-else.
