#-----------------------------------------------------------------------------#

# Set up to test a particular workspace.
ifdef WORKSPACE

# Make sure we don't get the installed versions of the libraries.
LINK_STATIC = yes
include $(WORKSPACE)/Mmake.workspace

endif

#
# Note: Mmake lets you override MCFLAGS for a particular file by setting
# MCFLAGS-foo.  Similarly, you can override GRADEFLAGS for a particular
# file by setting both GRADEFLAGS-foo.
#

# Override this with `mmake HAVE_NUPROLOG=yes'
# if you want to rebuild the `.exp' files.
HAVE_NUPROLOG=no

DIFF_OPTS=-c

# Override this with `RUN_RECOMPILATION_TESTS=no'
# if your compiler cannot run smart recompilation.
# This is only necessary for compilers built in deep
# profiling grades, because smart recompilation uses
# exception handling, which does not yet work with
# deep profiling.
RUN_RECOMPILATION_TESTS=yes

#-----------------------------------------------------------------------------#

# .PRECIOUS: %.mod %.c %.o %_init.c %.no %.nu %_init.nl %_init.no

%_init.c: Entry

#
# If there is a `.inp' file, then we pipe that in as the command's input.
# Then we run the command, with stdout and stderr both redirected to the 
# `.out' file.  Finally if the command fails (returns non-zero exit status),
# we print out the contents of the `.out' file.  We use `grep . $@ /dev/null'
# to print out the contents, because that precedes each line of output with
# the filename, which is helpful when running a parallel make.
#
%.out: %
	{ [ -f $*.inp ] && cat $*.inp; } | ./$< > $@ 2>&1 || \
		{ grep . $@ /dev/null; exit 1; }

#
# For some test cases, there is more than one valid output.
# We try matching the output with the `.exp' file, and if that
# doesn't succeed, and there are `.exp2', `.exp3', `.exp4' or `.exp5'
# files, then we try matching against those too.  If none succeed,
# the shortest of the diffs is put into the `.res' file.
#
%.res: %.exp %.out
	@echo "Comparing $*.out with $*.exp*,"
	@echo "	results in $@"
	@-rm -f $@ $*.res[1-3]
	@{ diff $(DIFF_OPTS) $*.exp $*.out > $*.res1 && \
		echo "Matched $*.exp" && \
		cp $*.res1 $@; } || \
	{ test -f $*.exp2 && \
		diff $(DIFF_OPTS) $*.exp2 $*.out > $*.res2 && \
		echo "Matched $*.exp2" && \
		cp $*.res2 $@; } || \
	{ test -f $*.exp3 && \
		diff $(DIFF_OPTS) $*.exp3 $*.out > $*.res3 && \
		echo "Matched $*.exp3" && \
		cp $*.res3 $@; } || \
	{ test -f $*.exp4 && \
		diff $(DIFF_OPTS) $*.exp4 $*.out > $*.res4 && \
		echo "Matched $*.exp4" && \
		cp $*.res4 $@; } || \
	{ test -f $*.exp5 && \
		diff $(DIFF_OPTS) $*.exp5 $*.out > $*.res5 && \
		echo "Matched $*.exp5" && \
		cp $*.res5 $@; } || \
	{ shortest=`wc -l $*.res[1-3] | grep -v total | sort -n | \
		head -1 | awk '{ print $$2; }' `; \
		echo "** $*.out did not match the expected output"; \
		echo "** (closest match was $$shortest)"; \
		cp $$shortest $@; \
		exit 1; }

#-----------------------------------------------------------------------------#

clean_local: clean_out clean_res

clean_mc: clean_c clean_o clean_out clean_res

clean_out:
	rm -f *.out

clean_exp:
	rm -f *.exp

clean_res:
	rm -f *.res*

#
# The `foo' targets make `foo_local' in the current directory before
# recursively making `foo' in all subdirectories.  The recursive part
# is handled in individual Mmakefiles.
# 

.PHONY: check_local dep_local depend_local all_local

.PHONY: check_subdirs dep_subdirs depend_subdirs realclean_subdirs \
        clean_subdirs all_subdirs

check:          check_local check_subdirs
dep:            dep_local dep_subdirs
depend:         depend_local depend_subdirs
realclean:      realclean_subdirs
clean:          clean_subdirs
all:            all_local all_subdirs

SUBDIR_MMAKE = mmake \
                GRADE='$(GRADE)' \
                EXTRA_CFLAGS='$(EXTRA_CFLAGS)' \
                EXTRA_MCFLAGS='$(EXTRA_MCFLAGS)'

#-----------------------------------------------------------------------------#
