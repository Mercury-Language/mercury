#-----------------------------------------------------------------------------#

THIS_DIR = stm

#-----------------------------------------------------------------------------#

# please keep these lists sorted
VALID_PROGS = 			\
	basic				\
	basic2				\
	exception_propogate	\
	nested				\
	nested_or_else		\
	atomic_or_else		\
	atomic_conj			\
	atomic_ite			\
	#demo				\
	par-asm_test7		\
	par-asm_test8		\
	par-asm_test9		\
	par_test10			\
	par_test8			\
	par_test9			\
	stmqueuetext		\


INVALID_PROGS = 		\


# these tests require parallel execution with multiple engines
MULTI_PROGS =			\
	conflict			\


# These tests require debugging, which hasn't been implemented for
# the MLDS backend or Erlang backend.
#
LLDS_PROGS = 

ifeq "$(filter hl% java% il% erlang%,$(GRADE))" ""
	PROGS0 = $(LLDS_PROGS)
else
	PROGS0 =
endif

ifneq "$(findstring par,$(GRADE))" ""
	VALID_PROGS := $(VALID_PROGS) $(MULTI_PROGS)
endif

#ifneq "$(findstring decldebug,$(GRADE))" ""
#	OBJ_PROGS =
#	PROGS =
#else
	OBJ_PROGS =
	PROGS = $(VALID_PROGS) $(INVALID_PROGS)
#endif

# `mmc --make' doesn't expect subdirectories to appear in targets.
ifeq ($(MMAKE_USE_MMC_MAKE),yes)
OS_SUBDIR=
ILS_SUBDIR=
DLLS_SUBDIR=
else
OS_SUBDIR=$(os_subdir)
ILS_SUBDIR=$(ils_subdir)
DLLS_SUBDIR=$(dlls_subdir)
endif


ifeq ($(findstring il,$(GRADE)),il)
	TARGET_OBJ_EXT=dll
	TARGET_OBJ_SUBDIR=$(DLLS_SUBDIR)
else
	TARGET_OBJ_EXT=$(O)
	TARGET_OBJ_SUBDIR=$(OS_SUBDIR)
endif
OBJS =	$(OBJ_PROGS:%=$(TARGET_OBJ_SUBDIR)%.$(TARGET_OBJ_EXT)) \
		$(IL_PROGS:%=$(ILS_SUBDIR)%.il)

#-----------------------------------------------------------------------------#

TESTS = $(sort $(PROGS))
SUBDIRS = 
TESTS_DIR = ..
include $(TESTS_DIR)/Mmake.common

# Module-specific options should go in Mercury.options so they
# can be found by `mmc --make'.
include Mercury.options

$(VALID_PROGS:%=%.runtest): %.runtest: %.res ;
$(INVALID_PROGS:%=%.runtest): %.runtest: %.err_res ;

$(OBJ_PROGS:%=%.runtest): %.runtest: %.$(TARGET_OBJ_EXT) ;

ifneq ($(MMAKE_USE_MMC_MAKE),yes)

%.err: %.m
	if $(MC) --errorcheck-only $(ALL_GRADEFLAGS) $(ALL_MCFLAGS) $* \
		> $*.err 2>&1; \
	then false; else true; fi

else

% XXX: with `mmake --use-mmc-make' the ".DEFAULT:" rule seems to take
% 	precedence over "%.err: %.m" rules.
% XXX: the reason we run the $(MCM) command twice is to avoid 
%	doubled up error messages, once while making interface files,
%	then the module proper.  The second time the command is run
%	only one set of error messages should appear.
$(addsuffix .err,$(PROGS)):
	-$(MCM) $@
	if $(MCM) -r $@ > /dev/null 2>&1 ; then false; else true; fi

endif

# Exercise multiple Mercury engines in lowlevel grades.
ENGINES :=
ifeq "$(filter hl% java% il% erlang%,$(GRADE))" ""
	ENGINES := MERCURY_OPTIONS=-P8
endif

%.out: %
	{ [ -f $*.inp ] && cat $*.inp; } | $(ENGINES) ./$< > $@ 2>&1 || \
		{ grep . $@ /dev/null; exit 1; }

#-----------------------------------------------------------------------------#

printtests:
	@echo $(PROGS)

printobjs:
	@echo $(OBJS)

clean_local:
	rm -f *.err *.h

#-----------------------------------------------------------------------------#
