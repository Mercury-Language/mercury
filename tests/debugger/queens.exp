       1:      1  1 CALL pred queens:main/2-0 (cc_multi) 
mdb> echo on
Command echo enabled.
mdb> print *
       HeadVar__1           		state('<<c_pointer>>')
mdb> 
       2:      2  2 CALL pred queens:data/1-0 (det) 
mdb> print *
mdb: there are no live variables.
mdb> 
       3:      2  2 EXIT pred queens:data/1-0 (det) 
mdb> print *
       HeadVar__1           		[1, 2, 3, 4, 5]
mdb> 
       4:      3  2 CALL pred queens:queen/2-0 (nondet) 
mdb> print *
       HeadVar__1           		[1, 2, 3, 4, 5]
mdb> 
       5:      4  3 CALL pred queens:qperm/2-0 (nondet) 
mdb> print *
       HeadVar__1           		[1, 2, 3, 4, 5]
mdb> 
       6:      4  3 SWTC pred queens:qperm/2-0 (nondet) s1;
mdb> print *
       HeadVar__1           		[1, 2, 3, 4, 5]
mdb> 
       7:      5  4 CALL pred queens:qdelete/3-0 (nondet) 
mdb> print *
       HeadVar__2           		[1, 2, 3, 4, 5]
mdb> 
       8:      5  4 DISJ pred queens:qdelete/3-0 (nondet) c2;d1;
mdb> print *
       HeadVar__2           		[1, 2, 3, 4, 5]
       V_10                 		[2, 3, 4, 5]
       V_11                 		1
mdb> level 1
   1       5       4    3 pred queens:qperm/2-0 (nondet) 
Ancestor level set to 1.
mdb> print *
       HeadVar__1           		[1, 2, 3, 4, 5]
mdb> up 1
   2       4       3    2 pred queens:queen/2-0 (nondet) 
Ancestor level set to 2.
mdb> vars
        0 HeadVar__1
mdb> print *
       HeadVar__1           		[1, 2, 3, 4, 5]
mdb> 
       9:      5  4 EXIT pred queens:qdelete/3-0 (nondet) 
mdb> print HeadVar__1
       HeadVar__1           		1
mdb> print HeadVar__2
       HeadVar__2           		[1, 2, 3, 4, 5]
mdb> print HeadVar__3
       HeadVar__3           		[2, 3, 4, 5]
mdb> 
      10:      6  4 CALL pred queens:qperm/2-0 (nondet) 
mdb> print *
       HeadVar__1           		[2, 3, 4, 5]
mdb> 
      11:      6  4 SWTC pred queens:qperm/2-0 (nondet) s1;
mdb> print *
       HeadVar__1           		[2, 3, 4, 5]
mdb> 
      12:      7  5 CALL pred queens:qdelete/3-0 (nondet) 
mdb> print *
       HeadVar__2           		[2, 3, 4, 5]
mdb> 
      13:      7  5 DISJ pred queens:qdelete/3-0 (nondet) c2;d1;
mdb> print *
       HeadVar__2           		[2, 3, 4, 5]
       V_10                 		[3, 4, 5]
       V_11                 		2
mdb> 
      14:      7  5 EXIT pred queens:qdelete/3-0 (nondet) 
mdb> print *
       HeadVar__1           		2
       HeadVar__2           		[2, 3, 4, 5]
       HeadVar__3           		[3, 4, 5]
mdb> 
      15:      8  5 CALL pred queens:qperm/2-0 (nondet) 
mdb> goto -a 20
      16:      8  5 SWTC pred queens:qperm/2-0 (nondet) s1;
      17:      9  6 CALL pred queens:qdelete/3-0 (nondet) 
      18:      9  6 DISJ pred queens:qdelete/3-0 (nondet) c2;d1;
      19:      9  6 EXIT pred queens:qdelete/3-0 (nondet) 
      20:     10  6 CALL pred queens:qperm/2-0 (nondet) 
mdb> stack
   0    4* pred queens:qperm/2-0 (nondet)
   4       pred queens:queen/2-0 (nondet)
   5       pred queens:main/2-0 (cc_multi)
mdb> stack -d
   0      20      10    6 pred queens:qperm/2-0 (nondet)
   1      15       8    5 pred queens:qperm/2-0 (nondet)
   2      10       6    4 pred queens:qperm/2-0 (nondet)
   3       5       4    3 pred queens:qperm/2-0 (nondet)
   4       4       3    2 pred queens:queen/2-0 (nondet)
   5       1       1    1 pred queens:main/2-0 (cc_multi)
mdb> print *
       HeadVar__1           		[4, 5]
mdb> #
Unknown command `#'. Give the command `help' for help.
mdb> # Test interactive queries.
Unknown command `#'. Give the command `help' for help.
mdb> #
Unknown command `#'. Give the command `help' for help.
mdb> mmc_options --use-subdirs
mdb> mmc_options
mdb> query queens list
?- <stdin>:026: Inferred :- pred query((list:list(character)), (list:list(character))).
<stdin>:026: Inferred :- mode query(out, out) is multi.
X = [], Y = ['a', 'b', 'c'], true ;
X = ['a'], Y = ['b', 'c'], true ;
X = ['a', 'b'], Y = ['c'], true ;
X = ['a', 'b', 'c'], Y = [], true ;
fail.
No (more) solutions.
?- <stdin>:026: Inferred :- pred query((list:list(int))).
<stdin>:026: Inferred :- mode query(out) is nondet.
List = [1, 2, 3], true ;
List = [1, 3, 2], true ;
List = [2, 1, 3], true ;
List = [2, 3, 1], true ;
List = [3, 1, 2], true ;
List = [3, 2, 1], true ;
fail.
No (more) solutions.
?- <stdin>:012: In clause for predicate `query:run/2':
<stdin>:012:   warning: variable `_2' occurs more than once in this scope.
<stdin>:014: In clause for predicate `query:run/2':
<stdin>:014:   warning: variable `_2' occurs more than once in this scope.
<stdin>:012: In clause for predicate `query:run/2':
<stdin>:012:   warning: variable `_2' occurs more than once in this scope.
<stdin>:015: In clause for predicate `query:run/2':
<stdin>:015:   warning: variable `_2' occurs more than once in this scope.
<stdin>:026: In clause for predicate `query:query/2':
<stdin>:026:   warning: variable `_2' occurs more than once in this scope.
<stdin>:001: In clause for predicate `query:query/2':
<stdin>:001:   warning: variable `_2' occurs more than once in this scope.
<stdin>:026: Inferred :- pred query((list:list(int)), (list:list(int))).
<stdin>:026: Inferred :- mode query(out, out) is nondet.
List = [2, 1, 3], _2 = [1, 3], true ;
List = [2, 3, 1], _2 = [3, 1], true ;
fail.
No (more) solutions.
?- <stdin>:012: In clause for predicate `query:run/2':
<stdin>:012:   warning: variable `_2' occurs more than once in this scope.
<stdin>:014: In clause for predicate `query:run/2':
<stdin>:014:   warning: variable `_2' occurs more than once in this scope.
<stdin>:012: In clause for predicate `query:run/2':
<stdin>:012:   warning: variable `_2' occurs more than once in this scope.
<stdin>:015: In clause for predicate `query:run/2':
<stdin>:015:   warning: variable `_2' occurs more than once in this scope.
<stdin>:026: In clause for predicate `query:query/2':
<stdin>:026:   warning: variable `_2' occurs more than once in this scope.
<stdin>:001: In clause for predicate `query:query/2':
<stdin>:001:   warning: variable `_2' occurs more than once in this scope.
<stdin>:026: Inferred :- pred query((list:list(int)), (list:list(int))).
<stdin>:026: Inferred :- mode query(out, out) is nondet.
fail.
No (more) solutions.
?- <stdin>:001: In clause for predicate `query:query/1':
<stdin>:001:   in argument 1 of call to predicate `qperm/2':
<stdin>:001:   in argument 2 of functor `./2':
<stdin>:001:   in argument 2 of functor `./2':
<stdin>:001:   in argument 1 of functor `./2':
<stdin>:001:   type error in unification of argument
<stdin>:001:   and constant `"foo"'.
<stdin>:001:   argument has type `int',
<stdin>:001:   constant `"foo"' has type `string'.
For more information, try recompiling with `-E'.
Compilation error(s) occurred.
?- <stdin>:026: Inferred :- pred query((list:list(int))).
<stdin>:001: In clause for `query(out(not_reached))':
<stdin>:001:   in argument 1 of call to predicate `queens:qperm/2':
<stdin>:001:   mode error: variable `List' has instantiatedness `free',
<stdin>:001:   expected instantiatedness was `ground'.
<stdin>:026: Inferred :- mode query(out(free)).
For more information, try recompiling with `-E'.
Compilation error(s) occurred.
?- 
mdb>  cc_query queens list
?- <stdin>:017: Inferred :- pred query((list:list(character)), (list:list(character))).
<stdin>:017: Inferred :- mode query(out, out) is multi.
X = [], Y = ['a', 'b', 'c'], true.
?- <stdin>:017: Inferred :- pred query((list:list(int))).
<stdin>:017: Inferred :- mode query(out) is nondet.
List = [1, 2, 3], true.
?- <stdin>:011: In clause for predicate `query:run/2':
<stdin>:011:   warning: variable `_2' occurs more than once in this scope.
<stdin>:012: In clause for predicate `query:run/2':
<stdin>:012:   warning: variable `_2' occurs more than once in this scope.
<stdin>:017: In clause for predicate `query:query/2':
<stdin>:017:   warning: variable `_2' occurs more than once in this scope.
<stdin>:001: In clause for predicate `query:query/2':
<stdin>:001:   warning: variable `_2' occurs more than once in this scope.
<stdin>:017: Inferred :- pred query((list:list(int)), (list:list(int))).
<stdin>:017: Inferred :- mode query(out, out) is nondet.
List = [2, 1, 3], _2 = [1, 3], true.
?- <stdin>:011: In clause for predicate `query:run/2':
<stdin>:011:   warning: variable `_2' occurs more than once in this scope.
<stdin>:012: In clause for predicate `query:run/2':
<stdin>:012:   warning: variable `_2' occurs more than once in this scope.
<stdin>:017: In clause for predicate `query:query/2':
<stdin>:017:   warning: variable `_2' occurs more than once in this scope.
<stdin>:001: In clause for predicate `query:query/2':
<stdin>:001:   warning: variable `_2' occurs more than once in this scope.
<stdin>:017: Inferred :- pred query((list:list(int)), (list:list(int))).
<stdin>:017: Inferred :- mode query(out, out) is nondet.
No solution.
?- 
mdb>  io_query queens list
run <-- [1, 3, 5, 2, 4]
run <-- X = [], Y = ['a', 'b', 'c']
run <-- [1, 2, 3]
run <-- [2, 1, 3]
run <-- No solution, as expected.
run <-- 
mdb> 
      21:     10  6 SWTC pred queens:qperm/2-0 (nondet) s1;
mdb> retry
      34:     10  6 EXIT pred queens:qperm/2-0 (nondet) 
retry
      20:     10  6 CALL pred queens:qperm/2-0 (nondet) 
mdb> print *
       HeadVar__1           		[4, 5]
mdb> finish -a
      21:     10  6 SWTC pred queens:qperm/2-0 (nondet) s1;
      22:     11  7 CALL pred queens:qdelete/3-0 (nondet) 
      23:     11  7 DISJ pred queens:qdelete/3-0 (nondet) c2;d1;
      24:     11  7 EXIT pred queens:qdelete/3-0 (nondet) 
      25:     12  7 CALL pred queens:qperm/2-0 (nondet) 
      26:     12  7 SWTC pred queens:qperm/2-0 (nondet) s1;
      27:     13  8 CALL pred queens:qdelete/3-0 (nondet) 
      28:     13  8 DISJ pred queens:qdelete/3-0 (nondet) c2;d1;
      29:     13  8 EXIT pred queens:qdelete/3-0 (nondet) 
      30:     14  8 CALL pred queens:qperm/2-0 (nondet) 
      31:     14  8 SWTC pred queens:qperm/2-0 (nondet) s2;
      32:     14  8 EXIT pred queens:qperm/2-0 (nondet) 
      33:     12  7 EXIT pred queens:qperm/2-0 (nondet) 
      34:     10  6 EXIT pred queens:qperm/2-0 (nondet) 
mdb> register --quiet
mdb> break print_list
 0: + stop  interface pred queens:print_list/3-0 (det)
mdb> break qdelete
 1: + stop  interface pred queens:qdelete/3-0 (nondet)
mdb> continue -a
      35:      8  5 EXIT pred queens:qperm/2-0 (nondet) 
      36:      6  4 EXIT pred queens:qperm/2-0 (nondet) 
      37:      4  3 EXIT pred queens:qperm/2-0 (nondet) 
      38:     15  3 CALL pred queens:safe/1-0 (semidet) 
      39:     15  3 SWTC pred queens:safe/1-0 (semidet) s1;
      40:     16  4 CALL pred queens:nodiag/3-0 (semidet) 
      41:     16  4 SWTC pred queens:nodiag/3-0 (semidet) s1;
      42:     16  4 THEN pred queens:nodiag/3-0 (semidet) s1;c4;t;
      43:     16  4 FAIL pred queens:nodiag/3-0 (semidet) 
      44:     15  3 FAIL pred queens:safe/1-0 (semidet) 
      45:      4  3 REDO pred queens:qperm/2-0 (nondet) 
      46:      6  4 REDO pred queens:qperm/2-0 (nondet) 
      47:      8  5 REDO pred queens:qperm/2-0 (nondet) 
      48:     10  6 REDO pred queens:qperm/2-0 (nondet) 
      49:     12  7 REDO pred queens:qperm/2-0 (nondet) 
      50:     14  8 REDO pred queens:qperm/2-0 (nondet) 
      51:     14  8 FAIL pred queens:qperm/2-0 (nondet) 
      52:     13  8 REDO pred queens:qdelete/3-0 (nondet) 
mdb> step -aS 5
      53:     13  8 DISJ pred queens:qdelete/3-0 (nondet) c2;d2;
      54:     17  9 CALL pred queens:qdelete/3-0 (nondet) 
      55:     17  9 FAIL pred queens:qdelete/3-0 (nondet) 
      56:     13  8 FAIL pred queens:qdelete/3-0 (nondet) 
      57:     12  7 FAIL pred queens:qperm/2-0 (nondet) 
mdb> disable 1
 1: - stop  interface pred queens:qdelete/3-0 (nondet)
mdb> continue -n
     675:    141  2 CALL pred queens:print_list/3-0 (det) 
mdb> continue -n -S
[1, 3, 5, 2, 4]
