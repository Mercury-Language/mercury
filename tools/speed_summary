#!/usr/bin/awk -f
# vim: ts=4 sw=4 et
#
# This script is intended to summarize timing results such as those produced
# by the speedtest script.
#
# As is usual for an awk script, its input is the list of files whose names
# are specified on the command line, or, in the absence of such file names,
# the contents of standard input.
#
# The input may contain two kinds of lines. Timing lines contain a first field
# that identifies a particular group of runs, and seven other fields containing
# benchmarking information in the format generated by the dotime script. Other
# lines are descriptive text that applies to the following group of timing
# lines. We distinguish between the two sorts of lines by requiring timing
# lines to start with a lower case letter, and requiring descriptive lines
# to start with something else. The output produced by tools/speedtest meets
# these requirements.
#
# When it has digested all its input, this script produces information for each
# group of timing lines in its input. For each group, it prints its descriptive
# text if any, and then the average user mode time taken by the runs in that
# group. It calculates a raw average, as well as averages taken by discarding
# the highest and lowest N times in each group, with N being 1 or 2.
#
# The point of discarding the highest and lowest values is to reduce the impact
# of non-recurring events such as the initial loading of the program into
# memory.
#
# You can ask for the reported times to be also expressed as a percentage of a
# given base time by setting the variable BASE on the command line (e.g. with
# a command such as "speed_summary BASE=13.7 batchname").

$1 ~ /[a-z].*/  {
        variant = $1;

        if (variants[variant] == "") {
            variants[variant] = variant;
            variant_order[cur_variant + 0] = variant;
            cur_variant++;
        }

        time = substr($2, 1, length($2) - 1);
        # printf "read %s %9.2f\n", variant, time;

        i = times_count[variant] + 0;
        times[variant "@" i] = time;
        times_count[variant]++;

        texts[variant] = texts[variant] text;
        text = "";

        # printf "assigned %s %d %s %9.2f\n", \
        # variant, i, variant "@" i, times[variant "@" i];
        next;
    }
    {
        text = text $0 "\n";
        next;
    }
END {
        for (ordinal = 0; ordinal < cur_variant; ordinal++) {
            variant = variant_order[ordinal];
            count = times_count[variant];

            # perform insertion sort on times[variant "@" *]
            for (i = 1; i < count; i++) {
                for (j = 0; j < i; j++) {
                    if (times[variant "@" j] > times[variant "@" i]) {
                        break;
                    }
                }

                insert = times[variant "@" i];
                for (k = i - 1; k >= j; k--) {
                    times[variant "@" k+1] = times[variant "@" k];
                }

                times[variant "@" j] = insert;
            }

            # for (i = 0; i < count; i++) {
            #   printf "sorted %s %d %9.2f\n", \
            #       variant, i, times[variant "@" i];
            # }
        }

        for (ignore = 1; ignore < 3; ignore++) {
            for (ordinal = 0; ordinal < cur_variant; ordinal++) {
                variant = variant_order[ordinal];

                printf "%s", texts[variant];

                num = 0;
                total = 0;
                for (i = ignore; i < count - ignore; i++) {
                    num++;
                    total += times[variant "@" i];
                }

                avg = total/num;
                printf "%s average of %d with ignore=%d %9.2f",
                    variant, count, ignore, avg;
                if (BASE + 0 != 0) {
                    percent = (100 * avg) / BASE;
                    printf " (%6.2f%%)", percent;
                }

                printf "\n";
            }
        }
    }
