\input texinfo
@c vim: expandtab
@setfilename mercury_ref.info
@settitle The Mercury Language Reference Manual

@dircategory The Mercury Programming Language
@direntry
* Mercury Language: (mercury_ref).  The Mercury Language Reference Manual.
@end direntry

@c @smallbook
@c @cropmarks
@finalout
@setchapternewpage on
@ifnottex
This file documents the Mercury programming language, version <VERSION>.

Copyright @copyright{} 1995--2012 The University of Melbourne.@*
Copyright @copyright{} 2013--2020 The Mercury team.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@ignore
Permission is granted to process this file through Tex and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.
@end ifnottex

@titlepage
@title The Mercury Language Reference Manual
@subtitle Version <VERSION>
@author Fergus Henderson
@author Thomas Conway
@author Zoltan Somogyi
@author David Jeffery
@author Peter Schachte
@author Simon Taylor
@author Chris Speirs
@author Tyson Dowd
@author Ralph Becket
@author Mark Brown
@author Peter Wang
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1995--2012 The University of Melbourne.@*
Copyright @copyright{} 2013--2020 The Mercury team.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.
@end titlepage
@contents
@page
@c ---------------------------------------------------------------------------

@ifnottex
@node Top,,, (mercury)
@top The Mercury Language Reference Manual, version <VERSION>
@end ifnottex
@c XXX Move to after Determinism
@c * Assertions::        Assertion declarations allow you to declare laws
@c                       that hold.
@menu
* Introduction::      A brief introduction to Mercury.
* Syntax::            A description of Mercury's syntax.
* Types::             Mercury has a strong parametric polymorphic type system.
* Modes::             Modes allow you to specify the direction of data flow.
* Unique modes::      Unique modes allow you to specify when there is only one
                      reference to a particular value, so the compiler can
                      safely use destructive update to modify that value.
* Determinism::       Determinism declarations let you specify that a predicate
                      should never fail or should never succeed more than once.
* User-defined equality and comparison::
                      User-defined types can have user-defined equality and
                      comparison predicates.
* Higher-order::      Mercury supports higher-order predicates and functions,
                      with closures, lambda expressions, and currying.
* Modules::           Modules allow you to divide a program into smaller parts.
* Type classes::      Constrained polymorphism.
* Existential types:: Support for data abstraction and heterogeneous
                      collections.
* Exception handling:: Catching exceptions to recover from exceptional
                      situations.
* Semantics::         Declarative and operational semantics of Mercury
                      programs.
* Foreign language interface:: Calling code written in other programming
                      languages from Mercury code
* Impurity::          Users can write impure Mercury code.
* Solver types::      Support for constraint logic programming
* Trace goals::       Trace goals allow programmers to add debugging and
                      logging code to their programs.
* Pragmas::           Various compiler directives, used for example to
                      control optimization.
* Implementation-dependent extensions::
                      The University of Melbourne Mercury implementation
                      supports several extensions to the Mercury language.
* Bibliography::      References for further reading.
@end menu

@node Introduction
@chapter Introduction

Mercury is a general-purpose programming language,
originally designed and implemented by a small group of researchers
at the University of Melbourne, Australia.
Mercury is based on the paradigm of purely declarative programming,
and was designed to be useful
for the development of large and robust ``real-world'' applications.
It improves on existing logic programming languages
by providing increased productivity, reliability and efficiency,
and by avoiding the need for non-logical program constructs.
Mercury provides the traditional logic programming syntax,
but also allows the syntactic convenience of user-defined functions,
smoothly integrating logic and functional programming into a single paradigm.

Mercury requires programmers to supply
type, mode and determinism declarations for the predicates
and functions they write.
The compiler checks these declarations,
and rejects the program if it cannot prove
that every predicate or function satisfies its declarations.
This improves reliability,
since many kinds of errors simply cannot happen
in successfully compiled Mercury programs.
It also improves productivity,
since the compiler pinpoints many errors
that would otherwise require manual debugging to locate.
The fact that declarations are checked by the compiler
makes them much more useful than comments
to anyone who has to maintain the program.
The compiler also exploits the guaranteed correctness of the declarations
for significantly improving the efficiency of the code it generates.

To facilitate programming-in-the-large, to allow separate compilation,
and to support encapsulation, Mercury has a simple module system.
Mercury's standard library has a variety of pre-defined modules
for common programming tasks --- see the Mercury Library Reference Manual.

@node Syntax
@chapter Syntax

@menu
* Syntax overview::
* Character set::
* Whitespace::
* Tokens::
* Terms::
* Builtin operators::
* Items::
* Declarations::
* Facts::
* Rules::
* Goals::
* State variables::
* DCG-rules::
* DCG-goals::
* Data-terms::
* Variable scoping::
* Implicit quantification::
* Elimination of double negation::
@end menu

@node Syntax overview
@section Syntax overview

Mercury's syntax is similar to the syntax of Prolog,
with some additional declarations for types, modes, determinism,
the module system, and pragmas,
and with the distinction that function symbols
may stand also for invocations of user-defined functions
as well as for data constructors.

A Mercury program consists of a set of modules.
Each module is a file containing a sequence of items
(declarations and clauses).
Each item is a term followed by a period.
Each term is composed of a sequence of tokens,
and each token is composed of a sequence of characters.
Like Prolog,
Mercury has the Definite Clause Grammar (DCG) notation for clauses.

@node Character set
@section Character set

Mercury program source files must be written
using the UTF-8 encoding of the Unicode character set.

@node Whitespace
@section Whitespace

In Mercury program source files,
whitespace is defined to be the following characters:

@multitable {CHARACTER_TABULATION} {Unicode_code_point} {Horizontal-tab}
@headitem  Unicode name @tab Unicode code point @tab Notes
    @item @sc{space}                @tab U+0020             @tab
    @item @sc{character tabulation} @tab U+0009             @tab Horizontal-tab
    @item @sc{line feed}            @tab U+000A             @tab
    @item @sc{line tabulation}      @tab U+000B             @tab Vertical-tab
    @item @sc{form feed}            @tab U+000C             @tab
    @item @sc{carriage return}      @tab U+000D             @tab
@end multitable

@node Tokens
@section Tokens

The different tokens in Mercury are as follows.
Tokens may be separated by whitespace.

@table @emph

@item line number directive
A line number directive consists of the character @samp{#},
a positive integer specifying the line number, and then a newline.
A @samp{#@var{line}} directive's only role
is to specifying the line number;
it is otherwise ignored by the syntax.
Line number directives may occur anywhere a token may occur.
They are used in conjunction with the @samp{pragma source_file} declaration
to indicate that the Mercury code following was generated by another tool;
they serve to associate each line in the Mercury code
with the source file name and line number
of the original source from which the Mercury code was derived,
so that the Mercury compiler can issue more informative error messages
using the original source code locations.
A @samp{#@var{line}} directive specifies
the line number for the immediately following line.
Line numbers for lines after that are incremented as usual,
so the second line after a @samp{#100} directive
would be considered to be line number 101.

@item string
A string is a sequence of characters enclosed in double quotes (@code{"}).

Within a string, two adjacent double quotes stand for a single double quote.
For example, the string @samp{ """" } is a string of length one,
containing a single double quote:
the outermost pair of double quotes encloses the string,
and the innermost pair stand for a single double quote.

Strings may also contain backslash escapes.
@samp{\a} stands for ``alert'' (a beep character),
@samp{\b} for backspace,
@samp{\r} for carriage-return,
@samp{\f} for form-feed,
@samp{\t} for tab,
@samp{\n} for newline,
@samp{\v} for vertical-tab.
An escaped backslash, single-quote, or double-quote stands for itself.

The sequence @samp{\x} introduces a hexadecimal escape;
it must be followed by a sequence of hexadecimal digits
and then a closing backslash.
It is replaced with the character
whose character code is identified by the hexadecimal number.
Similarly, a backslash followed by an octal digit
is the beginning of an octal escape;
as with hexadecimal escapes,
the sequence of octal digits must be terminated with a closing backslash.

The sequence @samp{\u} or @samp{\U} can be used to escape Unicode characters.
@samp{\u} must be followed by the Unicode character code
expressed as four hexadecimal digits.
@samp{\U} must be followed by the Unicode character code
expressed as eight hexadecimal digits.
The highest allowed value is @samp{\U0010FFFF}.

A backslash followed immediately by a newline is deleted;
thus an escaped newline can be used to continue a string
over more than one source line.
(String literals may also contain embedded newlines.)

@item name
A name is either an unquoted name or a quoted name.
An unquoted name is a lowercase letter followed by zero or more letters,
underscores, and digits.
A quoted name is any sequence of zero or more characters
enclosed in single quotes (@code{'}).
Within a quoted name,
two adjacent single quotes stand for a single single quote.
Quoted names can also contain
backslash escapes of the same form as for strings.

@item variable
A variable is an uppercase letter or underscore
followed by zero or more letters, underscores, and digits.
A variable token consisting of single underscore is treated specially:
each instance of @samp{_} denotes a distinct variable.
(In addition, variables starting with an underscore
are presumed to be ``don't-care'' variables;
the compiler will issue a warning
if a variable that does not start with an underscore occurs only once,
or if a variable starting with an underscore
occurs more than once in the same scope.)

@item integer
An integer is either a decimal, binary, octal, hexadecimal,
or character-code literal.
A decimal literal is any sequence of decimal digits.
A binary literal is @samp{0b} followed by any sequence of binary digits.
An octal literal is @samp{0o} followed by any sequence of octal digits.
A hexadecimal literal is @samp{0x}
followed by any sequence of hexadecimal digits.
A character-code literal is @samp{0'} followed by any single character.

Decimal, binary, octal and hexadecimal literals
may be optionally terminated by a suffix
that indicates whether the literal represents a signed or unsigned integer
and what the size of that integer is.
These suffixes are:
@multitable {i_or_no_suffix} {Unsigned} {Implementation_defined}
@headitem Suffix @tab Signedness @tab Size
@item @code{i} or no suffix   @tab Signed   @tab Implementation-defined
@item @code{i8}               @tab Signed   @tab 8-bit
@item @code{i16}              @tab Signed   @tab 16-bit
@item @code{i32}              @tab Signed   @tab 32-bit
@item @code{i64}              @tab Signed   @tab 64-bit
@item @code{u}                @tab Unsigned @tab Implementation-defined
@item @code{u8}               @tab Unsigned @tab 8-bit
@item @code{u16}              @tab Unsigned @tab 16-bit
@item @code{u32}              @tab Unsigned @tab 32-bit
@item @code{u64}              @tab Unsigned @tab 64-bit
@end multitable

For decimal, binary, octal and hexadecimal literals,
an arbitrary number of underscores (@samp{_})
may be inserted between the digits.
An arbitrary number of underscores may also be inserted
between the radix prefix (i.e. @samp{0b}, @samp{0o} and @samp{0x})
and the initial digit.
Similarly, an arbitrary number of underscores
may be inserted between the final digit and the signedness suffix.
The purpose of the underscores is to improve readability,
and they do not affect the numeric value of the literal.

@c TODO: we should support hexadecimal float literals too.
@item float
A floating point literal consists of a sequence of decimal digits,
a decimal point (@samp{.}) and a sequence of digits (the fraction part),
and the letter @samp{E} (or @samp{e}),
an optional sign (@samp{+} or @samp{-}),
and then another sequence of decimal digits (the exponent).
The fraction part or the exponent (but not both) may be omitted.

An arbitrary number of underscores (@samp{_})
may be inserted between the digits in a floating point literal.
Underscores may @emph{not} occur adjacent to any non-digit characters
(i.e. @samp{.}, @samp{e}, @samp{E}, @samp{+} or @samp{-})
in a floating point literal.
The purpose of the underscores is to improve readability,
and they do not affect the numeric value of the literal.

@item implementation_defined_literal
An implementation-defined literal
consists of a dollar sign (@samp{$}) followed by an unquoted name.

@item open_ct
A left parenthesis, @samp{(}, that is not preceded by whitespace.

@item open
A left parenthesis, @samp{(}, that is preceded by whitespace.

@item close
A right parenthesis, @samp{)}.

@item open_list
A left square bracket, @samp{[}.

@item close_list
A right square bracket, @samp{]}.

@item open_curly
A left curly bracket, @samp{@{}.

@item close_curly
A right curly bracket, @samp{@}}.

@item ht_sep
A ``head-tail separator'', i.e.@: a vertical bar, @samp{|}.

@item comma
A comma, @samp{,}.

@item end
A full stop (period), @samp{.}.

@item eof
The end of file.

@end table

@node Terms
@section Terms

A term is either a variable or a functor.

A functor is an integer, a float, a string, a name, a compound term,
or a higher-order term.

A compound term is a simple compound term, a list term, a tuple term,
an operator term, or a parenthesized term.

A simple compound term is a name
followed without any intervening whitespace
by an open parenthesis (i.e.@: an open_ct token),
a sequence of argument terms separated by commas,
and a close parenthesis.

A list term is an open square bracket (i.e.@: an open_list token)
followed by a sequence of argument terms separated by commas,
optionally followed by a vertical bar (i.e.@: a ht_sep token)
followed by a term,
followed by a close square bracket (i.e.@: a close_list token).
An empty list term is an open_list token followed by a close_list token.
List terms are parsed as follows:
@example
parse('[' ']') = [].
parse('[' List) = parse_list(List).
parse_list(Head ',' Tail) = '[|]'(parse_term(Head), parse_list(Tail)).
parse_list(Head '|' Tail ']') = '[|]'(parse_term(Head), parse_term(Tail)).
parse_list(Head ']') = '[|]'(parse_term(Head), []).
@end example

The following terms are all equivalent:
@example
[1, 2, 3]
[1, 2, 3 | []]
[1, 2 | [3]]
[1 | [2, 3]]
'[|]'(1, '[|]'(2, '[|]'(3, [])))
@end example

A tuple term is a left curly bracket (i.e.@: an open_curly token)
followed by a sequence of argument terms separated by commas,
and a right curly bracket.
For example, @code{@{1, '2', "three"@}} is a valid tuple term.

An operator term is a term specified using operator notation, as in Prolog.
Operators can also be formed by enclosing a name, a module qualified name
(@pxref{The module system}), or a variable between grave accents (backquotes).
Any name or variable may be used as an operator in this way.
If @var{fun} is a variable or name,
then a term of the form @code{@var{X} `@var{fun}` @var{Y}} is equivalent to
@code{@var{fun}(@var{X}, @var{Y})}. The operator is left associative
and binds more tightly than every operator other than @samp{^}
(@pxref{Builtin operators}).

A parenthesized term is just
an open parenthesis followed by a term and a close parenthesis.

A higher-order term is a ``closure'' term,
which can be any term other than a name or an operator term,
followed without any intervening whitespace
by an open parenthesis (i.e.@: an open_ct token),
a sequence of argument terms separated by commas,
and a close parenthesis.
A higher-order term is equivalent to a simple compound term
whose functor is the empty name,
and whose arguments are the closure term
followed by the argument terms of the higher-order term.
That is, a term such as @code{Term(Arg1, @dots{}, ArgN)} is parsed as
@code{''(Term, Arg1, @dots{}, ArgN)}.
Note that the closure term can be a parenthesized term;
for example, @code{(Term ^ FieldName)(Arg1, Arg2)} is a higher-order term,
and so it gets parsed as if it were @code{''((Term ^ FieldName), Arg1, Arg2)}.

@node Builtin operators
@section Builtin operators

The following table lists all of Mercury's builtin operators.
Operators with a low ``Priority'' bind more tightly
than those with a high ``Priority''.
For example, given that
@code{+} has priority 500 and @code{*} has priority 400,
the term @code{2 * X + Y} would parse as @code{(2 * X) + Y}.

The ``Specifier'' field indicates
what structure terms constructed with an operator are allowed to take.
``f'' represents the operator and ``x'' and ``y'' represent arguments.
``x'' represents an argument
whose priority must be strictly lower than that of the operator.
``y'' represents an argument
whose priority is lower or equal to that of the operator.
For example, ``yfx'' indicates a left-associative infix operator,
while ``xfy'' indicates a right-associative infix operator.

@example

Operator                        Specifier         Priority

.                               yfx               10
!                               fx                40
!.                              fx                40
!:                              fx                40
@@                               xfx               90
^                               xfy               99
^                               fx                100
event                           fx                100
:                               yfx               120
`@var{op}`                      yfx               120       @footnote{Operator term (@pxref{Terms}).}
**                              xfy               200
-                               fx                200
\                               fx                200
*                               yfx               400
/                               yfx               400
//                              yfx               400
<<                              yfx               400
>>                              yfx               400
div                             yfx               400
mod                             xfx               400
rem                             xfx               400
for                             xfx               500
+                               fx                500
+                               yfx               500
++                              xfy               500
-                               yfx               500
--                              yfx               500
/\                              yfx               500
\/                              yfx               500
..                              xfx               550
:=                              xfx               650
=^                              xfx               650
<                               xfx               700
=                               xfx               700
=..                             xfx               700
=:=                             xfx               700
=<                              xfx               700
==                              xfx               700
=\=                             xfx               700
>                               xfx               700
>=                              xfx               700
@@<                              xfx               700
@@=<                             xfx               700
@@>                              xfx               700
@@>=                             xfx               700
\=                              xfx               700
\==                             xfx               700
~=                              xfx               700
is                              xfx               701
and                             xfy               720
or                              xfy               740
func                            fx                800
impure                          fy                800
pred                            fx                800
semipure                        fy                800
\+                              fy                900
not                             fy                900
when                            xfx               900
~                               fy                900
<=                              xfy               920
<=>                             xfy               920
=>                              xfy               920
all                             fxy               950
arbitrary                       fxy               950
atomic                          fxy               950
disable_warning                 fxy               950
disable_warnings                fxy               950
promise_equivalent_solutions    fxy               950
promise_equivalent_solution_sets fxy              950
promise_exclusive               fy                950
promise_exclusive_exhaustive    fy                950
promise_exhaustive              fy                950
promise_impure                  fx                950
promise_pure                    fx                950
promise_semipure                fx                950
require_complete_switch         fxy               950
require_switch_arms_det         fxy               950
require_switch_arms_semidet     fxy               950
require_switch_arms_multi       fxy               950
require_switch_arms_nondet      fxy               950
require_switch_arms_cc_multi    fxy               950
require_switch_arms_cc_nondet   fxy               950
require_switch_arms_erroneous   fxy               950
require_switch_arms_failure     fxy               950
require_det                     fx                950
require_semidet                 fx                950
require_multi                   fx                950
require_nondet                  fx                950
require_cc_multi                fx                950
require_cc_nondet               fx                950
require_erroneous               fx                950
require_failure                 fx                950
trace                           fxy               950
try                             fxy               950
some                            fxy               950
,                               xfy               1000
&                               xfy               1025
->                              xfy               1050
;                               xfy               1100
or_else                         xfy               1100
then                            xfx               1150
if                              fx                1160
else                            xfy               1170
::                              xfx               1175
==>                             xfx               1175
where                           xfx               1175
--->                            xfy               1179
catch                           xfy               1180
type                            fx                1180
solver                          fy                1181
catch_any                       xfy               1190
end_module                      fx                1199
import_module                   fx                1199
include_module                  fx                1199
initialise                      fx                1199
initialize                      fx                1199
finalise                        fx                1199
finalize                        fx                1199
inst                            fx                1199
instance                        fx                1199
mode                            fx                1199
module                          fx                1199
pragma                          fx                1199
promise                         fx                1199
rule                            fx                1199
typeclass                       fx                1199
use_module                      fx                1199
-->                             xfx               1200
:-                              fx                1200
:-                              xfx               1200
?-                              fx                1200

@end example

@node Items
@section Items

Each item in a Mercury module is either a declaration or a clause.
If the top-level functor of the term is @samp{:-/1},
the item is a declaration, otherwise it is a clause.
There are three types of clauses.
If the top-level functor of the item is @samp{:-/2}, the item is a rule.
If the top-level functor is @samp{-->/2}, the item is a DCG rule.
Otherwise, the item is a fact.
There are two types of rules and facts.
If the top-level functor of the head of a rule is @samp{=/2}, the rule
is a function rule, otherwise it is a predicate rule.
If the top-level functor of the head of a fact is @samp{=/2}, the fact
is a function fact, otherwise it is a predicate fact.

@node Declarations
@section Declarations

The allowed declarations are:

@example
:- type
:- solver type
:- pred
:- func
:- inst
:- mode
:- typeclass
:- instance
:- pragma
:- promise
:- initialise
:- finalise
:- mutable
:- module
:- interface
:- implementation
:- import_module
:- use_module
:- include_module
:- end_module
@end example

The @samp{type}, @samp{solver type}, @samp{pred}, @samp{func}, @samp{typeclass}
and @samp{instance} declarations are used for the type system,
the @samp{inst} and @samp{mode} declarations are for the mode system,
the @samp{pragma} declarations are for the foreign language interface,
and for compiler hints about inlining,
and the remainder are for the module system.
They are described in more detail in their respective chapters.

@node Facts
@section Facts

A function fact is an item of the form @samp{@var{Head} = @var{Result}}.
A predicate fact is an item of the form @samp{@var{Head}},
where the top-level functor of @var{Head}
is not @code{:-/1}, @code{:-/2}, @code{-->/2}, or @code{=/2}.
In both cases, the @var{Head} term must not be a variable.
The top-level functor of the @var{Head}
determines which predicate or function the fact belongs to;
the predicate or function must have been declared
in a preceding @samp{pred} or @samp{func} declaration in this module.
The @var{Result} (if any) and the arguments of the @var{Head}
must be valid data-terms
(optionally annotated with a mode qualifier;
see @ref{Different clauses for different modes}).

A fact is equivalent to a rule whose body is @samp{true}.

@node Rules
@section Rules

A function rule is an item of the form
@samp{@var{Head} = @var{Result} :- @var{Body}}.
A predicate rule is an item of the form
@samp{@var{Head} :- @var{Body}}
where the top-level functor of @samp{Head} is not @code{=/2}.
In both cases, the @var{Head} term must not be a variable.
The top-level functor of the @var{Head} determines
which predicate or function the clause belongs to;
the predicate or function must have been declared
in a preceding @samp{pred} or @samp{func} declaration in this module.
The @var{Result} and the arguments of the @var{Head}
must be valid data-terms
(optionally annotated with a mode qualifier;
see @ref{Different clauses for different modes}).
The @var{Body} must be a valid goal.

@node Goals
@section Goals

A goal is a term of one of the following forms:

@table @asis
@item @code{some @var{Vars} @var{Goal}}
An existential quantification.
@var{Vars} must be a list of variables.
@var{Goal} must be a valid goal.

Each existential quantification introduces a new scope.
The variables in @var{Vars} are local to the goal @var{Goal}:
for each variable named in @var{Vars},
any occurrences of variables with that name in @var{Goal}
are considered to name a different variable
than any variables with the same name
that occur outside of the existential quantification.

Operationally, existential quantification has no effect,
so apart from its effect on variable scoping,
@samp{some @var{Vars} @var{Goal}} is the same as @samp{@var{Goal}}.

Mercury's rules for implicit quantification (@pxref{Implicit quantification})
mean that variables are often implicitly existentially quantified.
There is usually no need to write existential quantifiers explicitly.

@item @code{all @var{Vars} @var{Goal}}
A universal quantification.
@var{Vars} must be a list of variables.
@var{Goal} must be a valid goal.
This is an abbreviation for @samp{not (some @var{Vars} not @var{Goal})}.

@item @code{@var{Goal1}, @var{Goal2}}
A conjunction.
@var{Goal1} and @var{Goal2} must be valid goals.

@item @code{@var{Goal1} & @var{Goal2}}
A parallel conjunction.
This has the same declarative semantics as the normal conjunction.
Operationally,
implementations may execute @var{Goal1} & @var{Goal2} in parallel.
The order in which parallel conjuncts begin execution is not fixed.
It is an error for @var{Goal1} or @var{Goal2}
to have a determinism other than @code{det} or @code{cc_multi}.
@xref{Determinism categories}.

@item @code{@var{Goal1} ; @var{Goal2}}
where @var{Goal1} is not of the form
@samp{@var{Goal1a} -> @var{Goal1b}}: a disjunction.
@var{Goal1} and @var{Goal2} must be valid goals.

@item @code{true}
The empty conjunction.
Always succeeds.

@item @code{fail}
The empty disjunction.
Always fails.

@item @code{not @var{Goal}}
@itemx @code{\+ @var{Goal}}
A negation.
The two different syntaxes have identical semantics.
@var{Goal} must be a valid goal.
Both forms are equivalent to @samp{if @var{Goal} then fail else true}.

@item @code{@var{Goal1} => @var{Goal2}}
An implication.
This is an abbreviation for @samp{not (@var{Goal1}, not @var{Goal2})}.

@item @code{@var{Goal1} <= @var{Goal2}}
A reverse implication.
This is an abbreviation for @samp{not (@var{Goal2}, not @var{Goal1})}.

@item @code{@var{Goal1} <=> @var{Goal2}}
A logical equivalence.
This is an abbreviation for
@samp{(@var{Goal1} => @var{Goal2}), (@var{Goal1} <= @var{Goal2}}).

@item @code{if @var{CondGoal} then @var{ThenGoal} else @var{ElseGoal}}
@itemx @code{@var{CondGoal} -> @var{ThenGoal} ; @var{ElseGoal}}
An if-then-else.
The two different syntaxes have identical semantics.
@var{CondGoal}, @var{ThenGoal}, and @var{ElseGoal} must be valid goals.
Note that the ``else'' part is @emph{not} optional.

The declarative semantics of an if-then-else is given by
@code{( @var{CondGoal}, @var{ThenGoal} ; not(@var{CondGoal}), @var{ElseGoal})},
but the operational semantics are different,
and it is treated differently for the purposes of determinism inference
(@pxref{Determinism}).
Operationally, it executes the @var{CondGoal},
and if that succeeds, then execution continues with the @var{ThenGoal};
otherwise, i.e.@: if @var{CondGoal} fails, it executes the @var{ElseGoal}.
Note that @var{CondGoal} can be nondeterministic ---
unlike Prolog, Mercury's if-then-else does not commit
to the first solution of the condition if the condition succeeds.

If @var{CondGoal} is an explicit existential quantification,
@code{some @var{Vars} @var{QuantifiedCondGoal}}, then the variables @var{Vars}
are existentially quantified over the conjunction of the goals
@var{QuantifiedCondGoal} and @var{ThenGoal}.
Explicit existential quantifications that occur as subgoals of @var{CondGoal}
do @emph{not} affect the scope of variables in the ``then'' part.
For example, in
@example
   ( if some [V] @var{C} then @var{T} else @var{E} )
@end example
@noindent
the variable @var{V} is quantified
over the conjunction of the goals @var{C} and @var{T}
because the top-level goal of the condition
is an explicit existential quantification,
but in
@example
   ( if true, some [V] @var{C} then @var{T} else @var{E} )
@end example
@noindent
the variable @var{V} is only quantified over @var{C}
because the top-level goal of the condition
is not an explicit existential quantification.

@item @code{@var{Term1} = @var{Term2}}
A unification.
@var{Term1} and @var{Term2} must be valid data-terms.

@item @code{@var{Term1} \= @var{Term2}}
An inequality.
@var{Term1} and @var{Term2} must be valid data-terms.
This is an abbreviation for @samp{not (@var{Term1} = @var{Term2})}.

@item @code{call(Closure)}
@itemx @code{call(Closure1, Arg1)}
@itemx @code{call(Closure2, Arg1, Arg2)}
@itemx @code{call(Closure3, Arg1, Arg2, Arg3)}
@itemx @dots{}
A higher-order predicate call.
The closure and arguments must be valid data-terms.
@samp{call(Closure)} just calls the specified closure.
The other forms append the specified arguments
onto the argument list of the closure before calling it.
@xref{Higher-order}.

@item @code{Var}
@itemx @code{Var(Arg1)}
@itemx @code{Var(Arg2)}
@itemx @code{Var(Arg2, Arg3)}
@itemx @dots{}
A higher-order predicate call.
@var{Var} must be a variable.
The semantics are exactly the same as for the corresponding higher-order call
using the @code{call/N} syntax,
i.e.@: @samp{call(Var)}, @samp{call(Var, Arg1)}, etc.

@item @code{promise_pure @var{Goal}}
A purity cast.
@var{Goal} must be a valid goal.
This goal promises that @var{Goal} implements a pure interface,
even though it may include impure and semipure components.

@item @code{promise_semipure @var{Goal}}
A purity cast.
@var{Goal} must be a valid goal.
This goal promises that @var{Goal} implements a semipure interface,
even though it may include impure components.

@item @code{promise_impure @var{Goal}}
A purity cast.
@var{Goal} must be a valid goal.
This goal instructs the compiler to treat @var{Goal} as though it were impure,
regardless of its actual purity.

@item @code{promise_equivalent_solutions @var{Vars} @var{Goal}}
A determinism cast.
@var{Vars} must be a list of variables.
@var{Goal} must be a valid goal.
This goal promises that @var{Vars}
is the set of variables bound by @var{Goal},
and that while @var{Goal} may have more than one solution,
all of these solutions are equivalent
with respect to the equality theories of the variables in @var{Vars}.
It is an error for @var{Vars} to include a variable not bound by @var{Goal}
or for @var{Goal} to bind a non-local variable
that is not listed in @var{Vars}
(non-local variables with inst @code{any} are assumed to be further constrained
by @var{Goal} and must also be included in @var{Vars}).
If @var{Goal} has determinism @code{multi} or @code{cc_multi} then
@code{promise_equivalent_solutions @var{Vars} @var{Goal}}
has determinism @code{det}.
If @var{Goal} has determinism @code{nondet} or @code{cc_nondet} then
@code{promise_equivalent_solutions @var{Vars} @var{Goal}}
has determinism @code{semidet}.

@item @code{promise_equivalent_solution_sets @var{Vars} @var{Goal}}
A determinism cast,
of the kind performed by @code{promise_equivalent_solutions},
on any goals of the form
@code{arbitrary @var{ArbVars} @var{ArbGoal}} inside @var{Goal},
of which there should be at least one.
@var{Vars} and @var{ArbVars} must be lists of variables,
and @var{Goal} and @var{ArbGoal} must be valid goals.
@var{Vars} must be the set of variables bound by @var{Goal},
and @var{ArbVars} must be the set of variables bound by @var{ArbGoal},
It is an error for @var{Vars} to include a variable not bound by @var{Goal}
or for @var{Goal} to bind a non-local variable
that is not listed in @var{Vars},
and similarly for @var{ArbVars} and @var{ArbGoal}.
The intersection of @var{Vars} and the @var{ArbVars} list
of any @code{arbitrary @var{ArbVars} @var{ArbGoal}} goal
included inside @var{Goal} must be empty.

The overall @var{promise_equivalent_solution_sets} goal promises that
the set of solutions computed for @var{Vars} by @var{Goal}
is not influenced by which of the possible solutions
for @var{ArbVars} is computed by each @var{ArbGoal};
while different choices of solutions for some of the @var{ArbGoal}s
may lead to syntactically different solutions for @var{Vars} for @var{Goal},
all of these solutions are equivalent
with respect to the equality theories of the variables in @var{Vars}.
If an @var{ArbGoal} has determinism @code{multi} or @code{cc_multi} then
@code{arbitrary @var{ArbVars} @var{ArbGoal}} has determinism @code{det}.
If @var{ArbGoal} has determinism @code{nondet} or @code{cc_nondet} then
@code{arbitrary @var{ArbVars} @var{ArbGoal}} has determinism @code{semidet}.
@var{Goal} itself may have any determinism.

There is no requirement that given one of the @var{ArbGoal}s,
all its solutions must be equivalent with respect to the equality theories
of the corresponding @var{ArbVars};
in fact, in typical usage, this won't be the case.
The different solutions of the nested @var{arbitrary} goals
are not required to be equivalent in any context
except the @var{promise_equivalent_solution_sets} goal they are nested inside.

Goals of the form @code{arbitrary @var{ArbVars} @var{ArbGoal}}
are not allowed to occur outside
@code{promise_equivalent_solution_sets @var{Vars} @var{Goal}} goals.

@item @code{require_det @var{Goal}}
@itemx @code{require_semidet @var{Goal}}
@itemx @code{require_multi @var{Goal}}
@itemx @code{require_nondet @var{Goal}}
@itemx @code{require_cc_multi @var{Goal}}
@itemx @code{require_cc_nondet @var{Goal}}
@itemx @code{require_erroneous @var{Goal}}
@itemx @code{require_failure @var{Goal}}
A determinism check, typically used to enhance the robustness of code.
@var{Goal} must be a valid goal.
If @var{Goal} is det, then
@code{require_det @var{Goal}} is equivalent to just @var{Goal}.
If @var{Goal} is not det,
then the compiler is required to generate an error message.

The @code{require_det} keyword may be replaced with
@code{require_semidet},
@code{require_multi},
@code{require_nondet},
@code{require_cc_multi},
@code{require_cc_nondet},
@code{require_erroneous} or
@code{require_failure},
each of which requires @var{Goal} to have the named determinism.

@item @code{require_complete_switch [@var{Var}] @var{Goal}}
A switch completeness check, typically used to enhance the robustness of code.
If @var{Goal} is a switch on @var{Var}
and the switch is @emph{complete},
i.e. the switch has an arm for every function symbol that @var{Var}
could be bound to at this point in the code,
then @code{require_complete_switch [@var{Var}] @var{Goal}}
is equivalent to @var{Goal}.
If @var{Goal} is a switch on @var{Var} but is @emph{not} complete,
or @var{Goal} is not a switch on @var{Var} at all,
then the compiler is required to generate an error message.

@item @code{require_switch_arms_det [@var{Var}] @var{Goal}}
@itemx @code{require_switch_arms_semidet [@var{Var}] @var{Goal}}
@itemx @code{require_switch_arms_multi [@var{Var}] @var{Goal}}
@itemx @code{require_switch_arms_nondet [@var{Var}] @var{Goal}}
@itemx @code{require_switch_arms_cc_multi [@var{Var}] @var{Goal}}
@itemx @code{require_switch_arms_cc_nondet [@var{Var}] @var{Goal}}
@itemx @code{require_switch_arms_erroneous [@var{Var}] @var{Goal}}
@itemx @code{require_switch_arms_failure [@var{Var}] @var{Goal}}
@code{require_switch_arms_det} is a determinism check,
typically used to enhance the robustness of code.
@var{Goal} must be a valid goal.
If @var{Goal} is a switch on @var{Var},
and all arms of the switch would be allowable in a det context,
@code{require_switch_arms_det [@var{Var}] @var{Goal}}
is equivalent to @var{Goal}.
If @var{Goal} is not a switch on @var{Var},
or if it is a switch on @var{Var}
but some of its arms would @emph{not} be allowable in a det context,
then the compiler is required to generate an error message.

The @code{require_switch_arms_det} keyword may be replaced with
@code{require_switch_arms_semidet},
@code{require_switch_arms_multi},
@code{require_switch_arms_nondet},
@code{require_switch_arms_cc_multi},
@code{require_switch_arms_cc_nondet},
@code{require_switch_arms_erroneous} or
@code{require_switch_arms_failure},
each of which requires
the arms of the switch on @var{Var} to have a determinism
that is @emph{at least as tight} as the named determinism.
The determinism match need not be exact;
the requirement is that the arms' determinisms should make
all the promises about the minimum and maximum number of solutions
as the named determinism does.
For example, it is ok to have a det switch arm
in a @code{require_switch_arms_semidet} scope,
even though it would not be ok
to have a det goal in a @code{require_semidet} scope.

@item @code{disable_warnings [@var{Warning}] @var{Goal}}
@itemx @code{disable_warning [@var{Warning}] @var{Goal}}
The Mercury compiler can generate warnings
about several kinds of constructs that whose legal Mercury semantics
is likely to differ from the semantics intended by the programmer.
While such warnings are useful most of the time,
they are a distraction in cases where the programmer's intention
@emph{does} match the legal semantics.
Programmers can disable all warnings of a particular kind for an entire module
by compiling that module with the appropriate compiler option,
but in many cases this is not a good idea,
since some of the warnings it disables may @emph{not} have been mistaken.
This is what these goals are for.
The goal @code{disable_warnings [@var{Warning}] @var{Goal}}
is equivalent to @code{@var{Goal}} in all respects, with one exception:
the Mercury compiler will not generate warnings of any of the categories
whose names appear in @code{[@var{Warning}]}.

At the moment, the Mercury compiler supports the disabling of
the following warning categories:
@table @asis
@item @code{singleton_vars}
Disable the generation of singleton variable warnings.
@item @code{suspected_occurs_check_failure}
Disable the generation of warnings about code that looks like
it unifies a variable with a term that contains that same variable.
@c @item @code{non_tail_recursive_calls}
@c Disable the generation of warnings about recursive calls
@c that are not @emph{tail}-recursive calls.
@item @code{suspicious_recursion}
Disable the generation of warnings about suspicious recursive calls.
@end table

The keyword starting this scope may be written
either as @code{disable_warnings} or as @code{disable_warning}.
This is intended to make the code read more naturally
regardless of whether the list contains the name of
more than one disabled warning category.

@item @code{trace @var{Params} @var{Goal}}
A trace goal, typically used for debugging or logging.
@var{Goal} must be a valid goal;
@var{Params} must be a valid list of trace parameters.
Some trace parameters specify compile time or run time conditions;
if any of these conditions are false, @var{Goal} will not be executed.
Since in some program invocations
@var{Goal} may be replaced by @samp{true} in this way,
@var{Goal} may not bind or change the instantiation state
of any variables it shares with the surrounding context.
The things it may do are thus restricted to side effects;
good programming style requires these side effects
to not have any affect on the execution of the program itself,
but to be confined to the provision of extra information
for the user of the program.
See @ref{Trace goals} for the details.

@item @code{try @var{Params} @var{Goal} @dots{} catch @var{Term} -> @var{CGoal} @dots{}}
A try goal.
Exceptions thrown during the execution of @var{Goal} may be caught and handled.
A summary of the try goal syntax is:

@example
@group
    try @var{Params} @var{Goal}
    then @var{ThenGoal}
    else @var{ElseGoal}
    catch @var{Term} -> @var{CatchGoal}
    @dots{}
    catch_any @var{CatchAnyVar} -> @var{CatchAnyGoal}
@end group
@end example

See @ref{Exception handling} for the full details.

@item @code{event @var{Goal}}
An event goal.
@var{Goal} must be a predicate call.
Event goals are an extension used by the Melbourne Mercury implementation
to support user defined events in the Mercury debugger, @samp{mdb}.
See the ``Debugging'' chapter of the Mercury User's Guide for further details.

@item @code{@var{Call}}
Any goal which does not match any of the above forms
must be a predicate call.
The top-level functor of the term determines the predicate called;
the predicate must be declared in a @code{pred} declaration
in the module or in the interface of an imported module.
The arguments must be valid data-terms.

@end table

@node State variables
@section State variables

Clauses may use @samp{state variables}
as a shorthand for naming intermediate values in a sequence.
That is, where in the plain syntax one might write
@example
    main(IO0, IO) :-
        io.write_string("The answer is ", IO0, IO1),
        io.write_int(calculate_answer(@dots{}), IO1, IO2),
        io.nl(IO3, IO).
@end example
@noindent
using state variable syntax one could write
@example
    main(!IO) :-
        io.write_string("The answer is ", !IO),
        io.write_int(calculate_answer(@dots{}), !IO),
        io.nl(!IO).
@end example

A state variable is written @samp{!.@var{X}} or @samp{!:@var{X}},
denoting the ``current'' or ``next'' value of the sequence labelled @var{X}.
An argument @samp{!@var{X}} is shorthand
for two state variable arguments @samp{!.@var{X}, !:@var{X}};
that is,
@samp{p(@dots{}, !@var{X}, @dots{})}
is parsed as
@samp{p(@dots{}, !.@var{X}, !:@var{X}, @dots{})}.

Within each clause, a transformation converts state variables
into sequences of ordinary logic variables.
The syntactic conversion is described in terms of
the notional @samp{transform} function defined next.

The transformation is applied once for each state variable @var{X}
with some fresh variables which we shall call @var{ThisX} and @var{NextX}.

The expression
@samp{substitute(@var{Term}, @var{X}, @var{ThisX}, @var{NextX})}
stands for a copy of @var{Term}
with free occurrences of @samp{!.@var{X}} replaced with @var{ThisX}
and free occurrences of @samp{!:@var{X}} replaced with @var{NextX}
(a free occurrence is one not bound
by the head of a clause or lambda, or by explicit quantification.)

State variables obey special scope rules.
A state variable @var{X} must be explicitly introduced
either in the head of the clause or lambda
(in which case it may appear as either or both of
@samp{!.@var{X}} or @samp{!:@var{X}})
or in an explicit quantification
(in which case it must appear as @samp{!@var{X}}.)
A state variable @var{X} in the enclosing scope
of a lambda or if-then-else expression
may only be referred to as @samp{!.@var{X}}
(unless the enclosing @var{X} is masked
by a more local state variable of the same name.)

For instance, the following clause employing a lambda expression
@example
p(@var{A}, @var{B}, !@var{S}) :-
    F = (pred(@var{C}::in, @var{D}::out) is det :-
        q(@var{C}, @var{D}, !@var{S})
    ),
    ( F(@var{A}, @var{E}) ->
        @var{B} = @var{E}
    ;
        @var{B} = @var{A}
    ).
@end example
@noindent
is illegal because
it implicitly refers to @samp{!:@var{S}} inside the lambda expression.
However
@example
p(@var{A}, @var{B}, !@var{S}) :-
    F = (pred(@var{C}::in, @var{D}::out, !.@var{S}::in, !:@var{S}::out) is det :-
        q(@var{C}, @var{D}, !@var{S})
    ),
    ( F(@var{A}, @var{E}, !@var{S}) ->
        @var{B} = @var{E}
    ;
        @var{B} = @var{A}
    ).
@end example
@noindent
is acceptable because
the state variable @var{S} accessed inside the lambda expression
is locally scoped to the lambda expression
(shadowing the state variable of the same name outside the lambda expression),
and the lambda expression may refer to
the next version of a local state variable.

There are three restrictions concerning state variables in lambdas:
first, @samp{!@var{X}} is not a legitimate function result,
since it stands for two arguments, rather than one;
second, @samp{!@var{X}} may not appear as a parameter term
in the head of a lambda,
since there is no syntax
for specifying the modes of the two implied parameters;
third, @samp{!@var{X}} may not appear as an argument in a function application
since this would not make sense
given the usual interpretation of state variables and functions.

@table @code

@item @var{Head} :- @var{Body}
@example
transform((@var{Head} :- @var{Body}), @var{X}, @var{ThisX}, @var{NextX}) =
substitute(@var{Head}, @var{X}, @var{ThisX}, @var{NextX}) :- transform(@var{Body}, @var{X}, @var{ThisX}, @var{NextX})
@end example

@item @var{Head} --> @var{Body}
@example
transform((@var{Head} --> @var{Body}), @var{X}, @var{ThisX}, @var{NextX}) =
substitute(@var{Head}, @var{X}, @var{ThisX}, @var{NextX}) :- transform(@var{Body}, @var{X}, @var{ThisX}, @var{NextX})
@end example

@item @var{Goal1}, @var{Goal2}
@example
transform((@var{Goal1}, @var{Goal2}), @var{X}, @var{ThisX}, @var{NextX}) =
transform(@var{Goal1}, @var{X}, @var{ThisX}, @var{TmpX}), transform(@var{Goal2}, @var{X}, @var{TmpX}, @var{NextX})
@end example
for some fresh variable @var{TmpX}.

@item @var{Goal1} ; @var{Goal2}
@example
transform((@var{Goal1} ; @var{Goal2}), @var{X}, @var{ThisX}, @var{NextX}) =
transform(@var{Goal1}, @var{X}, @var{ThisX}, @var{NextX}) ; transform(@var{Goal2}, @var{X}, @var{ThisX}, @var{NextX})
@end example

@item not @var{Goal}
@item \+ @var{Goal}
@example
transform((not @var{Goal}), @var{X}, @var{ThisX}, @var{NextX}) =
not transform(@var{Goal1}, @var{X}, @var{ThisX}, @var{DummyX}), @var{NextX} = @var{ThisX}
@end example
for some fresh variable @var{DummyX}.

@item if @var{Goal1} then @var{Goal2} else @var{Goal3}
@item @var{Goal1} -> @var{Goal2} ; @var{Goal3}
@example
transform((if @var{Goal1} then @var{Goal2} else @var{Goal3}), @var{X}, @var{ThisX}, @var{NextX}) =
if transform(@var{Goal1}, @var{X}, @var{ThisX}, @var{TmpX}) then transform(@var{Goal2}, @var{X}, @var{TmpX},  @var{NextX})
                                    else transform(@var{Goal3}, @var{X}, @var{ThisX}, @var{NextX})
@end example
for some fresh variable @var{TmpX}.

@item @var{Goal1} => @var{Goal2}
@item @var{Goal2} <= @var{Goal1}
@example
transform((@var{Goal1} => @var{Goal2}), @var{X}, @var{ThisX}, @var{NextX}) =
transform(@var{Goal1}, @var{X}, @var{ThisX}, @var{TmpX}) => transform(@var{Goal2}, @var{X}, @var{TmpX},  @var{NextX}),
@var{NextX} = @var{ThisX}
@end example
for some fresh variable @var{TmpX}.

@item all @var{Vars} @var{Goal}
@example
transform((all @var{Vars} @var{Goal}), @var{X}, @var{ThisX}, @var{NextX}) =
all @var{Vars} transform(@var{Goal}, @var{X}, @var{ThisX}, @var{DummyX}), @var{NextX} = @var{ThisX}
@end example
for some fresh variable @var{DummyX}.

@item some @var{Vars} @var{Goal}
@example
transform((some @var{Vars} @var{Goal}), @var{X}, @var{ThisX}, @var{NextX}) =
some @var{Vars} transform(@var{Goal}, @var{X}, @var{ThisX}, @var{NextX})
@end example

@item !@var{X} ^ @var{field_list} := @var{Term}
A field update.
Replaces a field in the argument.
@var{Term} must be a valid data-term.
@var{field_list} must be a valid field list.
@xref{Record syntax}.
@example
transform((!@var{X} ^ @var{field_list} := @var{Term}), @var{X}, @var{ThisX}, @var{NextX}) =
NextX = ThisX ^ field_list := Term
@end example

@item @var{Call_or_Unification}
If @samp{!:@var{X}} does not appear in @var{Call_or_Unification} then
@example
transform(@var{Call_or_Unification}, @var{X}, @var{ThisX}, @var{NextX}) =
substitute(@var{Call_or_Unification}, @var{X}, @var{ThisX}, @var{NextX}), @var{NextX} = @var{ThisX}
@end example
If @samp{!:@var{X}} does appear in @var{Call_or_Unification} then
@example
transform(@var{Call_or_Unification}, @var{X}, @var{ThisX}, @var{NextX}) =
substitute(@var{Call_or_Unification}, @var{X}, @var{ThisX}, @var{NextX})
@end example

@end table

This transformation can lead
to the introduction of chains of unifications for variables
that do not otherwise play a role in the definition.
Such chains are removed transparently.

The following code fragments illustrate
appropriate use of state variable syntax.

@table @b

@item Threading the I/O state
@example
main(!IO) :-
    io.write_string("The 100th prime is ", !IO),
    X = prime(100),
    io.write_int(X, !IO),
    io.nl(!IO).
@end example

@item Handling accumulators (1)
@example
foldl2(_, [], !A, !B).
foldl2(P, [X | Xs], !A, !B) :-
    P(X, !A, !B),
    foldl2(P, Xs, !A, !B).
@end example

@item Handling accumulators (2)
@example
iterate_while2(P, F, !A, !B) :-
    ( if P(!.A, !.B) then
        F(!A, !B),
        iterate_while2(P, F, !A, !B)
    else
        true
    ).
@end example
@end table

@node DCG-rules
@section DCG-rules

Definite Clause Grammar notation
is intended for writing parsers and sequence generators in a particular style;
in the past it has also been used to thread an implicit state variable,
typically the I/O state, through code.
As a matter of style, we recommend that
in future DCG notation be reserved for writing parsers and sequence generators,
and that state variable syntax be used for passing state threads.

DCG-rules in Mercury have identical syntax and semantics
to DCG-rules in Prolog.

A DCG-rule is an item of the form @samp{@var{Head} --> @var{Body}}.
The @var{Head} term must not be a variable.
A DCG-rule is an abbreviation for an ordinary rule
with two additional implicit arguments appended to the arguments of @var{Head}.
These arguments are fresh variables,
which we shall call @var{V_in} and @var{V_out}.
The @var{Body} must be a valid DCG-goal,
and is an abbreviation for an ordinary goal.
The next section defines a mathematical function
@samp{DCG-transform(@var{V_in}, @var{V_out}, @var{DCG-goal})}
which specifies the semantics
of how DCG goals are transformed into ordinary goals.
(The @samp{DCG-transform} function is purely for the purposes of exposition,
to define the semantics --- it is not part of the language.)

@node DCG-goals
@section DCG-goals

A DCG-goal is a term of one of the following forms:

@table @code
@item some @var{Vars} @var{DCG-goal}
A DCG existential quantification.
@var{Vars} must be a list of variables.
@var{DCG-goal} must be a valid DCG-goal.

Semantics:
@example
transform(V_in, V_out, some Vars DCG_goal) =
some Vars transform(V_in, V_out, DCG_goal)
@end example

@item all @var{Vars} @var{DCG-goal}
A DCG universal quantification.
@var{Vars} must be a list of variables.
@var{DCG-goal} must be a valid DCG-goal.

Semantics:
@example
transform(V_in, V_out, all Vars DCG_goal) =
all Vars transform(V_in, V_out, DCG_goal)
@end example

@item @var{DCG-goal1}, @var{DCG-goal2}
A DCG sequence.
Intuitively, this means ``parse @var{DCG-goal1} and then parse @var{DCG-goal2}''
or ``do @var{DCG-goal1} and then do @var{DCG-goal2}''.
(Note that the only way this construct actually forces the desired sequencing
is by the modes of the implicit DCG arguments.)
@var{DCG-goal1} and @var{DCG-goal2} must be valid DCG-goals.

Semantics:
@c XXX too indented
@example
transform(V_in, V_out, (DCG-goal1, DCG-goal2)) =
(transform(V_in, V_new, DCG_goal1), transform(V_new, V_out, DCG_goal2))
@end example
where V_new is a fresh variable.

@item @var{DCG-goal1} ; @var{DCG-goal2}
A disjunction.  @var{DCG-goal1} and @var{DCG-goal2} must be valid goals.
@var{DCG-goal1} must not be of the form @samp{DCG-goal1a -> DCG-goal1b}.
(If it is, then the goal is an if-then-else, not a disjunction.)

Semantics:
@c XXX too indented
@example
transform(V_in, V_out, (DCG_goal1 ; DCG_goal2)) =
( transform(V_in, V_out, DCG_goal1)
; transform(V_in, V_out, DCG_goal2)
)
@end example

@item @{ @var{Goal} @}
A brace-enclosed ordinary goal.
@var{Goal} must be a valid goal.

Semantics:
@example
transform(V_in, V_out, @{ Goal @}) = (Goal, V_out = V_in)
@end example

@item [@var{Term}, @dots{}]
A DCG input match.
Unifies the implicit DCG input variable V_in,
which must have type @samp{list(_)},
with a list whose initial elements are the terms specified
and whose tail is the implicit DCG output variable V_out.
The terms must be valid data-terms.

Semantics:
@example
transform(V_in, V_out, [Term1, @dots{}]) = (V_in = [Term, @dots{} | V_Out])
@end example

@item []
The null DCG goal (an empty DCG input match).
Equivalent to @samp{@{ true @}}.

Semantics:
@example
transform(V_in, V_out, []) = (V_out = V_in)
@end example

@item not @var{DCG-goal}
@itemx \+ @var{DCG-goal}
A DCG negation.
The two different syntaxes have identical semantics.
@var{Goal} must be a valid goal.

Semantics:
@example
transform(V_in, V_out, not DCG_goal) =
(not transform(V_in, V_new, DCG_goal), V_out = V_in)
@end example
where V_new is a fresh variable.

@item if @var{CondGoal} then @var{ThenGoal} else @var{ElseGoal}
@itemx @var{CondGoal} -> @var{ThenGoal} ; @var{ElseGoal}
A DCG if-then-else.
The two different syntaxes have identical semantics.
@var{CondGoal}, @var{ThenGoal}, and @var{ElseGoal} must be valid DCG-goals.

Semantics:
@example
transform(V_in, V_out, if CondGoal then ThenGoal else ElseGoal) =
if transform(V_in, V_cond, CondGoal) then
        transform(V_cond, V_out, ThenGoal)
else
        transform(V_in, V_out, ElseGoal)
@end example

@item =(@var{Term})
A DCG unification.
Unifies @var{Term} with the implicit DCG argument.
@var{Term} must be a valid data-term.

Semantics:
@example
transform(V_in, V_out, =(Term)) = (Term = V_in, V_out = V_in)
@end example

@item :=(@var{Term})
A DCG output unification.
Unifies @var{Term} with the implicit DCG output argument,
ignoring the input DCG argument.
@var{Term} must be a valid data-term.

Semantics:
@example
transform(V_in, V_out, :=(Term)) = (V_out = Term)
@end example

@item @var{Term} =^ @var{field_list}
A DCG field selection.
Unifies @var{Term} with the result of
applying the field selection @var{field_list} to the implicit DCG argument.
@var{Term} must be a valid data-term.
@var{field_list} must be a valid field list.
@xref{Record syntax}.

Semantics:
@example
transform(V_in, V_out, Term =^ field_list) =
        (Term = V_in ^ field_list, V_out = V_in)
@end example

@item ^ @var{field_list} := @var{Term}
A DCG field update.
Replaces a field in the implicit DCG argument.
@var{Term} must be a valid data-term.
@var{field_list} must be a valid field list.
@xref{Record syntax}.

Semantics:
@example
transform(V_in, V_out, ^ field_list := Term) =
        (V_out = V_in ^ field_list := Term)
@end example

@item @var{DCG-call}
Any term which does not match any of the above forms
must be a DCG predicate call.
If the term is a variable @var{Var},
it is treated as if it were @samp{call(@var{Var})}.
Then, the two implicit DCG arguments are appended to the specified arguments.

Semantics:
@example
transform(V_in, V_out, p(A1, @dots{}, AN)) =
p(A1, @dots{}, AN, V_in, V_out)
@end example

@end table

@node Data-terms
@section Data-terms

Syntactically, a data-term is just a term.

There are a couple of differences from Prolog.
The first one is that double-quoted strings are atomic in Mercury,
they are not abbreviations for lists of character codes.
The second is that Mercury provides several extensions to Prolog's term syntax:
Mercury terms may contain
record field selection and field update expressions,
conditional (if-then-else) expressions,
function applications,
higher-order function applications,
lambda expressions,
and explicit type qualifications.

A data-term is either
a variable, a data-functor, or a special data-term.
A special data-term is
a conditional expression,
a record syntax expression,
a unification expression,
a lambda expression,
a higher-order function application,
or an explicit type qualification.

@menu
* Data-functors::
* Record syntax::
* Unification expressions::
* Conditional expressions::
* Lambda expressions::
* Higher-order function applications::
* Explicit type qualification::
@end menu

@node Data-functors
@subsection Data-functors

A data-functor is an integer, a float, a string,
a character literal (any single-character name),
a name, an implementation-defined literal, or a compound data-term.
A compound data-term is a compound term
which does not match the form of a special data-term (@pxref{Data-terms}),
and whose arguments are data-terms.
If a data-functor is a name or a compound data-term,
its top-level functor must name
a function, predicate, or data constructor
declared in the module or in the interface of an imported module.

Implementation-defined literals are symbolic names
whose value represents a property of the compilation environment
or the context in which it appears.
The implementation replaces these symbolic names
with actual constants during compilation.
Implementation-defined literals can only appear within clauses.
The following literals must be supported by all Mercury implementations:

@table @asis
@item @samp{$file}
a string that gives the name of the file
that contains the module being compiled.
If the name of the file cannot be determined,
then it is replaced by an arbitrary string.

@item @samp{$line}
the line number (integer) of the goal in which the literal appears,
or -1 if it cannot be determined.

@item @samp{$module}
a string representation of the fully-qualified module name.

@item @samp{$pred}
a string containing the fully-qualified predicate or function name and arity.

@end table

The Melbourne Mercury implementation
additionally supports the following extension:

@table @asis
@item @samp{$grade}
the grade (string) in which the module is compiled.

@end table

@node Record syntax
@subsection Record syntax

Record syntax provides a convenient way
to select or update fields of data constructors,
independent of the definition of the constructor.
Record syntax expressions are transformed into
sequences of calls to field selection or update functions
(@pxref{Field access functions}).

A field specifier is a name or a compound data-term.
A field list is a list of field specifiers separated by @code{^}.
@code{field}, @code{field1 ^ field2} and @code{field1(A) ^ field2(B, C)}
are all valid field lists.

If the top-level functor of a field specifier is @samp{@var{field}/N},
there must be a visible selection function @samp{@var{field}/(N + 1)}.
If the field specifier occurs in a field update expression,
there must also be a visible update function
named @samp{'@var{field} :='/(N + 2)}.

Record syntax expressions have one of the following forms.
There are also record syntax DCG goals (@pxref{DCG-goals}),
which provide similar functionality to record syntax expressions,
except that they act on the DCG arguments of a DCG clause.

@table @code
@item @var{Term} ^ @var{field_list}

A field selection.
For each field specifier in @var{field_list},
apply the corresponding selection function in turn.

@var{Term} must be a valid data-term.
@var{field_list} must be a valid field list.

A field selection is transformed using the following rules:
@example
transform(Term ^ Field(Arg1, @dots{})) = Field(Arg1, @dots{}, Term).
transform(Term ^ Field(Arg1, @dots{}) ^ Rest) =
                transform(Field(Arg1, @dots{}, Term) ^ Rest).
@end example

Examples:

@code{Term ^ field} is equivalent to @code{field(Term)}.

@code{Term ^ field(Arg)} is equivalent to @code{field(Arg, Term)}.

@w{@code{Term ^ field1(Arg1) ^ field2(Arg2, Arg3)}} is equivalent
to @w{@code{field2(Arg2, Arg3, field1(Arg1, Term))}}.

@item @var{Term} ^ @var{field_list} := @var{FieldValue}

A field update, returning a copy of @var{Term}
with the value of the field specified by @var{field_list}
replaced with @var{FieldValue}.

@var{Term} must be a valid data-term.
@var{field_list} must be a valid field list.

A field update is transformed using the following rules:
@example
transform(Term ^ Field(Arg1, @dots{}) := FieldValue) =
                'Field :='(Arg1, @dots{}, Term, FieldValue)).

transform(Term0 ^ Field(Arg1, @dots{}) ^ Rest := FieldValue) = Term :-
        OldFieldValue = Field(Arg1, @dots{}, Term0),
        NewFieldValue = transform(OldFieldValue ^ Rest := FieldValue),
        Term = 'Field :='(Arg1, @dots{}, Term0, NewFieldValue).
@end example

Examples:

@w{@code{Term ^ field := FieldValue}}
is equivalent to @w{@code{'field :='(Term, FieldValue)}}.

@w{@code{Term ^ field(Arg) := FieldValue}}
is equivalent to @w{@code{'field :='(Arg, Term, FieldValue)}}.

@w{@code{Term ^ field1(Arg1) ^ field2(Arg2) := FieldValue}}
is equivalent to the code
@example
OldField1 = field1(Arg1, Term),
NewField1 = 'field2 :='(Arg2, OldField1, FieldValue),
Result = 'field1 :='(Arg1, Term, NewField1)
@end example

@end table

@node Unification expressions
@subsection Unification expressions

A unification expression is an expression of the form

@example
@var{X} @@ @var{Y}
@end example

@noindent
where @var{X} and @var{Y} are data-terms.

The meaning of a unification expression is that the arguments are unified,
and the expression is equivalent to the unified value.

The strict sequential operational semantics (@pxref{Semantics})
of an expression @w{@code{@var{X} @@ @var{Y}}}
is that the expression is replaced by a fresh variable @code{Z},
and immediately after @code{Z} is evaluated,
the conjunction @w{@code{Z = @var{X}, Z = @var{Y}}} is evaluated.

For example

@example
p(X @@ f(_, _), X).
@end example

@noindent
is equivalent to

@example
p(H1, H2) :-
    H1 = X,
    H1 = f(_, _),
    H2 = X.
@end example

Unification expressions are most useful when writing switches
(@pxref{Determinism checking and inference}).
The arguments of a unification expression
are examined when checking for switches.
The arguments of an equivalent user-defined function would not be.

@node Conditional expressions
@subsection Conditional expressions

A conditional expression is an expression of either of the two following forms

@example
(if @var{Goal} then @var{Expression1} else @var{Expression2})
(@var{Goal} -> @var{Expression1} ; @var{Expression2})
@end example

@noindent
@var{Goal} is a goal;
@var{Expression1} and @var{Expression2} are both data-terms.
The semantics of a conditional expression is that
if @var{Goal} is true,
then the expression has the meaning of @var{Expression1},
else the expression has the meaning of @var{Expression2}.

If @var{Goal} takes the form @code{some [X, Y, Z] @dots{}}
then the scope of @var{X}, @var{Y}, and @var{Z} includes @var{Expression1}.

@node Lambda expressions
@subsection Lambda expressions

A lambda expression is a compound term of one of the following forms

@example
pred(Arg1::Mode1, Arg2::Mode2, @dots{}) is Det :- Goal
pred(Arg1::Mode1, Arg2::Mode2, @dots{}, DCGMode0, DCGMode1) is Det --> DCGGoal
func(Arg1::Mode1, Arg2::Mode2, @dots{}) = (Result::Mode) is Det :- Goal
func(Arg1, Arg2, @dots{}) = (Result) is Det :- Goal
func(Arg1, Arg2, @dots{}) = Result :- Goal
@end example

@noindent
where @var{Arg1}, @var{Arg2}, @dots{} are zero or more data-terms,
@var{Result} is a data-term,
@var{Mode1}, @var{Mode2}, @dots{} are zero or more modes (@pxref{Modes}),
@var{DCGMode0} and @var{DCGMode1} are modes (@pxref{Modes}),
@var{Det} is a determinism (@pxref{Determinism}),
@var{Goal} is a goal (@pxref{Goals}),
and @var{DCGGoal} is a DCG Goal (@pxref{DCG-goals}).
The @samp{:- Goal} part is optional;
if it is not specified, then @samp{:- true} is assumed.
A lambda expression denotes a higher-order predicate or function term
whose value is the predicate or function of the specified arguments
determined by the specified goal.
@xref{Higher-order}.

A lambda expression introduces a new scope:
any variables occurring in the arguments @var{Arg1}, @var{Arg2}, @dots{}
are locally quantified, i.e.@:
any occurrences of variables with that name in the lambda expression
are considered to name a different variable than any variables
with the same name that occur outside of the lambda expression.
For variables which occur in @var{Result} or @var{Goal},
but not in the arguments,
the usual Mercury rules for implicit quantification apply
(@pxref{Implicit quantification}).

The form of lambda expression using @samp{-->} as its top level functor
is a syntactic abbreviation:
an expression of the form

@example
pred(Var1::Mode1, Var2::Mode2, @dots{}, DCGMode0, DCGMode1) is Det --> DCGGoal
@end example

@noindent
is equivalent to

@example
pred(Var1::Mode1, Var2::Mode2, @dots{},
    DCGVar0::DCGMode0, DCGVar1::DCGMode1) is Det :- Goal
@end example

@noindent
where @var{DCGVar0} and @var{DCGVar1} are fresh variables,
and @var{Goal} is the result of @samp{DCG-transform(DCGVar0, DCGVar1, DCGGoal)}
where DCG-transform is the function specified in @ref{DCG-goals}.

@node Higher-order function applications
@subsection Higher-order function applications

A higher-order function application is a compound term
of one of the following two forms

@example
apply(@var{Func}, @var{Arg1}, @var{Arg2}, @dots{}, @var{ArgN})
@var{FuncVar}(@var{Arg1}, @var{Arg2}, @dots{}, @var{ArgN})
@end example

@noindent
where @var{N} >= 0, @var{Func} is a term
of type @samp{func(T1, T2, @dots{}, Tn) = T},
@var{FuncVar} is a variable of that type, and
@var{Arg1}, @var{Arg2}, @dots{}, @var{ArgN}
are terms of types @samp{T1}, @samp{T2}, @dots{}, @samp{Tn}.
The type of the higher-order function application term is @var{T}.
It denotes the result of applying the specified function
to the specified arguments.
@xref{Higher-order}.

@node Explicit type qualification
@subsection Explicit type qualification

Explicit type qualifications are occasionally useful to resolve ambiguities
that can arise from overloading or polymorphic types.

An explicit type qualification expression is a term of the form

@example
@var{Term} : @var{Type}
@end example

@noindent
@var{Term} must be a valid data-term.
@var{Type} must be a valid type (@pxref{Types}).

An explicit type qualification expression constrains
the specified term to have the specified type.
Apart from that, the meaning of an explicit type qualification expression
is just the same as the specified @var{Term}.

Currently we also support the following alternative syntax
for type qualification:

@example
with_type(@var{Term}, @var{Type})
@end example

@noindent
or equivalently, as it is more commonly written,

@example
@var{Term} `with_type` @var{Type}
@end example

@node Variable scoping
@section Variable scoping

There are three sorts of variables in Mercury:
ordinary variables, type variables, and inst variables.

Variables occurring in types are called type variables.
Variables occurring in insts or modes are called inst variables.
Variables that occur in data-terms,
and that are not inst variables or type variables,
are called ordinary variables.

(Type variables can occur in data-terms
in the right-hand [@var{Type}] operand of an explicit type qualification.
Inst variables can occur in data-terms
in the right-hand [@var{Mode}] operand of an explicit mode qualification.
Apart from that, all other variables in data-terms are ordinary variables.)

The three different variable sorts occupy different namespaces:
there is no semantic relationship between two variables of different sorts
(e.g.@: a type variable and an ordinary variable)
even if they happen to share the same name.
However, as a matter of programming style, it is generally a bad idea
to use the same name for variables of different sorts in the same clause.

The scope of ordinary variables
is the clause or declaration in which they occur,
unless they are quantified,
either explicitly (@pxref{Goals})
or implicitly (@pxref{Implicit quantification}).

The scope of type variables in a predicate or function's type declaration
extends over any explicit type qualifications
(@pxref{Explicit type qualification})
in the clauses for that predicate or function,
and over @samp{pragma type_spec} (@pxref{Type specialization}) declarations
for that predicate or function,
so that explicit type qualifications and @samp{pragma type_spec} declarations
can refer to those type variables.
The scope of any type variables in an explicit type qualification
which do not occur in the predicate or function's type declaration
is the clause in which they occur.

The scope of inst variables is the clause or declaration in which they occur.

@node Implicit quantification
@section Implicit quantification

The rule for implicit quantification in Mercury
is not the same as the usual one in mathematical logic.
In Mercury, variables that do not occur in the head of a clause
are implicitly existentially quantified around their closest enclosing scope
(in a sense to be made precise in the following paragraphs).
This allows most existential quantifiers to be omitted,
and leads to more concise code.

An occurrence of a variable is @dfn{in a negated context}
if it is in a negation,
in a universal quantification,
in the condition of an if-then-else,
in an inequality,
or in a lambda expression.

Two goals are @dfn{parallel}
if they are different disjuncts of the same disjunction,
or if one is the ``else'' part of an if-then-else
and the other goal is either the ``then'' part or the condition
of the if-then-else,
or if they are the goals of disjoint (distinct and non-overlapping)
lambda expressions.

If a variable occurs in a negated context
and does not occur outside of that negated context other than in parallel goals
(and in the case of a variable in the condition of an if-then-else,
other than in the ``then'' part of the if-then-else),
then that variable is implicitly existentially quantified inside the negation.

@node Elimination of double negation
@section Elimination of double negation

The treatment of inequality, universal quantification,
implication, and logical equivalence as abbreviations
can cause the introduction of double negations
which could make otherwise well-formed code mode-incorrect.
To avoid this problem, the language specifies that
after syntax analysis and implicit quantification,
and before mode analysis is performed,
the implementation must delete any double negations
and must replace any negations of conjunctions of negations
with disjunctions.
(Both of these transformations preserve
the logical meaning and type-correctness of the code,
and they preserve or improve mode-correctness:
they never transform code fragments that would be well-moded
into ones that would be ill-moded.)

@node Types
@chapter Types

The type system is based on many-sorted logic,
and supports polymorphism,
type classes (@pxref{Type classes}),
and existentially quantified types (@pxref{Existential types}).

@menu
* Builtin types::
* User-defined types::
* Predicate and function type declarations::
* Field access functions::
* The standard ordering::
@end menu

@node Builtin types
@section Builtin types

This section describes the special types
that are built into the Mercury implementation,
or are defined in the standard library.

@menu
* Primitive types::
* Other builtin types::
@end menu

@node Primitive types
@subsection Primitive types

There is a special syntax
for constants of all primitive types except @code{char}.
(For @code{char}, the standard syntax suffixes.)

@menu
* Signed integer types::
* Unsigned integer types::
* Floating-point type::
* Character type::
* String type::
@end menu

@node Signed integer types
@subsubsection Signed integer types
There are five primitive signed integer types:
@code{int}, @code{int8}, @code{int16}, @code{int32} and @code{int64}.

Except for @code{int},
the width in bits of each of these is given by the numeric suffix in its name.

The width in bits of @code{int} is implementation defined,
but must be at least 32-bits.

All signed integer types use two's-complement representation.
Their width must be equal to the width of the corresponding unsigned type.

Values of the type @code{int8} must be in the range
@math{-128} (@math{-(2^{8 - 1})}) to @math{127} (@math{2^{8 - 1} - 1}),
both inclusive.

Values of the type @code{int16} must be in the range
@math{-32768} (@math{-(2^{16 - 1})}) to @math{32767} (@math{2^{16 - 1} - 1}),
both inclusive.

Values of the type @code{int32} must be in the range
@math{-2147483648} (@math{-(2^{32 - 1})})
to @math{2147483647} (@math{2^{32 - 1} - 1}),
both inclusive.

Values of the type @code{int64} must be in the range
@math{-9223372036854775808} (@math{-(2^{64 - 1})})
to @math{9223372036854775807} (@math{2^{64 - 1} - 1}),
both inclusive.

Values of the type @code{int} must be in the range
to @math{-(2^{N - 1})} to @math{2^{N - 1} - 1},
both inclusive;
@math{N} being the width of @code{int} in bits.

@node Unsigned integer types
@subsubsection Unsigned integer types
There are five primitive unsigned integer types:
@code{uint}, @code{uint8}, @code{uint16}, @code{uint32} and @code{uint64}.

Except for @code{uint},
the width in bits of each of these is given by the numeric suffix in its name.

The width in bits of @code{uint} is implementation defined,
but must be at least 32-bits.
It must be equal to the width of the type @code{int}.

Values of the type @code{uint8} must be in the range
@math{0} (@math{2^0 - 1}) to @math{255} (@math{2^8 - 1}),
both inclusive.

Values of the type @code{uint16} must be in the range
@math{0} (@math{2^0- 1}) to @math{65535} (@math{2^16 - 1}),
both inclusive.

Values of the type @code{uint32} must be in the range
@math{0} (@math{2^0 - 1}) to @math{4294967295} (@math{2^32 - 1}),
both inclusive.

Values of the type @code{uint64} must be in the range
@math{0} (@math{2^0 - 1}) to @math{18446744073709551615} (@math{2^64 - 1}),
both inclusive.

Values of the type @math{uint} must be in the range
@math{0} (@math{2^0 - 1}) to @math{2^N - 1},
both inclusive;
@math{N} being the width of @code{uint} in bits.

@node Floating-point type
@subsubsection Floating-point type
There is one floating-point type: @code{float}.

It is represented using either the 32-bit single-precision IEEE 754 format
or the 64-bit double-precision IEEE 754 format.

The choice between the two formats is implementation dependent.

In the Melbourne Mercury implementation,
@code{float}s are represented
using the 32-bit single-precision IEEE 754 format
in grades that have @code{.spf} grade component,
and using the 64-bit double-precision IEEE 754 format in every other grade.

@node Character type
@subsubsection Character type
There is one character type: @code{char}.

Values of this type represent Unicode code points.

@node String type
@subsubsection String type
There is one string type: @code{string}.

A string is a sequence of characters encoded
using either the UTF-8 or UTF-16 encoding of Unicode.

The choice between the two encodings is implementation dependent.

In the Melbourne Mercury implementation,
@code{string}s are represented
using UTF-8 when generating code for C or Erlang,
and using UTF-16 when generating code for C# or Java.

@node Other builtin types
@subsection Other builtin types

@menu
* Predicate and function types::
* Tuple types::
* The universal type::
* The ``state-of-the-world'' type::
@end menu

@node Predicate and function types
@subsubsection Predicate and function types
The predicate types are
@code{pred}, @code{pred(T)}, @code{pred(T1, T2)}, @dots{}

@noindent
The function types are
@code{(func) = T}, @code{func(T1) = T}, @code{func(T1, T2) = T}, @dots{}

Higher-order predicate and function types
are used to pass closures to other predicates and functions.
@xref{Higher-order}.

@node Tuple types
@subsubsection Tuple types
The tuple types are @code{@{@}}, @code{@{T@}}, @code{@{T1, T2@}}, @dots{}

A tuple type is equivalent to a discriminated union type
(@pxref{Discriminated unions}) with declaration
@example
 :- type @{Arg1, Arg2, @dots{}, ArgN@}
         --->    @{ @{Arg1, Arg2, @dots{}, ArgN@} @}.
@end example

@node The universal type
@subsubsection The universal type
The type @code{univ} is defined in the standard library module @code{univ},
along with the predicates @code{type_to_univ/2} and @code{univ_to_type/2}.
With those predicates, values of any type can be converted to the universal
type and back again.
The universal type is useful for situations
where you need heterogeneous collections.

@node The ``state-of-the-world'' type
@subsubsection The ``state-of-the-world'' type
The type @code{io.state} is defined in the standard library module @code{io},
and represents the state of the world.
Predicates which perform I/O
are passed the only reference to the current state of the world,
and produce a unique reference to the new state of the world.
In this way, we can give a declarative semantics to code that performs I/O.

@node User-defined types
@section User-defined types

New types can be introduced with @samp{:- type} declarations.
There are several categories of derived types:

@menu
* Discriminated unions::
* Equivalence types::
* Abstract types::
@end menu

@node Discriminated unions
@subsection Discriminated unions

These encompass both enumeration and record types in other languages.
A derived type is defined using @samp{:- type @var{type} ---> @var{body}}.
(Note there are @emph{three} dashes in that arrow.
It should not be confused with the two-dash arrow used for DCGs
or the one-dash arrow used for if-then-else.)
If the @var{type} term is a functor of arity zero
(i.e.@: one having zero arguments),
it names a monomorphic type.
Otherwise, it names a polymorphic type;
the arguments of the functor must be distinct type variables.
The @var{body} term is defined as
a sequence of constructor definitions separated by semi-colons.

Ordinarily, each constructor definition
must be a functor whose arguments (if any) are types.
Ordinary discriminated union definitions must be @dfn{transparent}:
all type variables occurring in the @var{body}
must also occur in the @var{type}.

However, constructor definitions can optionally be existentially typed.
In that case, the functor will be preceded by an existential type quantifier
and can optionally be followed by an existential type class constraint.
For details, see @ref{Existential types}.
Existentially typed discriminated union definitions need not be transparent.

The arguments of constructor definitions may be labelled.
These labels cause the compiler to generate functions
which can be used to conveniently select and update fields of a term
in a manner independent of the definition of the type
(@pxref{Field access functions}).
A labelled argument has the form @w{@code{@var{fieldname} :: @var{Type}}}.
It is an error for two fields in the same module to have the same label.

Here are some examples of discriminated union definitions:

@example
:- type fruit
        --->    apple
        ;       orange
        ;       banana
        ;       pear.

:- type strange
        --->    foo(int)
        ;       bar(string).

:- type employee
        --->    employee(
                       name        :: string,
                       age         :: int,
                       department  :: string
                ).

:- type tree
        --->    empty
        ;       leaf(int)
        ;       branch(tree, tree).

:- type list(T)
        --->    []
        ;       [T | list(T)].

:- type pair(T1, T2)
        --->    T1 - T2.
@end example

If the body of a discriminated union type definition
contains a term whose top-level functor is @code{';'/2},
the semi-colon is normally assumed to be a separator.
This makes it difficult to define a type
whose constructors include @code{';'/2}.
To allow this, curly braces can be used to quote the semi-colon.
It is then also necessary to quote curly braces.
The following example illustrates this:

@example
:- type tricky
        --->    @{ int ; int @}
        ;       @{ @{ int @} @}.
@end example

This defines a type with two constructors,
@code{';'/2} and @code{'@{@}'/1}, whose argument types are all @code{int}.
We recommend against using constructors named @code{'@{@}'}
because of the possibility of confusion with the builtin tuple types.

Each discriminated union type definition introduces a distinct type.
Mercury considers two discriminated union types that have the same bodies
to be distinct types (name equivalence).
Having two different definitions of a type
with the same name and arity in the same module is an error.

Constructors may be overloaded among different types:
there may be any number of constructors with a given name and arity,
so long as they all have different types.
However, there must not be more than one constructor
with the same name, arity, and result type in the same module.
(There is no particularly good reason for this restriction;
in the future we may allow several such functors
as long as they have different argument types.)
Note that excessive overloading of constructors
can slow down type checking
and can make the program confusing for human readers,
so overloading should not be over-used.

@c XXX The `where direct_arg' attribute is not documented because it requires
@c     the user has a detailed understanding of the type representation, and
@c     is very implementation specific. The following is for implementors.

@c Discriminated union type definitions may be followed by a
@c @samp{direct_arg} attribute of the following form:
@c
@c @example
@c where direct_arg is @var{ctors}
@c @end example
@c
@c @noindent
@c where @var{ctors} is a list of @var{functor-name} / @var{functor-arity}.
@c The functor arities must always be one.
@c
@c The attribute notifies importing modules that each of the functors
@c listed is to be represented as a tagged pointer to its argument. The
@c argument type must be known, when compiling the module that the type is
@c defined in, to not require the use of the tag bits. The compiler will
@c emit an error message otherwise.  The compiler will silently ignore
@c functors which require a secondary tag.
@c
@c The optimised type representation is usually only applied if the
@c argument type is defined in the interface section of the same module.
@c This attribute allows the programmer to also apply it when the argument
@c type is known to the defining module, but not necessarily modules which
@c import the top-level type.
@c
@c Ideally, the @samp{direct_arg} attribute would be automatically
@c generated when making an interface file, so the user would never need to
@c write it manually.  At this time, the compiler does not have enough
@c information when making interface files.

Note that user defined types may not have names that have meanings in Mercury.
(Most of these are documented in later sections.)

The list of reserved type names is
@example
int
int8
int16
int32
int64
uint
uint8
uint16
uint32
uint64
float
character
string
@{@}
=
pred
func
pure
semipure
impure
''
@end example

@node Equivalence types
@subsection Equivalence types

These are type abbreviations.
They are defined using @samp{==} as follows.
They may be polymorphic.

@example
:- type money == int.
:- type assoc_list(KeyType, ValueType)
        == list(pair(KeyType, ValueType)).
@end example

Equivalence type definitions must be transparent.
Unlike discriminated union type definitions,
equivalence type definitions must not be cyclic;
that is, the type on the left hand side of the @samp{==}
(@samp{assoc_list} and @samp{money} in the examples above)
must not occur on the right hand side of the @samp{==}.

Mercury treats an equivalence type
as an abbreviation for the type on the right hand side of the definition;
the two are equivalent in all respects
in scopes where the equivalence type is visible.

@node Abstract types
@subsection Abstract types

These are types whose implementation is hidden.
The type declarations

@example
:- type t1.
:- type t2(T1, T2).
@end example

@noindent
declare types @code{t1/0} and @code{t2/2} to be abstract types.
Such declarations are only useful in the interface section of a module.
This means that the type names will be exported,
but the constructors (functors) for these types will not be exported.
The implementation section of a module
must give a definition for all of the abstract types
named in the interface section of the module.
Abstract types may be defined as either discriminated union types
or as equivalence types.

@node Predicate and function type declarations
@section Predicate and function type declarations

The argument types of each predicate
must be explicitly declared with a @samp{:- pred} declaration.
The argument types and return type of each function must be
explicitly declared with a @samp{:- func} declaration.
For example:

@example
:- pred is_all_uppercase(string).

:- func strlen(string) = int.
@end example

Predicates and functions can be polymorphic;
that is, their declarations can include type variables.
For example:

@example
:- pred member(T, list(T)).

:- func length(list(T)) = int.
@end example

A predicate or function can be declared
to have a given higher-order type (@pxref{Higher-order})
by using an explicit type qualification in the type declaration.
This is useful where several predicates or functions
need to have the same type signature,
which often occurs for type class method implementations
(@pxref{Type classes}),
and for predicates to be passed as higher-order terms.

For example,

@example
:- type foldl_pred(T, U) == pred(T, U, U).
:- type foldl_func(T, U) == (func(T, U) = U).

:- pred p(int) : foldl_pred(T, U).
:- func f(int) : foldl_func(T, U).
@end example

@noindent
is equivalent to

@example
:- pred p(int, T, U, U).
:- pred f(int, T, U) = U.
@end example

Type variables in predicate and function declarations
are implicitly universally quantified by default;
that is, the predicate or function may be called with arguments
and (in the case of functions) return value
whose actual types are any instance of the types specified in the declaration.
For example, the function @samp{length/1} declared above
could be called with the argument having type
@samp{list(int)}, or @samp{list(float)}, or @samp{list(list(int))}, etc.

Type variables in predicate and function declarations can
also be existentially quantified; this is discussed in
@ref{Existential types}.

There must only be one predicate with a given name and arity in each module,
and only one function with a given name and arity in each module.
It is an error to declare the same predicate or function twice.

There must be at least one clause defined
for each declared predicate or function,
except for those defined using the foreign language interface
(@pxref{Foreign language interface}).
However, Mercury implementations are permitted to provide a method
of processing Mercury programs in which such errors are not reported
until and unless the predicate or function is actually called.
(The University of Melbourne Mercury implementation provides this
with its @samp{--allow-stubs} option.
This can be useful during program development,
since it allows you to execute parts of a program
while the program's implementation is still incomplete.)

Note that a predicate defined using DCG notation (@pxref{DCG-rules})
will appear to be defined with two fewer arguments than it is declared with.
It will also appear to be called with two fewer arguments
when called from predicates defined using DCG notation.
However, when called from an ordinary predicate or function,
it must have all the arguments it was declared with.

The compiler infers the types of data-terms,
and in particular the types of variables
and overloaded constructors, functions, and predicates.
A @dfn{type assignment} is an assignment of a type to every variable,
and of a particular constructor, function, or predicate
to every name in a clause.
A type assignment is @dfn{valid} if it satisfies the following conditions.

Each constructor in a clause
must have been declared in at least one visible type declaration.
The type assigned to each constructor term
must match one of the type declarations for that constructor,
and the types assigned to the arguments of that constructor
must match the argument types specified in that type declaration.

The type assigned to each function call term
must match the return type of one of the @samp{:- func} declarations
for that function, and the types assigned to the arguments of that function
must match the argument types specified in that type declaration.

The type assigned to each predicate argument must match
the type specified in one of the @samp{:- pred} declarations
for that predicate.
The type assigned to each head argument in a predicate clause
must exactly match the argument type specified
in the corresponding @samp{:- pred} declaration.

The type assigned to each head argument in a function clause
must exactly match the argument type
specified in the corresponding @samp{:- func} declaration,
and the type assigned to the result term in a function clause
must exactly match the result type specified
in the corresponding @samp{:- func} declaration.

The type assigned to each data-term with an explicit type qualification
(@pxref{Explicit type qualification})
must match the type specified by the type qualification
expression@footnote{The type of an explicitly
type qualified term may be an instance of the type specified by the
qualifier. This allows explicit type qualifications to constrain the
types of two data-terms to be identical, without knowing the exact types
of the data-terms. It also allows type qualifications to refer to the
types of the results of existentially typed predicates or functions.}.

(Here ``match'' means to be an instance of,
i.e.@: to be identical to for some substitution of the type parameters,
and ``exactly match'' means to be identical up to renaming of type parameters.)

One type assignment @var{A} is said to be
@dfn{more general} than another type assignment @var{B}
if there is a binding of the type parameters in @var{A}
that makes it identical (up to renaming of parameters) to @var{B}.
If there is more than one valid type assignment,
the compiler must choose the most general one.
If there are two valid type assignments which are not identical up to renaming
and neither of which is more general than the other,
then there is a type ambiguity, and compiler must report an error.
A clause is @dfn{type-correct}
if there is a unique (up to renaming) most general valid type assignment.
Every clause in a Mercury program must be type-correct.

@node Field access functions
@section Field access functions

Fields of constructors of discriminated union types may be labelled
(@pxref{Discriminated unions}).
These labels cause the compiler to generate function
which can be used to select and update fields of a term
in a manner independent of the definition of the type.

The Mercury language includes syntactic sugar to make it more convenient
to select and update fields inside nested terms (@pxref{Record syntax})
and to select and update fields of the DCG arguments of a clause
(@pxref{DCG-goals}).

@menu
* Field selection::
* Field update::
* User-supplied field access function declarations::
* Field access examples::
@end menu

@node Field selection
@subsection Field selection

@example
@var{field}(@var{Term})
@end example

Each field label @samp{@var{field}} in a constructor
causes generation of a field selection function @samp{@var{field}/1},
which takes a data-term of the same type as the constructor
and returns the value of the labelled field,
failing if the top-level constructor of the argument
is not the constructor containing the field.

If the declaration of the field is in the interface section of the module,
the corresponding field selection function is also exported from the module.

By default, this function has no declared modes ---
the modes are inferred at each call to the function.
However, the type and modes of this function may be explicitly declared,
in which case it will have only the declared modes.

To create a higher-order term from a field selection function,
an explicit lambda expression must be used,
unless a single mode declaration is supplied for the field selection function.

@node Field update
@subsection Field update

@example
'@var{field} :='(@var{Term}, @var{ValueTerm})
@end example

Each field label @samp{@var{field}} in a constructor
causes generation of a field update function @samp{'@var{field} :='/2}.
The first argument of this function
is a data-term of the same type as the constructor.
The second argument
is a data-term of the same type as the labelled field.
The return value is a copy of the first argument
with the value of the labelled field replaced by the second argument.
@samp{'@var{field} :='/2} fails
if the top-level constructor of the first argument
is not the constructor containing the labelled field.

If the declaration of the field is in the interface section of the module,
the corresponding field update function is also exported from the module.

By default, this function has no declared modes ---
the modes are inferred at each call to the function.
However, the type and modes of this function may be explicitly declared,
in which case it will have only the declared modes.

To create a higher-order term from a field update function,
an explicit lambda expression must be used,
unless a single mode declaration is supplied for the field update function.

Some fields cannot be updated using field update functions.
For the constructor @samp{unsettable/2} below,
neither field may be updated
because the resulting term would not be well-typed.
A future release may allow multiple fields to be updated
by a single expression to avoid this problem.

@example
:- type unsettable
        --->    some [T] unsettable(
                    unsettable1 :: T,
                    unsettable2 :: T
                ).
@end example

@node User-supplied field access function declarations
@subsection User-supplied field access function declarations

Type and mode declarations for compiler-generated field access functions
for fields of constructors local to a module
may be placed in the interface section of the module.
This allows the implementation of a type to be hidden
while still allowing client modules to use record syntax
to manipulate values of the type.
Supplying a type declaration and a single mode declaration
also allows higher-order terms to be created
from a field access function without using explicit lambda expressions.

Declarations for field access functions for fields occurring in the interface
section of a module must also occur in the interface section.

Declarations and clauses for field access functions can also be supplied
for fields which are not a part of any type.
This is useful when the data structures of a program change
so that a value which was previously stored as part of a type
is now computed each time it is requested.
It also allows record syntax to be used for type class methods.

User-declared field access functions may take extra arguments.
For example, the Mercury standard library module @code{map}
contains the following functions:
@example
:- func elem(K, map(K, V)) = V is semidet.
:- func 'elem :='(K, map(K, V), V) = map(K, V).
@end example
Field access syntax may be used
at the top-level of @code{func} and @code{mode} declarations
and in the head of clauses.
For instance:
@example
:- func map(K, V) ^ elem(K) = V.
:- mode in        ^ in      = out is semidet.
Map ^ elem(Key) = map.lookup(Map, Key).

:- func (map(K, V) ^ elem(K) := V)  = V.
:- mode (in        ^ in      := in) = out is semidet.
(Map ^ elem(Key) := Value) = map.set(Map, Key, Value).
@end example

The Mercury standard library modules @code{array} and @code{bt_array}
define similar functions.

@node Field access examples
@subsection Field access examples

The examples make use of the following type declarations:

@example
:- type type1
        --->    type1(
                    field1 :: type2,
                    field2 :: string
                ).

:- type type2
        --->    type2(
                    field3 :: int,
                    field4 :: int
                ).
@end example

The compiler generates some field access functions for @samp{field1}.
The functions generated for the other fields are similar.

@example
:- func type1 ^ field1 = type2.
type1(Field1, _) ^ field1 = Field1.

:- func (type1 ^ field1 := type2) = type1.
(type1(_, Field2) ^ field1 := Field1) = type1(Field1, Field2).
@end example

Using these functions and the syntactic sugar described in @ref{Record syntax},
programmers can write code such as

@example
:- func type1 ^ increment_field3 = type1.

Term0 ^ increment_field3 =
    Term0 ^ field1 ^ field3 := Term0 ^ field1 ^ field3 + 1.
@end example

The compiler expands this into

@example
increment_field3(Term0) = Term :-
    OldField3 = field3(field1(Term0)),
    OldField1 = field1(Term0),
    NewField1 = 'field3 :='(OldField1, OldField3 + 1),
    Term = 'field1 :='(Term0, NewField1).
@end example

The field access functions defined
in the Mercury standard library module @samp{map}
can be used as follows:

@example
:- func update_field_in_map(map(int, type1), int, string)
    = map(int, type1) is semidet.

update_field_in_map(Map, Index, Value) =
    Map ^ elem(Index) ^ field2 := Value.
@end example

@node The standard ordering
@section The standard ordering

For (almost) every Mercury type there exists a standard ordering;
any two values of the same type can be compared under this ordering
by using the @code{builtin.compare/3} predicate.
The ordering is total, meaning that the corresponding binary relations
are reflexive, transitive and anti-symmetric.
The one exception is higher-order types,
which cannot be unified or compared;
any attempt to do so will raise an exception.

The existence of this ordering makes it possible to implement
generic data structures such as sets and maps,
without needing to know the specifics of the ordering.
Furthermore, different platforms often have their own natural orderings
which are not necessarily consistent with each other.
As such, the standard ordering for most types is not fully defined.

For the primitive integer types,
the standard ordering is the usual numerical ordering.
Implementations should reject code containing overflowing integer literals.

For the primitive type @code{float},
the standard ordering approximates the usual numerical ordering.
If the result of @code{builtin.compare/3} is @code{(<)} or @code{(>)}
then this relation holds in the numerical ordering,
but this is not necessarily the case for @code{(=)} due to lack of precision.
In the standard ordering, ``negative'' and ``positive'' zero values are equal.
Implementations should replace overflowing literals
with the infinity of the same sign;
in the standard ordering positive infinity is greater than all finite values
and negative infinity is less than all finite values.
Implementations must throw an exception when comparing
a ``not a number'' (NaN) value.

For the primitive type @code{char},
the standard ordering is
the numerical ordering of the Unicode code point values.

For the primitive type @code{string},
the standard ordering is implementation dependent.
The current implementation performs string comparison using
the C @code{strcmp()} function,
the Java @code{String.compareTo()} method,
the C# @code{System.String.CompareOrdinal()} method, and
the Erlang term comparison operators,
when compiling to C, Java, C# and Erlang respectively.

For tuple types, corresponding arguments are compared,
with the first argument being the most significant,
then the second, and so on.

For discriminated union types,
if both values have the same principal constructor
then corresponding arguments are compared in order,
with the first argument being the most significant,
then the second, and so on.
If the values have different principal constructors,
then the value whose principal constructor
is listed first in the definition of the type
will compare as less than the other value.
There is one exception from this rule:
in types that are subject to a @code{foreign_enum} pragma,
the outcomes of comparisons are decided
by user's chosen foreign language representations,
using the rules of the foreign language.

@node Modes
@chapter Modes

@menu
* Insts modes and mode definitions::
* Predicate and function mode declarations::
* Constrained polymorphic modes::
* Different clauses for different modes::
@end menu

@node Insts modes and mode definitions
@section Insts, modes, and mode definitions

The @dfn{mode} of a predicate, or function, is a mapping
from the initial state of instantiation of the arguments of the predicate,
or the arguments and result of a function,
to their final state of instantiation.
To describe states of instantiation,
we use information provided by the type system.
Types can be viewed as regular trees with two kinds of nodes:
or-nodes representing types
and and-nodes representing constructors.
The children of an or-node are the constructors
that can be used to construct terms of that type;
the children of an and-node are the types
of the arguments of the constructors.
We attach mode information to the or-nodes of type trees.

An @dfn{instantiatedness tree}
is an assignment of an @dfn{instantiatedness}
--- either @dfn{free} or @dfn{bound} ---
to each or-node of a type tree,
with the constraint that all descendants of a free node must be free.

A term is @dfn{approximated by} an instantiatedness tree
if for every node in the instantiatedness tree,

@itemize @bullet
@item
if the node is ``free'',
then the corresponding node in the term (if any)
is a free variable that does not share with any other variable
(we call such variables @dfn{distinct});

@item
if the node is ``bound'',
then the corresponding node in the term (if any)
is a function symbol.

@end itemize

When an instantiatedness tree tells us that a variable is bound,
there may be several alternative function symbols to which it could be bound.
The instantiatedness tree does not tell us which of these it is bound to;
instead for each possible function symbol it tells us exactly
which arguments of the function symbol will be free and which will be bound.
The same principle applies recursively to these bound arguments.

Mercury's mode system allows users
to declare names for instantiatedness trees using declarations such as

@example
:- inst listskel == bound([] ; [free | listskel]).
@end example

This instantiatedness tree describes lists
whose skeleton is known but whose elements are distinct variables.
As such, it approximates the term @code{[A,B]}
but not the term @code{[H|T]} (only part of the skeleton is known),
the term @code{[A,2]} (not all elements are variables),
or the term @code{[A,A]} (the elements are not distinct variables).

As a shorthand, the mode system provides @code{free} and @code{ground}
as names for instantiatedness trees
all of whose nodes are free and bound respectively
(with the exception of solver type values
which may be semantically ground,
but be defined in terms of non-ground solver type values;
see @ref{Solver types} for more detail).
The shape of these trees is determined
by the type of the variable to which they apply.

A more concise, alternative syntax exists
for @code{bound} instantiatedness trees:

@example
:- inst maybeskel
    --->    no
    ;       yes(free).
@end example

@noindent
which is equivalent to writing

@example
:- inst maybeskel == bound(no ; yes(free)).
@end example

You can specify what type (actually what type constructor)
an inst is intended to be used on
by adding @code{for}, followed by the name and arity of that type constructor,
after the name of the inst, like this:
@example
:- inst maybeskel for maybe/1
    --->    no
    ;       yes(free).
@end example

@noindent
This can be useful documentation,
even though the compiler does not (yet) prevent
the use of such insts on values of other types.

As execution proceeds, variables may become more instantiated.
A @dfn{mode mapping} is a mapping
from an initial instantiatedness tree to a final instantiatedness tree,
with the constraint that no node of the type tree
is transformed from bound to free.
Mercury allows the user to specify mode mappings directly
by expressions such as @code{inst1 >> inst2},
or to give them a name using declarations such as

@example
:- mode m == inst1 >> inst2.
@end example

Two standard shorthand modes are provided,
corresponding to the standard notions of inputs and outputs:

@example
:- mode in == ground >> ground.
:- mode out == free >> ground.
@end example

Though we do not recommend this,
Prolog fans who want to use the symbols @samp{+} and @samp{-}
can do so by simply defining them using a mode declaration:

@example
:- mode (+) == in.
:- mode (-) == out.
@end example

These two modes are enough for most functions and predicates.
Nevertheless, Mercury's mode system is sufficiently
expressive to handle more complex data-flow patterns,
including those involving partially instantiated data structures i.e.@: data
structures with ``free'' @emph{holes} in them.
(In the current implementation,
partially instantiated data structures are unsupported
due to a lack of alias tracking in the mode system.
For more information,
please see the @file{LIMITATIONS} file distributed with Mercury.)

For example, consider an interface to a database
that associates data with keys,
and provides read and write access to the items it stores.
To represent accesses to the database over a network,
you would need declarations such as

@example
:- type operation
     --->   lookup(key, data)
     ;      set(key, data).
:- inst request for operation/0
    --->    lookup(ground, free)
    ;       set(ground, ground).
:- mode create_request == free >> request.
:- mode satisfy_request == request >> ground.
@end example

@samp{inst} and @samp{mode} declarations can be parametric.
For example, the following declaration

@example
:- inst listskel(Inst) for list/1
    --->    []
    ;       [Inst | listskel(Inst)].
@end example

@noindent
defines the inst @samp{listskel(Inst)} to be a list skeleton
whose elements have inst @code{Inst};
you can then use insts such as @samp{listskel(listskel(free))},
which represents the instantiation state of a list of lists of free variables.
The standard library provides the parametric modes

@example
:- mode in(Inst) == Inst >> Inst.
:- mode out(Inst) == free >> Inst.
@end example

@noindent
so that for example the mode @samp{create_request} defined above
could have be defined as

@example
:- mode create_request == out(request).
@end example

There must not be more than one inst definition
with the same name and arity in the same module.
Similarly, there must not be more than one mode definition
with the same name and arity in the same module.

Note that user defined insts and modes may not have names
that have meanings in Mercury.
(Most of these are documented in later sections.)

The list of reserved inst names is
@example
=<
any
bound
bound_unique
clobbered
clobbered_any
free
ground
is
mostly_clobbered
mostly_unique
mostly_unique_any
not_reached
unique
unique_any
@end example

The list of reserved mode names is
@example
=
>>
any_func
any_pred
func
is
pred
@end example

@node Predicate and function mode declarations
@section Predicate and function mode declarations

A @dfn{predicate mode declaration}
assigns a mode mapping to each argument of a predicate.
A @dfn{function mode declaration}
assigns a mode mapping to each argument of a function,
and a mode mapping to the function result.
Each mode of a predicate or function is called a @dfn{procedure}.
For example, given the mode names defined by

@example
:- mode out_listskel == free >> listskel.
:- mode in_listskel == listskel >> listskel.
@end example

@noindent
the (type and) mode declarations
of the function @samp{length} and predicate @samp{append} are as follows:

@example
:- func length(list(T)) = int.
:- mode length(in_listskel) = out.
:- mode length(out_listskel) = in.

:- pred append(list(T), list(T), list(T)).
:- mode append(in, in, out).
:- mode append(out, out, in).
@end example

Note that functions may have more than one mode, just like predicates;
functions can be reversible.

Alternately, the mode declarations for @samp{length}
could use the standard library modes @samp{in/1} and @samp{out/1}:

@example
:- func length(list(T)) = int.
:- mode length(in(listskel)) = out.
:- mode length(out(listskel)) = in.
@end example

As for type declarations,
a predicate or function can be defined
to have a given higher-order inst (@pxref{Higher-order insts and modes})
by using @code{`with_inst`} in the mode declaration.

For example,

@example
:- inst foldl_pred == (pred(in, in, out) is det).
:- inst foldl_func == (func(in, in) = out is det).

:- mode p(in) `with_inst` foldl_pred.
:- mode f(in) `with_inst` foldl_func.
@end example

@noindent
is equivalent to

@example
:- mode p(in, in, in, out) is det.
:- mode f(in, in, in) = out is det.
@end example

@noindent
(@samp{is det} is explained in @ref{Determinism}.)

If a predicate or function has only one mode,
the @samp{pred} and @samp{mode} declaration can be combined:

@example
:- func length(list(T)::in) = (int::out).
:- pred append(list(T)::in, list(T)::in, list(T)::out).

:- pred p `with_type` foldl_pred(T, U) `with_inst` foldl_pred.
@end example

It is an error for a predicate or function
whose @samp{pred} and @samp{mode} declarations are so combined
to have any other separate @samp{mode} declarations.

If there is no mode declaration for a function,
the compiler assumes a default mode for the function
in which all the arguments have mode @code{in}
and the result of the function has mode @code{out}.
(However, there is no requirement that a function have such a mode;
if there is any explicit mode declaration, it overrides the default.)

If a predicate or function type declaration
occurs in the interface section of a module,
then all mode declarations for that predicate or function
must occur in the interface section of the @emph{same} module.
Likewise, if a predicate or function type declaration
occurs in the implementation section of a module,
then all mode declarations for that predicate or function
must occur in the implementation section of the @emph{same} module.
Therefore, is an error
for a predicate or function to have mode declarations
in both the interface and implementation sections of a module.

A function or predicate mode declaration is an assertion by the programmer
that for all possible argument terms and (if applicable) result term
for the function or predicate
that are approximated (in our technical sense)
by the initial instantiatedness trees of the mode declaration
and all of whose free variables are distinct,
if the function or predicate succeeds, then
the resulting binding of those argument terms and (if applicable)
result term will in turn be approximated
by the final instantiatedness trees of the mode declaration,
with all free variables again being distinct.
We refer to such assertions as @dfn{mode declaration constraints}.
These assertions are checked by the compiler, which rejects programs
if it cannot prove that their mode declaration constraints are satisfied.

Note that with the usual definition of @samp{append}, the mode

@example
:- mode append(in_listskel, in_listskel, out_listskel).
@end example

@noindent
would not be allowed,
since it would create aliasing between the different arguments ---
on success of the predicate, the list elements would be free variables,
but they would not be distinct.

In Mercury it is always possible to call a procedure with an argument
that is more bound than the initial inst specified for that argument
in the procedure's mode declaration.
In such cases, the compiler will insert additional unifications
to ensure that the argument actually passed to the procedure
will have the inst specified.
For example, if the predicate @code{p/1} has mode @samp{p(out)},
you can still call @samp{p(X)} if @code{X} is ground.
The compiler will transform this code to @samp{p(Y), X = Y}
where @code{Y} is a fresh variable.
It is almost as if the predicate @code{p/1} has another mode @samp{p(in)};
we call such modes ``implied modes''.

To make this concept precise, we introduce the following definition.
A term @dfn{satisfies} an instantiatedness tree
if for every node in the instantiatedness tree,

@itemize @bullet
@item
if the node is ``free'',
then the corresponding node in the term (if any)
is either a distinct free variable,
or a function symbol.

@item
if the node is ``bound'',
then the corresponding node in the term (if any)
is a function symbol.

@end itemize

The @dfn{mode set} for a predicate or function
is the set of mode declarations for the predicate or function.
A mode set is an assertion by the programmer
that the predicate should only be called with argument terms
that satisfy the initial instantiatedness trees
of one of the mode declarations in the set
(i.e.@: the specified modes and the modes they imply
are the only allowed modes for this predicate or function).
We refer to the assertion associated with a mode set
as the @dfn{mode set constraint};
these are also checked by the compiler.

A predicate or function @var{p} is
@dfn{well-moded with respect to a given mode declaration}
if given that the predicates and functions called by @var{p}
all satisfy their mode declaration constraints,
there exists an ordering of the conjuncts in each conjunction
in the clauses of @var{p} such that

@itemize @bullet
@item
@var{p} satisfies its mode declaration constraint, and
@item
@var{p} satisfies the mode set constraint of all of the predicates and
functions it calls
@end itemize

We say that a predicate or function is well-moded
if it is well-moded with respect to
all the mode declarations in its mode set,
and we say that a program is well-moded
if all its predicates and functions are well-moded.

The mode analysis algorithm checks one procedure at a time.
It abstractly interprets the definition of the predicate or function,
keeping track of the instantiatedness of each variable,
and selecting a mode for each call and unification in the definition.
To ensure that
the mode set constraints of called predicates and functions are satisfied,
the compiler may reorder the elements of conjunctions;
it reports an error if no satisfactory order exists.
Finally it checks that
the resulting instantiatedness of the procedure's arguments
is the same as the one given by the procedure's declaration.

The mode analysis algorithm annotates each call with the mode used.

@node Constrained polymorphic modes
@section Constrained polymorphic modes

Mode declarations for predicates and functions may also have inst parameters.
However, such parameters must be constrained
to be @emph{compatible} with some other inst.
In a predicate or function mode declaration,
an inst of the form @samp{@var{InstParam} =< @var{Inst}},
where @var{InstParam} is a variable and @var{Inst} is an inst,
states that
@var{InstParam} is constrained to be @emph{compatible} with @var{Inst},
that is,
@var{InstParam} represents some inst
that can be used anywhere where @var{Inst} is required.
If an inst parameter occurs more than once in a declaration,
it must have the same constraint on each occurrence.

For example, in the mode declaration
@example
:- mode append(in(list_skel(I =< ground)), in(list_skel(I =< ground)),
    out(list_skel(I =< ground))) is det.
@end example
@noindent
@code{I} is an inst parameter which is constrained to be ground.
If @samp{append} is called with the first two arguments
having an inst of, say, @samp{list_skel(bound(f))},
then after @samp{append} returns,
all three arguments will have inst @samp{list_skel(bound(f))}.
If the mode of append had been simply
@example
:- mode append(in(list_skel(ground)), in(list_skel(ground)),
    out(list_skel(ground))) is det.
@end example
@noindent
then we would only have been able to infer an inst of @samp{list_skel(ground)}
for the third argument, not the more specific inst.

Note that attempting to call @samp{append}
when the first two arguments do not have ground insts
(e.g.@: @samp{list_skel(bound(g(free)))})
is a mode error because it violates the constraint on the inst parameter.

To avoid having to repeat a constraint everywhere that an inst parameter occurs,
it is possible to list the constraints after the rest of the mode declaration,
following a @samp{<=}.
E.g.@: the above example could have been written as
@example
:- (mode append(in(list_skel(I)), in(list_skel(I)),
    out(list_skel(I))) is det) <= I =< ground.
@end example

Note that in the current Mercury implementation
this syntax requires parentheses
around the @samp{mode(@dots{}) is @var{Det}} part of the declaration.

Also, if the constraint on an inst parameter is @samp{ground}
then it is not necessary to give the constraint in the declaration.
The example can be further shortened to
@example
:- mode append(in(list_skel(I)), in(list_skel(I)), out(list_skel(I)))
    is det.
@end example

Constrained polymorphic modes are particularly useful
when passing objects with higher-order types to polymorphic predicates,
since they allow the higher-order mode information to be retained
(@pxref{Higher-order}).

@node Different clauses for different modes
@section Different clauses for different modes

Because the compiler automatically reorders conjunctions to satisfy the modes,
it is often possible for a single clause to satisfy different modes.
However, occasionally reordering of conjunctions is not sufficient;
you may want to write different code for different modes.

For example, the usual code for list append

@example
append([], Ys, Ys).
append([X|Xs], Ys, [X|Zs]) :-
    append(Xs, Ys, Zs).
@end example

@noindent
works fine in most modes,
but is not very satisfactory for the @samp{append(out, in, in)} mode of append,
because although every call in this mode only has at most one solution,
the compiler's determinism inference will not be able to infer that.
This means that using the usual code
for append in this mode will be inefficient,
and the overly conservative determinism inference
may cause spurious determinism errors later.

For this mode, it is better to use a completely different algorithm:

@example
append(Prefix, Suffix, List) :-
    list.length(List, ListLength),
    list.length(Suffix, SuffixLength),
    PrefixLength = ListLength - SuffixLength,
    list.split_list(PrefixLength, List, Prefix, Suffix).
@end example

@noindent
However, that code doesn't work in the other modes of @samp{append}.

To handle such cases, you can use mode annotations on clauses,
which indicate that particular clauses
should only be used for particular modes.
To specify that a clause only applies to a given mode,
each argument @var{Arg} of the clause head
should be annotated with the corresponding argument mode @var{Mode},
using the @samp{::} mode qualification operator,
i.e.@: @samp{@var{Arg} :: @var{Mode}}.

For example, if @samp{append} was declared as
@example
@group
:- pred append(list(T), list(T), list(T)).
:- mode append(in, in, out).
:- mode append(out, out, in).
:- mode append(in, out, in).
:- mode append(out, in, in).
@end group
@end example

@noindent
then you could implement it as

@example
@group
append(L1::in,  L2::in,  L3::out) :- usual_append(L1, L2, L3).
append(L1::out, L2::out, L3::in)  :- usual_append(L1, L2, L3).
append(L1::in,  L2::out, L3::in)  :- usual_append(L1, L2, L3).
append(L1::out, L2::in,  L3::in)  :- other_append(L1, L2, L3).

usual_append([], Ys, Ys).
usual_append([X|Xs], Ys, [X|Zs]) :- usual_append(Xs, Ys, Zs).

other_append(Prefix, Suffix, List) :-
    list.length(List, ListLength),
    list.length(Suffix, SuffixLength),
    PrefixLength = ListLength - SuffixLength,
    list.split_list(PrefixLength, List, Prefix, Suffix).
@end group
@end example

This language feature can be used to write ``impure'' code
that doesn't have any consistent declarative semantics.
For example, you can easily use it
to write something similar to Prolog's (in)famous @samp{var/1} predicate:

@example
:- mode var(in).
:- mode var(free>>free).
var(_::in) :- fail.
var(_::free>>free) :- true.
@end example

@noindent
As you can see, in this case the two clauses are @emph{not} equivalent.

Because of this possibility,
predicates or functions which are defined
using different code for different modes
are by default assumed to be impure;
the programmer must either
(1) carefully ensure that the logical meaning of the clauses
is the same for all modes,
which can be declared to the compiler
through a @samp{pragma promise_equivalent_clauses} declaration,
or a @samp{pragma promise_pure} declaration,
or (2) declare the predicate or function as impure.
@xref{Impurity}.

In the example with @samp{append} above,
the two ways of implementing append do have the same declarative semantics,
so we can safely use the first approach:

@example
:- pragma promise_equivalent_clauses(append/3).
@end example

The pragma

@example
:- pragma promise_pure(append/3).
@end example

would also promise that the clauses are equivalent,
but on top of that would also promise that the code of each clause is pure.
Sometimes, if some clauses contain impure code,
that is a promise that the programmer wants to make,
but this extra promise is unnecessary in this case.

In the example with @samp{var/1} above,
the two clauses have different semantics,
so the predicate must be declared as impure:

@example
	:- impure pred var(T).
@end example

@node Unique modes
@chapter Unique modes

Mode declarations can also specify so-called ``unique modes''.
Mercury's unique modes are similar
to ``linear types'' in some functional programming languages such as Clean.
They allow you to specify
when there is only one reference to a particular value,
and when there will be no more references to that value.
If the compiler knows there will be no more references to a value,
it can perform ``compile-time garbage collection''
by automatically inserting code
to deallocate the storage associated with that value.
Even more importantly,
the compiler can also simply reuse the storage immediately,
for example by destructively updating one element of an array
rather than making a new copy of the entire array
in order to change one element.
Unique modes are also the mechanism Mercury uses to provide declarative I/O.

We have not yet implemented unique modes fully,
and the details are still in a state of flux.
So the following should be considered tentative.

@menu
* Destructive update::
* Backtrackable destructive update::
* Limitations of the current implementation::
@end menu

@node Destructive update
@section Destructive update

In addition to the insts mentioned above
(@code{free}, @code{ground}, and @code{bound(@dots{})}),
Mercury also provides ``unique'' insts
@code{unique} and @code{unique(@dots{})}
which are like @code{ground} and @code{bound(@dots{})} respectively,
except that they carry the additional constraint that
there can only be one reference to the corresponding value.
There is also an inst @code{dead} which means that
there are no references to the corresponding value,
so the compiler is free to generate code that reuses that value.
There are three standard modes for manipulating unique values:

@example
% unique output
:- mode uo == free >> unique.

% unique input
:- mode ui == unique >> unique.

% destructive input
:- mode di == unique >> dead.
@end example

Mode @code{uo} is used to create a unique value.
Mode @code{ui} is used to inspect a unique value without losing its uniqueness.
Mode @code{di} is used to deallocate or reuse the memory
occupied by a value that will not be used.

Note that a value is not considered @code{unique}
if it might be needed on backtracking.
This means that unique modes are generally only useful
for code whose determinism is @code{det} or @code{cc_multi}
(@pxref{Determinism}).

Unlike @code{bound} instantiatedness trees,
there is no alternative syntax for @code{unique} instantiatedness trees.

@node Backtrackable destructive update
@section Backtrackable destructive update

@quotation
``Well it just so happens that your friend here is only @emph{mostly} dead.
@*There's a big difference between mostly dead and all dead@dots{}
@*Now, mostly dead is slightly alive.
@*Now, all dead --- well, with all dead, there's usually only
one thing that you can do.''

``What's that?''

``Go through his clothes and look for loose change!''

--- from the movie ``The Princess Bride''.
@end quotation

To allow for backtrackable destructive updates
--- that is, updates whose effect is undone on backtracking,
perhaps by recording the overwritten values on a ``trail''
so that they can be restored after backtracking ---
Mercury also provides ``mostly unique'' modes.
The insts @code{mostly_unique} and @code{mostly_dead}
are equivalent to @code{unique} and @code{dead},
except that only references which will be encountered during forward execution
are counted ---
it is OK for @code{mostly_unique} or @code{mostly_dead} values
to be needed again on backtracking.

Mercury defines some standard modes
for manipulating ``mostly unique'' values, just as it does for unique values:

@example
% mostly unique output
:- mode muo == free >> mostly_unique.

% mostly unique input
:- mode mui == mostly_unique >> mostly_unique.

% mostly destructive input
:- mode mdi == mostly_unique >> mostly_dead.
@end example

@node Limitations of the current implementation
@section Limitations of the current implementation

The implementation of the mode analysis algorithm is not quite complete;
as a result, it is not possible to use nested unique modes,
i.e.@: modes in which anything but the top level of a variable is unique.
If you do, you will get unique mode errors
when you try to get a unique field of a unique data structure.
It is also not possible to use unique-input modes;
only destructive-input and unique-output modes work.

The Mercury compiler does not (yet) reuse @code{dead} values.
The only destructive update in the current implementation occurs
in library modules, e.g.@: for I/O and arrays.
We do however plan to implement structure reuse
and compile-time garbage collection in the future.

@node Determinism
@chapter Determinism

@menu
* Determinism categories::
* Determinism checking and inference::
* Replacing compile-time checking with run-time checking::
* Interfacing nondeterministic code with the real world::
* Committed choice nondeterminism::
@end menu

@node Determinism categories
@section Determinism categories

For each mode of a predicate or function,
we categorise that mode according to how many times it can succeed,
and whether or not it can fail before producing its first solution.

If all possible calls to a particular mode of a predicate or function
which return to the caller
(calls which terminate,
do not throw an exception
and do not cause a fatal runtime error)

@itemize @bullet
@item
have exactly one solution,
then that mode is @dfn{deterministic} (@code{det});

@item
either have no solutions or have one solution,
then that mode is @dfn{semideterministic} (@code{semidet});

@item
have at least one solution but may have more,
then that mode is @dfn{multisolution} (@code{multi});

@item
have zero or more solutions,
then that mode is @dfn{nondeterministic} (@code{nondet});

@item
fail without producing a solution,
then that mode has a determinism of @code{failure}.
@end itemize

If no possible calls to a particular mode of a predicate or function
can return to the caller,
then that mode has a determinism of @code{erroneous}.

The determinism annotation @code{erroneous} is used on the library predicates
@samp{require.error/1} and @samp{exception.throw/1},
but apart from that,
determinism annotations @code{erroneous} and @code{failure}
are generally not needed.

To summarize:

@example
                Maximum number of solutions
Can fail?       0               1               > 1
no              erroneous       det             multi
yes             failure         semidet         nondet
@end example

(Note: the ``Can fail?'' column here indicates only whether the procedure
can fail before producing at least one solution;
attempts to find a @emph{second} solution to a particular call,
e.g.@: for a procedure with determinism @code{multi},
are always allowed to fail.)

The determinism of each mode of a predicate or function
is indicated by an annotation on the mode declaration.
For example:

@example
:- pred append(list(T), list(T), list(T)).
:- mode append(in, in, out) is det.
:- mode append(out, out, in) is multi.
:- mode append(in, in, in) is semidet.

:- func length(list(T)) = int.
:- mode length(in) = out is det.
:- mode length(in(list_skel)) = out is det.
:- mode length(in) = in is semidet.
@end example

An annotation of @code{det} or @code{multi} is an assertion
that for every value each of the inputs,
there exists at least one value of the outputs
for which the predicate is true,
or (in the case of functions)
for which the function term is equal to the result term.
Conversely, an annotation of @code{det} or @code{semidet} is an assertion
that for every value each of the inputs,
there exists at most one value of the outputs for which the predicate is true,
or (in the case of functions)
for which the function term is equal to the result term.
These assertions are called the @dfn{mode-determinism assertions};
they can play a role in the semantics,
because in certain circumstances,
they may allow an implementation to perform
optimizations that would not otherwise be allowed,
such as optimizing away a goal with no outputs
even though it might infinitely loop.

If the mode of the predicate is given in the @code{:- pred} declaration
rather than in a separate @code{:- mode} declaration,
then the determinism annotation goes on the @code{:- pred} declaration
(and similarly for functions).
In particular, this is necessary
if a predicate does not have any argument variables.
If the determinism declaration is given on a @code{:- func} declaration
without the mode, the function is assumed to have the default mode
(see @ref{Modes} for more information on default modes of functions).

For example:

@example
:- pred loop(int::in) is erroneous.
loop(X) :- loop(X).

:- pred p is det.
p.

:- pred q is failure.
q :- fail.
@end example

If there is no mode declaration for a function,
then the default mode for that function
is considered to have been declared as @code{det}.
If you want to write a partial function,
i.e.@: one whose determinism is @code{semidet},
then you must explicitly declare the mode and determinism.

In Mercury, a function is supposed to be
a true mathematical function of its arguments;
that is, the value of the function's result
should be determined only by the values of its arguments.
Hence, for any mode of a function
that specifies that all the arguments are fully input
(i.e.@: for which the initial inst of all the arguments is a ground inst),
the determinism of that mode can only be
@code{det}, @code{semidet}, @code{erroneous}, or @code{failure}.

The determinism categories form this lattice:

@example
             erroneous
              /     \
          failure   det
             \     /   \
             semidet  multi
                 \     /
                  nondet
@end example

The higher up this lattice a determinism category is,
the more the compiler knows about the number of solutions
of procedures of that determinism.

@node Determinism checking and inference
@section Determinism checking and inference

The determinism of goals
is inferred from the determinism of their component parts,
according to the rules below.
The inferred determinism of a procedure is just the inferred
determinism of the procedure's body.

For procedures that are local to a module,
the determinism annotations may be omitted;
in that case, their determinism will be inferred.
(To be precise, the determinism of procedures without a determinism annotation
is defined as the least fixpoint of the transformation which,
given an initial assignment
of the determinism @code{det} to all such procedures,
applies those rules to infer
a new determinism assignment for those procedures.)

It is an error to omit the determinism annotation
for procedures that are exported from their containing module.

If a determinism annotation is supplied for a procedure,
the declared determinism is compared against the inferred determinism.
If the declared determinism is greater than or not comparable to the
inferred determinism (in the partial ordering above), it is an error.
If the declared determinism is less than the inferred determinism,
it is not an error, but the implementation may issue a warning.

The determinism category of each goal
is inferred according to the following rules.
These rules work with the two components of determinism categories:
whether the goal can fail without producing a solution,
and the maximum number of solutions of the goal (0, 1, or more).
If the inference process below reports that a goal can succeed more than once,
but the goal generates no outputs that are visible from outside the goal,
and the goal is not impure (@pxref{Impurity}),
then the final determinism of the goal
will be based on the goal succeeding at most once,
since the compiler will implicitly prune away any duplicate solutions.

@table @asis
@item Calls
The determinism category of a call
is the determinism declared or inferred
for the called mode of the called procedure.

@item Unifications
The determinism of a unification
is either @code{det}, @code{semidet}, or @code{failure},
depending on its mode.

A unification that assigns the value of one variable to another
is deterministic.
A unification that constructs a structure and assigns it to a variable
is also deterministic.
A unification that tests whether a variable has a given top function symbol
is semideterministic,
unless the compiler knows the top function symbol of that variable,
in which case its determinism is either det or failure
depending on whether the two function symbols are the same or not.
A unification that tests two variables for equality
is semideterministic,
unless the compiler knows that the two variables are aliases for one another,
in which case the unification is deterministic,
or unless the compiler knows that the two variables
have different function symbols in the same position,
in which case the unification has a determinism of failure.

The compiler knows the top function symbol of a variable
if the previous part of the procedure definition
contains a unification of the variable with a function symbol,
or if the variable's type has only one function symbol.

@item Conjunctions
The determinism of the empty conjunction (the goal @samp{true})
is @code{det}.
The conjunction @samp{(@var{A}, @var{B})} can fail
if either @var{A} can fail, or if @var{A} can succeed at least once,
and @var{B} can fail.
The conjunction can succeed at most zero times
if either @var{A} or @var{B} can succeed at most zero times.
The conjunction can succeed more than once
if either @var{A} or @var{B} can succeed more than once
and both @var{A} and @var{B} can succeed at least once.
(If e.g.@: @var{A} can succeed at most zero times,
then even if @var{B} can succeed many times
the maximum number of solutions of the conjunction is still zero.)
Otherwise, i.e.@: if both @var{A} and @var{B} succeed at most once,
the conjunction can succeed at most once.

@item Switches
A disjunction is a @emph{switch}
if each disjunct has near its start
a unification that tests the same bound variable
against a different function symbol.
For example, consider the common pattern
@example
@group
(
    L = [], empty(Out)
;
    L = [H|T], nonempty(H, T, Out)
)
@end group
@end example

If @code{L} is input to the disjunction,
then the disjunction is a switch on @code{L}.

If two variables are unified with each other,
then whatever function symbol one variable is unified with,
the other variable is considered to be unified with the same function symbol.
In the following example,
since @code{K} is unified with @code{L},
the second disjunct unifies @code{L} as well as @code{K} with cons,
and thus the disjunction is recognized as a switch.
@example
@group
(
    L = [], empty(Out)
;
    K = L, K = [H|T], nonempty(H, T, Out)
)
@end group
@end example

A switch can fail
if the various arms of the switch do not cover
all the function symbols in the type of the switched-on variable,
or if the code in some arms of the switch can fail,
bearing in mind that in each arm of the switch,
the unification that tests the switched-on variable
against the function symbol of that arm
is considered to be deterministic.
A switch can succeed several times
if some arms of the switch can succeed several times,
possibly because there are multiple disjuncts
that test the switched-on variable against the same function symbol.
A switch can succeed at most zero times
only if all the reachable arms of the switch can succeed at most zero times.
(A switch arm is not reachable
if it unifies the switched-on variable with a function symbol
that is ruled out by that variable' initial instantation state.)

Only unifications may occur
before the test of the switched-on variable in each disjunct.
Tests of the switched-on variable
may occur within existential quantification goals.

The following example is a switch.

@example
(
    Out = 1, L = []
;
    some [H, T] (
        L = [H|T],
        nonempty(H, T, Out)
    )
)
@end example

The following example is not a switch
because the call in the first disjunct occurs
before the test of the switched-on variable.

@example
(
    empty(Out), L = []
;
    L = [H|T], nonempty(H, T, Out)
)
@end example

The unification of the switched-on variable with a function symbol
may occur inside a nested disjunction in a given disjunct,
provided that unification is preceded only by other unifications,
both inside the nested disjunction and before the nested disjunction.
The following example is a switch on @code{X},
provided @code{X} is bound beforehand.

@example
@group
(
    X = f
    p(Out)
;
    Y = X,
    (
        Y = g,
        Intermediate = 42
    ;
        Z = Y,
        Z = h(Arg),
        q(Arg, Intermediate)
    ),
    r(Intermediate, Out)
)
@end group
@end example

@item Disjunctions
The determinism of the empty disjunction (the goal @samp{fail})
is @code{failure}.
A disjunction @samp{(@var{A} ; @var{B})} that is not a switch
can fail if both @var{A} and @var{B} can fail.
It can succeed at most zero times
if both @var{A} and @var{B} can succeed at most zero times.
It can succeed at most once
if one of @var{A} and @var{B} can succeed at most once
and the other can succeed at most zero times.
Otherwise, i.e.@: if either @var{A} or @var{B} can succeed more than once,
or if both @var{A} and @var{B} can succeed at least once,
it can succeed more than once.

@c The local determinism of a disjunction is @code{nondet} unless the
@c compiler can detect that the disjunction is actually a switch and
@c hence @dfn{index} the disjunction.
@c Precisely describing the rules for detecting switches is somewhat tricky,
@c and I won't attempt to do so, but they are
@c reasonable easy to understand in practice.
@c The compiler can index on any input variable to a disjunction
@c (not just the first head variable).  It can also index on more than
@c one variable, since after indexing on the first one, switch detection is
@c applied to all sub-disjunctions.  It can index on any functor, not
@c just the top-most one.

@item If-then-else

If the condition of an if-then-else cannot fail,
the if-then-else is equivalent
to the conjunction of the condition and the ``then'' part,
and its determinism is computed accordingly.
Otherwise, an if-then-else can fail
if either the ``then'' part or the ``else'' part can fail.
It can succeed at most zero times
if the ``else'' part can succeed at most zero times
and if at least one of the condition and the ``then'' part
can succeed at most zero times.
It can succeed more than once
if any one of the condition, the ``then'' part and the ``else'' part
can succeed more than once.

@item Negations

If the determinism of the negated goal is @code{erroneous},
then the determinism of the negation is @code{erroneous}.
If the determinism of the negated goal is @code{failure},
the determinism of the negation is @code{det}.
If the determinism of the negated goal is @code{det} or @code{multi},
the determinism of the negation is @code{failure}.
Otherwise, the determinism of the negation is @code{semidet}.

@end table

@node Replacing compile-time checking with run-time checking
@section Replacing compile-time checking with run-time checking

Note that ``perfect'' determinism inference is an undecidable problem,
because it requires solving the halting problem.
(For instance, in the following example

@example
@group
:- pred p(T, T).
:- mode p(in, out) is det.

p(A, B) :-
    (
        something_complicated(A, B)
    ;
        B = A
    ).
@end group
@end example

@noindent
@samp{p/2} can have more than one solution
only if @samp{something_complicated/2} can succeed.)
Sometimes,
the rules specified by the Mercury language for determinism inference
will infer a determinism that is not as precise as you would like.
However, it is generally easy to overcome such problems.
The way to do this is to replace the compiler's static checking
with some manual run-time checking.
For example, if you know that a particular goal should never fail,
but the compiler infers that goal to be @code{semidet},
you can check at runtime that the goal does succeed,
and if it fails, call the library predicate @samp{error/1}.

@example
:- pred q(T, T).
:- mode q(in, out) is det.

q(A, B) :-
    ( goal_that_should_never_fail(A, B0) ->
        B = B0
    ;
        error("goal_that_should_never_fail failed!")
    ).
@end example

@noindent
The predicate @code{error/1} has determinism @code{erroneous},
which means the compiler knows that it will never succeed or fail,
so the inferred determinism for the body of @code{q/2} is @code{det}.
(Checking assumptions like this is good coding style anyway.
The small amount of up-front work that Mercury requires
is paid back in reduced debugging time.)
Mercury's mode analysis knows that
computations with determinism @code{erroneous} can never succeed,
which is why it does not require the ``else'' part
to generate a value for @code{B}.
The introduction of the new variable @code{B0} is necessary
because the condition of an if-then-else is a negated context,
and can export the values it generates
only to the ``then'' part of the if-then-else,
not directly to the surrounding computation.
(If the surrounding computations had direct access
to values generated in conditions,
they might access them even if the condition failed.)

@node Interfacing nondeterministic code with the real world
@section Interfacing nondeterministic code with the real world

Normally, attempting to call
a @code{nondet} or @code{multi} mode of a predicate
from a predicate declared as @code{semidet} or @code{det}
will cause a determinism error.
So how can we call nondeterministic code from deterministic code?
There are several alternative possibilities.

If you just want to see if a nondeterministic goal is satisfiable or not,
without needing to know what variable bindings it produces,
then there is no problem -
determinism analysis considers @code{nondet} and @code{multi} goals
with no non-local output variables to be
@code{semidet} and @code{det} respectively.

If you want to use the values of output variables,
then you need to ask yourself
which one of possibly many solutions to a goal do you want?
If you want all of them, you need to use the predicate
@samp{solutions/2} in the standard library module @samp{solutions},
which collects all of the solutions to a goal into a list ---
@pxref{Higher-order}.

If you just want one solution and don't care which,
the calling predicate should be declared @code{nondet} or @code{multi}.
The nondeterminism should then be propagated up the call tree
to the point at which it can be pruned.
In Mercury, pruning can be achieved in several ways.

The first way is the one mentioned above:
if a goal has no non-local output variables
then the implementation will only attempt to satisfy the goal once.
Any potential duplicate solutions will be implicitly pruned away.

The second way is to rely on the fact that
the implementation will only seek a single solution to @samp{main/2},
so alternative solutions to @samp{main/2}
(and hence also to @code{nondet} or @code{multi} predicates
called directly or indirectly from @samp{main/2})
are implicitly pruned away.
This is one way to achieve ``don't care'' style nondeterminism in Mercury.

The other situation in which you may want pruning
and committed choice style nondeterminism
is when you know that all the solutions returned will be equivalent.
For example, you might want to find the maximum element in a set
by iterating over the elements in the set.
Iterating over the elements in a set in an unspecified order is a
nondeterministic operation,
but no matter which order you remove them,
the maximum value in the set should be the same.

If you know that there will only ever be at most one distinct
solution under the equality theory of the output variables,
then you can use a @samp{promise_equivalent_solutions} determinism cast.

Note that specifying a user-defined equivalence relation
as the equality predicate for user-defined types
(@pxref{User-defined equality and comparison})
means that @samp{promise_equivalent_solutions}
can be used to express more general forms of equivalence.
For example, if you define a set type which represents sets as unsorted lists,
you would want to define a user-defined equivalence relation for that type,
which could sort the lists before comparing them.
The @samp{promise_equivalent_solutions} determinism cast
could then be used for sets
even though the lists used to represent the sets
might not be in the same order in every solution.

@node Committed choice nondeterminism
@section Committed choice nondeterminism

In addition to the determinism annotations described earlier,
there are ``committed choice'' versions of @code{multi} and @code{nondet},
called @code{cc_multi} and @code{cc_nondet}.
These can be used instead of @code{multi} or @code{nondet}
if all calls to that mode of the predicate (or function)
occur in a context in which only one solution is needed.

Such single-solution contexts are determined as follows.

@itemize @bullet
@item
The body of any procedure declared @code{cc_multi} or @code{cc_nondet}
is in a single-solution context.
For example, the program entry point @samp{main/2}
may be declared @code{cc_multi},
and in that case the clauses for @code{main} are in a single-solution context.

@item
Any goal with no output variables is in a single-solution context.

@item
If a conjunction is in a single-solution context,
then the right-most conjunct is in a single-solution context,
and if the right-most conjunct cannot fail,
then the rest of the conjunction is also in a single-solution context.
(``Right-most'' here refers to the order @emph{after} mode reordering.)

@item
If an if-then-else is in a single-solution context,
then the ``then'' part and the ``else'' part are in single-solution contexts,
and if the ``then'' part cannot fail,
then the condition of the if-then-else is also in a single-solution context.

@item
For other compound goals, i.e.@: disjunctions, negations,
and (explicitly) existentially quantified goals,
if the compound goal is in a single-solution context,
then the immediate sub-goals of that compound goal
are also in single-solution contexts.

@end itemize

The compiler will check that
all calls to a committed-choice mode of a predicate (or function)
do indeed occur in a single-solution context.

You can declare two different modes of a predicate (or function)
which differ only in ``cc-ness''
(i.e.@: one being @code{multi} and the other @code{cc_multi},
or one being @code{nondet} and the other @code{cc_nondet}).
In that case,
the compiler will select the appropriate one for each call
depending on whether the call comes from a single-solution context or not.
Calls from single-solution contexts will call the committed choice version,
while calls which are not from single-solution contexts
will call the backtracking version.

There are several reasons to use committed choice determinism annotations.
One reason is for efficiency:
committed choice annotations allow the compiler
to generate much more efficient code.
Another reason is for doing I/O,
which is allowed only in @code{det} or @code{cc_multi} predicates,
not in @code{multi} predicates.
Another is for dealing with types that use non-canonical representations
(@pxref{User-defined equality and comparison}).
And there are a variety of other applications.

@c XXX fix semantics for I/O + committed choice + mode inference

@c @node Assertions
@c @chapter Assertions
@c
@c Mercury supports the declaration of laws that hold for predicates and
@c functions.
@c These laws are only checked for type-correctness,
@c it is the responsibility of the programmer to ensure overall correctness.
@c The behaviour of programs with incorrect laws is undefined.
@c
@c A new law is introduced with the @samp{:- promise} declaration.
@c
@c Here are some examples of @samp{:- promise} declarations.
@c The following example declares the function @samp{+} to be commutative.
@c
@c @example
@c :- promise all [A, B, R]
@c     (
@c         R = A + B
@c     <=>
@c         R = B + A
@c     ).
@c @end example
@c
@c Note that each variable in the declaration was explicitly quantified.
@c The current Mercury compiler requires that each assertion begins with
@c an @samp{all} quantification, and that every variable is explicitly
@c quantified.
@c
@c Here is a more complicated declaration. It declares that @samp{append} is
@c associative.
@c
@c @example
@c :- promise all [A, B, C, ABC]
@c     (
@c         ( some [AB] (append(A, B, AB), append(AB, C, ABC)) )
@c     <=>
@c         ( some [BC] (append(B, C, BC), append(A, BC, ABC)) )
@c     ).
@c @end example

@node User-defined equality and comparison
@chapter User-defined equality and comparison

When defining abstract data types,
often it is convenient to use a non-canonical representation ---
that is, one for which a single abstract value
may have more than one different possible concrete representation.
For example, you may wish to implement an abstract type @samp{set}
by representing a set as an (unsorted) list.

@example
:- module set_as_unsorted_list.
:- interface.
:- type set(T).

:- implementation.
:- import_module list.
:- type set(T)
    --->    set(list(T)).
@end example

@noindent
In this example,
the concrete representations @samp{set([1,2])} and @samp{set([2,1])}
would both represent the same abstract value,
namely the set containing the elements 1 and 2.

For types such as this, which do not have a canonical representation,
the standard definition of equality is not the desired one;
we want equality on sets to mean equality of the abstract values,
not equality of their representations.
To support such types, Mercury allows programmers to specify
a user-defined equality predicate for user-defined types:

@example
:- type set(T)
    --->    set(list(T))
            where equality is set_equals.
@end example

@noindent
Here @samp{set_equals} is the name of a user-defined predicate
that is used for equality on the type @samp{set(T)}.
It could for example be defined in terms of a @samp{subset} predicate.

@example
:- pred set_equals(set(T)::in, set(T)::in) is semidet.
set_equals(S1, S2) :-
    subset(S1, S2),
    subset(S2, S1).
@end example

A comparison predicate can also be supplied.

@example
:- type set(T)
    --->    set(list(T))
            where equality is set_equals, comparison is set_compare.

:- pred set_compare(builtin.comparison_result::uo,
    set(T)::in, set(T)::in) is det.

set_compare(Result, Set1, Set2) :-
    promise_equivalent_solutions [Result] (
        set_compare_2(Set1, Set2, Result)
    ).

:- pred set_compare_2(set(T)::in, set(T)::in,
    builtin.comparison_result::uo) is cc_multi.

set_compare_2(set(List1), set(List2), Result) :-
    builtin.compare(Result, list.sort(List1), list.sort(List2)).
@end example

If a comparison predicate is supplied
and the unification predicate is omitted,
a unification predicate is generated by the compiler
in terms of the comparison predicate.
For the @samp{set} example, the generated predicate would be:

@example
set_equals(S1, S2) :-
    set_compare((=), S1, S2).
@end example

If a unification predicate is supplied without a comparison predicate,
the compiler will generate a comparison predicate
which throws an exception of type @samp{exception.software_error} when called.

A type declaration for a type @samp{foo(T1, @dots{}, TN)}
may contain a @samp{where equality is @var{equalitypred}} specification
only if it declares a discriminated union type or a foreign type
(@pxref{Using foreign types from Mercury})
and the following conditions are satisfied:

@itemize @bullet
@item
@var{equalitypred} must be the name of a predicate with signature
@example
:- pred @var{equalitypred}(foo(T1, @dots{}, TN)::in,
                foo(T1, @dots{}, TN)::in) is semidet.
@end example

It is legal for the type, mode and determinism to be more permissive:
the type or the mode's initial insts may be more general
(e.g.@: the type of the equality predicate
could be just the polymorphic type @samp{pred(T, T)})
and the mode's final insts or the determinism may be more specific
(e.g.@: the determinism of the equality predicate
could be any of @code{det}, @code{failure} or @code{erroneous}).

@item
If the type is a discriminated union
then its definition cannot be a single zero-arity constructor.

@item
The equality predicate must be ``pure'' (@pxref{Impurity}).

@item
The equality predicate must be defined in the same module as the type.

@item
If the type is exported the equality predicate must also be exported.

@item
@var{equalitypred} should be an equivalence relation;
that is, it must be symmetric, reflexive, and transitive.
However, the compiler is not required to check this
@footnote{If @var{equalitypred} is not an equivalence relation,
then the program is inconsistent:
its declarative semantics contains a contradiction,
because the additional axioms for the user-defined equality
contradict the standard equality axioms.
That implies that the implementation
may compute any answer at all (@pxref{Semantics}),
i.e.@: the behaviour of the program is undefined.}.

@end itemize

Types with user-defined equality can only be used in limited ways.
Because there are multiple representations for the same abstract value,
any attempt to examine the representation of such a value
is a conceptually non-deterministic operation.
In Mercury this is modelled using committed choice nondeterminism.

The semantics of specifying @samp{where equality is @var{equalitypred}}
on the type declaration for a type @var{T} are as follows:

@itemize @bullet
@item
If the program contains any deconstruction unification or switch
on a variable of type @var{T} that could fail,
other than unifications with mode @samp{(in, in)},
then it is a compile-time error.

@item
If the program contains any deconstruction unification or switch
on a variable of type @var{T} that cannot fail,
then that operation has determinism @code{cc_multi}.

@item
Any attempts to examine the representation of a variable of type @var{T}
using facilities of the standard library
(e.g.@: @samp{argument}/3 and @samp{functor/3} in @samp{deconstruct})
that do not have determinism @code{cc_multi} or @code{cc_nondet}
will result in a run-time error.

@item
In addition to the usual equality axioms,
the declarative semantics of the program will contain the axiom
@samp{@var{X} = @var{Y} <=> @var{equalitypred}(@var{X}, @var{Y})}
for all @var{X} and @var{Y} of type @samp{T}.

@item
Any @samp{(in, in)} unifications for type @var{T}
are computed using the specified predicate @var{equalitypred}.

@end itemize

A type declaration for a type @samp{foo(T1, @dots{}, TN)}
may contain a @samp{where comparison is @var{comparepred}} specification
only if it declares a discriminated union type or a foreign type
(@pxref{Using foreign types from Mercury}) and the
following conditions are satisfied:

@itemize @bullet
@item
@var{comparepred} must be the name of a predicate with signature
@example
:- pred @var{comparepred}(builtin.comparison_result::uo,
                foo(T1, @dots{}, TN)::in, foo(T1, @dots{}, TN)::in) is det.
@end example

As with equality predicates,
it is legal for the type, mode and determinism to be more permissive.

@item
If the type is a discriminated union
then its definition cannot be a single zero-arity constructor.

@item
The comparison predicate must also be ``pure'' (@pxref{Impurity}).

@item
The comparison predicate must be defined in the same module as the type.

@item
If the type is exported the comparison predicate must also be exported.

@item
The relation
@example
compare_eq(X, Y) :- @var{comparepred}((=), X, Y).
@end example
must be an equivalence relation;
that is, it must be symmetric, reflexive, and transitive.
The compiler is not required to check this.

@item
The relations
@example
compare_leq(X, Y) :- @var{comparepred}(R, X, Y), (R = (=) ; R = (<)).
compare_geq(X, Y) :- @var{comparepred}(R, X, Y), (R = (=) ; R = (>)).
@end example
must be total order relations:
that is they must be antisymmetric, reflexive and transitive.
The compiler is not required to check this.

@end itemize

For each type for which the declaration has a
@samp{where comparison is @var{comparepred}} specification,
any calls to the standard library predicate @samp{builtin.compare/3}
with arguments of that type are evaluated
as if they were calls to @var{comparepred}.

A type declaration may contain a
@samp{where equality is @var{equalitypred}, comparison is @var{comparepred}}
specification only if in addition to the conditions above,
@samp{all [X, Y] (@var{comparepred}((=), X, Y) <=> @var{equalitypred}(X, Y))}.
The compiler is not required to check this.

@node Higher-order
@chapter Higher-order programming

Mercury supports higher-order functions and predicates
with currying, closures, and lambda expressions.
(To be pedantic, it would be more accurate to say that
Mercury supports higher-order procedures:
in Mercury, when you construct a higher-order term,
you only get one mode of a predicate or function;
if you want multiple modes, you must pass multiple higher-order procedures.)

@menu
* Creating higher-order terms::
* Calling higher-order terms::
* Higher-order insts and modes::
@end menu

@node Creating higher-order terms
@section Creating higher-order terms
@c NB. This section is pointed to by an error message in compiler/typecheck.m,
@c so if you change the section name, you need to update that error message.

To create a higher-order predicate or function term,
you can use a lambda expression,
or, if the predicate or function has only one mode
and it is not a zero-arity function,
you can just use its name.
For example, if you have declared a predicate

@example
:- pred sum(list(int), int).
:- mode sum(in, out) is det.
@end example

@noindent
the following unifications have the same effect:

@example
X = (pred(List::in, Length::out) is det :- sum(List, Length))
Y = sum
@end example

In the above example,
the type of @code{X}, and @code{Y} is @samp{pred(list(int), int)},
which means a predicate of two arguments
of types @code{list(int)} and @code{int} respectively.

Similarly, given

@example
:- func scalar_product(int, list(int)) = list(int).
:- mode scalar_product(in, in) = out is det.
@end example

@noindent
the following three unifications have the same effect:

@example
@group
X = (func(Num, List) = NewList :- NewList = scalar_product(Num, List))
Y = (func(Num::in, List::in) = (NewList::out) is det
        :- NewList = scalar_product(Num, List))
Z = scalar_product
@end group
@end example

In the above example,
the type of @code{X}, @code{Y}, and @code{Z} is
@samp{func(int, list(int)) = list(int)},
which means a function of two arguments,
whose types are @code{int} and @code{list(int)},
with a return type of @code{int}.
As with @samp{:- func} declarations,
if the modes and determinism of the function
are omitted in a higher-order function term,
then the modes default to @code{in} for the arguments,
@code{out} for the function result,
and the determinism defaults to @code{det}.

The Melbourne Mercury implementation currently requires
that you use an explicit lambda expression to specify which mode you want,
if the predicate or function has more than one mode
(but see below for an exception to this rule).

You can also create higher-order function terms
of non-zero arity and higher-order predicate terms by ``currying'',
i.e.@: specifying the first few arguments to a predicate or function,
but leaving the remaining arguments unspecified.
For example, the unification

@example
Sum123 = sum([1,2,3])
@end example

@noindent
binds @code{Sum123} to a higher-order predicate term of type @samp{pred(int)}.
Similarly, the unification

@example
Double = scalar_product(2)
@end example

@noindent
binds @code{Double} to a higher-order function term of type
@samp{func(list(int)) = list(int)}.

As a special case, currying of a multi-moded predicate or function is allowed
provided that the mode of the predicate or function
can be determined from the insts of the higher-order curried arguments.
For example, @samp{P = list.foldl(io.write)} is allowed
because the inst of @samp{io.write} matches
exactly one mode of @samp{list.foldl}.

For higher-order predicate expressions that thread an accumulator pair,
we have syntax that allows you to use DCG notation
in the goal of the expression.
For example,

@example
Pred = (pred(Strings::in, Num::out, di, uo) is det -->
    io.write_string("The strings are: "),
    @{ list.length(Strings, Num) @},
    io.write_strings(Strings),
    io.nl
)
@end example

@noindent
is equivalent to

@example
Pred = (pred(Strings::in, Num::out, IO0::di, IO::uo) is det :-
    io.write_string("The strings are: ", IO0, IO1),
    list.length(Strings, Num),
    io.write_strings(Strings, IO1, IO2),
    io.nl(IO2, IO)
)
@end example

Higher-order function terms of zero arity
can only be created using an explicit lambda expression;
you have to use e.g.@: @samp{(func) = foo} rather than plain @samp{foo},
because the latter denotes the result of evaluating the function,
rather than the function itself.

Note that when constructing a higher-order term,
you cannot just use the name of a builtin language construct
such as @samp{=}, @samp{\=}, @samp{call}, or @samp{apply},
and nor can such constructs be curried.
Instead, you must either use an explicit lambda expression,
or you must write a forwarding predicate or function.
For example, instead of

@example
list.filter(\=(2), [1, 2, 3], List)
@end example

@noindent
you must write either

@example
list.filter((pred(X::in) is semidet :- X \= 2), [1, 2, 3], List)
@end example

@noindent
or

@example
list.filter(not_equal(2), [1, 2, 3], List)
@end example

@noindent
where you have defined @samp{not_equal} using

@example
:- pred not_equal(T::in, T::in) is semidet.
not_equal(X, Y) :- X \= Y.
@end example

Another case when this arises is when want to curry a higher-order term.
Suppose, for example, that you have
a higher-order predicate term @samp{OldPred}
of type @samp{pred(int, char, float)},
and you want to construct a new higher-order predicate term
@samp{NewPred} of type @samp{pred(char, float)} from @samp{OldPred}
by supplying a value for just the first argument.
The solution is the same:
use an explicit lambda expression or a forwarding predicate.
In either case, the body of the lambda expression or the forwarding predicate
must contain a higher-order call with all the arguments supplied.

@node Calling higher-order terms
@section Calling higher-order terms

Once you have created a higher-order predicate term
(sometimes known as a closure),
the next thing you want to do is to call it.
For predicates, you use the builtin goal call/N:

@table @asis
@item @code{call(Closure)}
@itemx @code{call(Closure1, Arg1)}
@itemx @code{call(Closure2, Arg1, Arg2)}
@itemx @dots{}
A higher-order predicate call.  @samp{call(Closure)} just calls the
specified higher-order predicate term.  The other forms append the
specified arguments onto the argument list of the closure before
calling it.
@end table

For example, the goal

@example
call(Sum123, Result)
@end example

@noindent
would bind @code{Result} to the sum of @samp{[1, 2, 3]}, i.e.@: to 6.

For functions, you use the builtin expression apply/N:

@table @asis
@item @code{apply(Closure)}
@itemx @code{apply(Closure1, Arg1)}
@itemx @code{apply(Closure2, Arg1, Arg2)}
@itemx @dots{}
A higher-order function application.
Such a term denotes the result of
invoking the specified higher-order function term with the specified arguments.
@end table

For example, given the definition of @samp{Double} above, the goal

@example
List = apply(Double, [1, 2, 3])
@end example

@noindent
would be equivalent to

@example
List = scalar_product(2, [1, 2, 3])
@end example

@noindent
and so for a suitable implementation of the function @samp{scalar_product/2}
this would bind @code{List} to @samp{[2, 4, 6]}.

One extremely useful higher-order predicate in the Mercury standard library
is @samp{solutions/2}, which has the following declaration:

@example
:- pred solutions(pred(T), list(T)).
:- mode solutions(pred(out) is nondet, out) is det.
@end example

The term which you pass to @samp{solutions/2} is a higher-order predicate term.
You can pass the name of a one-argument predicate,
or you can pass a several-argument predicate
with all but one of the arguments supplied (a closure).
The declarative semantics of @samp{solutions/2} can be defined as follows:

@example
solutions(Pred, List) is true iff
    all [X] (call(Pred, X) <=> list.member(X, List))
    and List is sorted.
@end example

@noindent
where @samp{call(Pred, X)}
invokes the higher-order predicate term @code{Pred} with argument @code{X},
and where @samp{list.member/2}
is the standard library predicate for list membership.
In other words, @samp{solutions(Pred, List)} finds all the values of @code{X}
for which @samp{call(Pred, X)} is true,
collects these solutions in a list,
sorts the list, and returns that list as its result.
Here is an example: the standard library defines a predicate
@samp{list.perm(List0, List)}

@example
:- pred list.perm(list(T), list(T)).
:- mode list.perm(in, out) is nondet.
@end example

@noindent
which succeeds iff List is a permutation of List0.
Hence the following call to solutions

@example
solutions(list.perm([3,1,2]), L)
@end example

@noindent
should return
all the possible permutations of the list @samp{[3,1,2]} in sorted order:

@example
L = [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]].
@end example

See also @samp{unsorted_solutions/2} and @samp{solutions_set/2},
which are defined in the standard library module @samp{solutions}
and documented in the Mercury Library Reference Manual.

@node Higher-order insts and modes
@section Higher-order insts and modes

In Mercury, the mode and determinism
of a higher-order predicate or function term
are generally part of that term's @emph{inst}, not its @emph{type}.
This allows a single higher-order predicate to work
on argument predicates of different modes and determinism,
which is particularly useful for library predicates
such as @samp{list.map} and @samp{list.foldl}.

@menu
* Builtin higher-order insts and modes::
* Default insts for functions::
* Combined higher-order types and insts::
@end menu

@node Builtin higher-order insts and modes
@subsection Builtin higher-order insts and modes

The language contains builtin @samp{inst} values

@example
(pred) is @var{Determinism}
pred(@var{Mode}) is @var{Determinism}
pred(@var{Mode1}, @var{Mode2}) is @var{Determinism}
@dots{}
(func) = @var{Mode} is @var{Determinism}
func(@var{Mode1}) = @var{Mode} is @var{Determinism}
func(@var{Mode1}, @var{Mode2}) = @var{Mode} is @var{Determinism}
@dots{}
@end example

These insts represent the instantiation state
of variables bound to higher-order predicate and function terms
with the appropriate mode and determinism.
For example, @samp{pred(out) is det} represents the instantiation state
of being bound to a higher-order predicate term which is @code{det}
and accepts one output argument;
the term @samp{sum([1,2,3])} from the example above
is one such higher-order predicate term which matches this instantiation state.

As a convenience, the language also contains
builtin @samp{mode} values of the same name
(and they are what we have been using in the examples up to now).
These modes map from the corresponding @samp{inst} to itself.
It is as if they were defined by

@example
:- mode (pred is @var{Determinism}) == in(pred is @var{Determinism}).
:- mode (pred(@var{Inst}) is @var{Determinism}) ==
    in(pred(@var{Inst}) is @var{Determinism}).
@dots{}
@end example

@noindent
using the parametric inst @samp{in/1} mentioned in @ref{Modes}
which maps an inst to itself.

If you want to define a predicate which returns a higher-order predicate term,
you would use a mode such as @samp{free >> pred(@dots{}) is @dots{}},
or @samp{out(pred(@dots{}) is @dots{} )}.
For example:
@c XXX The space after the dots{} above works around a bug in texi2html

@example
:- pred foo(pred(int)).
:- mode foo(free >> pred(out) is det) is det.

foo(sum([1,2,3])).
@end example

Note that in Mercury it is an error to attempt to unify two higher-order terms.
This is because equivalence of higher-order terms
is undecidable in the general case.

For example, given the definition of @samp{foo} above, the goal

@example
foo((pred(X::out) is det :- X = 6))
@end example

@noindent
is illegal.
If you really want to compare higher-order predicates for equivalence,
you must program it yourself;
for example, the above goal could legally be written as

@example
P = (pred(X::out) is det :- X = 6),
foo(Q),
all [X] (call(P, X) <=> call(Q, X)).
@end example

Note that the compiler will only catch
direct attempts at higher-order unifications;
indirect attempts (via polymorphic predicates,
for example @samp{(list.append([], [P], [Q])}
may result in an error at run-time rather than at compile-time.

Mercury also provides builtin @samp{inst} values for use with solver types:

@example
any_pred is @var{Determinism}
any_pred(@var{Mode}) is @var{Determinism}
any_pred(@var{Mode1}, @var{Mode2}) is @var{Determinism}
@dots{}
any_func = @var{Mode} is @var{Determinism}
any_func(@var{Mode1}) = @var{Mode} is @var{Determinism}
any_func(@var{Mode1}, @var{Mode2}) = @var{Mode} is @var{Determinism}
@dots{}
@end example

See @ref{Solver types} for more details.

@node Default insts for functions
@subsection Default insts for functions

In order to call a higher-order term,
the compiler must know its higher-order inst.
This can cause problems when
higher-order terms are placed into a polymorphic collection type
and then extracted,
since the declared mode for the extraction will typically be @code{out}
and the higher-order inst information will be lost.
To partially alleviate this problem,
and to make higher-order functional programming easier,
if the term to be called has a function type,
but no higher-order inst information is explicitly provided,
we assume that it has the default higher-order function inst
@samp{func(in, @dots{}, in) = out is det}.

As a consequence of this,
a higher-order function term can @emph{only} be passed
where a term with no higher-order inst information is expected
if it can be passed
where a term with the default higher-order function inst is expected.
Higher-order predicate terms can always be passed to such a place,
but note that there is little value in doing so
because there is no default higher-order inst for predicates
therefore it will not be possible to call those terms.

@node Combined higher-order types and insts
@subsection Combined higher-order types and insts

A higher-order type may optionally specify an inst in the following manner:

@example
(pred) is @var{Determinism}
pred(@var{Type}::@var{Mode}) is @var{Determinism}
pred(@var{Type1}::@var{Mode1}, @var{Type2}::@var{Mode2}) is @var{Determinism}
@dots{}
(func) = (@var{Type}::@var{Mode}) is @var{Determinism}
func(@var{Type1}::@var{Mode1}) = (@var{Type}::@var{Mode}) is @var{Determinism}
func(@var{Type1}::@var{Mode1}, @var{Type2}::@var{Mode2}) = (@var{Type}::@var{Mode}) is @var{Determinism}
@dots{}
@end example

When used as argument types of functors in type declarations,
types of this form have two effects.
First, for any unification that constructs a term using such an argument,
there is an additional mode constraint that
the argument must be approximated by the inst.
In other words, to be mode correct a program must not construct any term
where a functor has an argument that does not have the declared inst,
if present.

The second effect is that when a unification deconstructs a ground term
to extract an argument with such a declared inst,
the extracted argument may then be used as if it had that inst.

For example, given this type declaration:

@example
:- type job
    --->    job(pred(int::out, io::di, io::uo) is det).
@end example

the following goal is correct:

@example
:- pred run(job::in, io::di, io::uo) is det.
run(Job, !IO) :-
    Job = job(Pred),
    Pred(Result, !IO),          % Pred has the necessary inst
    write_line(Result, !IO).
@end example

However, the following would be a mode error:

@example
:- pred bad(job::out) is det.
bad(job(p)).                    % Error: p does not have required mode

:- pred p(int::in, io::di, io::out) is det.
@dots{}
@end example

As a new feature, combined higher-order types and insts are only permitted
as direct arguments of functors in discriminated unions.
So the following examples currently result in errors.

@example
% Error: use on the RHS of equivalence types.
:- type p == (pred(io::di, io::uo) is det).
:- type f == (func(int::in) = (int::out) is semidet).

% Error: use inside a type constructor.
:- type jobs
    --->    jobs(list(pred(int::out, io::di, io::uo) is det)).

% Error: use in a pred/func declaration.
:- pred p((pred(io::di, io::uo) is det)::in, io::di, io::uo) is det.
:- func f(func(int::in) = (int::out) is semidet, int) = int.
@end example

Future versions of the language may allow these forms.

@node Modules
@chapter Modules

@menu
* The module system::
* An example module::
* Sub-modules::
* Module initialisation::
* Module finalisation::
* Module-local mutable variables::
@end menu

@node The module system
@section The module system

The Mercury module system is relatively simple and straightforward.

Each module must start with a @samp{:- module @var{ModuleName}} declaration,
specifying the name of the module.

An @samp{:- interface.} declaration indicates
the start of the module's interface section:
this section specifies the entities that are exported by this module.
Mercury provides support for abstract data types,
by allowing the definition of a type to be kept hidden,
with the interface only exporting the type name.
The interface section may contain definitions of types,
type classes, data constructors, instantiation states, and modes,
and declarations for abstract data types, abstract type class instances,
functions, predicates, and (sub-)modules.
The interface section may not contain definitions
for functions or predicates (i.e.@: clauses),
or definitions of (sub-)modules.

An @samp{:- implementation.} declaration indicates
the start of the module's implementation section.
Any entities declared in this section are local to the module
(and its sub-modules, if any) and cannot be used by other modules.
The implementation section must contain definitions
for all abstract data types, abstract instance declarations,
functions, predicates, and sub-modules exported by the module,
as well as for all local types, type class instances, functions,
predicates, and sub-modules.
The implementation section can be omitted if it is empty.

The module may optionally end
with a @samp{:- end_module @var{ModuleName}} declaration;
the name specified in the @samp{end_module} must be the same
as that in the corresponding @samp{module} declaration.

@c should we mention multipart interfaces and implementations?
@c ===> no

If a module wishes to make use of entities exported by other modules,
then it must explicitly import those modules
using one or more @samp{:- import_module @var{Modules}}
or @w{@samp{:- use_module @var{Modules}}} declarations,
in order to make those declarations visible.
In both cases, @var{Modules}
is a comma-separated list of fully-qualified module names.
These declarations may occur
either in the interface or the implementation section.
If the imported entities are used in the interface section,
then the corresponding @code{import_module} or @code{use_module}
declaration must also be in the interface section.
If the imported entities are only used in the implementation section,
the @code{import_module} or @code{use_module} declaration
should be in the implementation section.

The names of predicates, functions, constructors, constructor fields,
types, modes, insts, type classes, and (sub-)modules
can be explicitly module qualified using the @samp{.} operator,
e.g.@: @samp{module.name} or @samp{module.submodule.name}.
This is useful both for readability and for resolving name conflicts.
Uses of entities imported using @code{use_module} declarations
@emph{must} be explicitly fully module qualified.

Currently we also support @samp{__} as an alternative module qualifier,
so you can write @code{module__name} instead of @code{module.name}.

Certain optimizations require information or source code
for predicates defined in other modules to be as effective as possible.
At the moment, inlining and higher-order specialization
are the only optimizations
that the Mercury compiler can perform across module boundaries.

Exactly one module of the program
must export a predicate @samp{main/2},
which must be declared as either

@example
:- pred main(io.state::di, io.state::uo) is det.
@end example

@noindent
or

@example
:- pred main(io.state::di, io.state::uo) is cc_multi.
@end example

@noindent
(or any declaration equivalent to one of the two above).

Mercury has a standard library which includes over 100 modules,
including modules for
lists, stacks, queues, priority queues, sets, bags (multi-sets),
maps (dictionaries), random number generation, input/output,
and filename and directory handling.
See the Mercury Library Reference Manual for a list of the available modules,
and for the documentation of each module.

@node An example module
@section An example module.

For illustrative purposes,
here is the definition of a simple module for managing queues:

@example
:- module queue.
:- interface.

% Declare an abstract data type.

:- type queue(T).

% Declare some predicates which operate on the abstract data type.

:- pred empty_queue(queue(T)).
:- mode empty_queue(out) is det.
:- mode empty_queue(in) is semidet.

:- pred put(queue(T), T, queue(T)).
:- mode put(in, in, out) is det.

:- pred get(queue(T), T, queue(T)).
:- mode get(in, out, out) is semidet.

:- implementation.

% Queues are implemented as lists. We need the `list' module
% for the declaration of the type list(T), with its constructors
% '[]'/0 % and '.'/2, and for the declaration of the predicate
% list.append/3.

:- import_module list.

% Define the queue ADT.

:- type queue(T) == list(T).

% Define the exported predicates.

empty_queue([]).

put(Queue0, Elem, Queue) :-
    list.append(Queue0, [Elem], Queue).

get([Elem | Queue], Elem, Queue).

:- end_module queue.
@end example

@node Sub-modules
@section Sub-modules

As mentioned above, modules may contain sub-modules.
There are two kinds of sub-modules,
called nested sub-modules and separate sub-modules;
the difference is that nested sub-modules
are defined in the same source file as the containing module,
whereas separate sub-modules are defined in separate source files.
Implementations should support separate compilation of separate sub-modules.

A module may not contain more than one sub-module with the same name.

@menu
* Nested sub-modules::
* Separate sub-modules::
* Visibility rules::
* Implementation bugs and limitations::
@end menu

@node Nested sub-modules
@subsection Nested sub-modules

Nested sub-modules within a module are delimited by
matching @samp{:- module} and @samp{:- end_module} declarations.
(Note that @samp{:- end_module} for nested sub-modules
are mandatory, not optional,
even if the nested sub-module is the last thing in the source file.
Also note that the module name in a @samp{:- module} or @samp{:- end_module}
declaration need not be fully-qualified.)
The sequence of items thus delimited is known as a sub-module item sequence.

The interface and implementation parts of a nested sub-module
may be specified in two different sub-module declarations.
If a sub-module item sequence includes an interface section,
then it is a declaration of that sub-module;
if it includes an implementation section,
then it is a definition of that sub-module;
and if includes both, then it is both declaration and definition.

It is an error to declare a sub-module twice, or to define it twice.
It is an error to define a sub-module without declaring it.
As mentioned earlier, it is an error
to define a sub-module in the interface section of its parent module.

If a sub-module is declared but not explicitly defined,
then there is an implicit definition
with an empty implementation section for that sub-module.
This empty implementation section will result in an error
if the interface section of a sub-module contains any of the following:

@itemize @bullet
@item
a declaration for a function or a predicate;
@item
an abstract declaration for a type, inst, mode or typeclass,
i.e.@ a declaration that does not itself serve as a definition
of that type, inst, mode or typeclass;
@item
an abstract declaration of a typeclass instance; or
@item
a (doubly, triply, etc) nested sub-module
(which perforce has only an interface section, and no implementation section)
and which contains any of the above.
@end itemize

@node Separate sub-modules
@subsection Separate sub-modules

Separate sub-modules are declared using
@samp{:- include_module @var{Modules}} declarations.
Each @samp{:- include_module} declaration specifies
a comma-separated list of sub-modules.

@example
:- include_module @var{Module1}, @var{Module2}, @dots{}, @var{ModuleN}.
@end example

Each of the named sub-modules in an @samp{:- include_module} declaration
must be defined in a separate source file.
The mapping between module names and source file names
is implementation-defined.
(For a module named @samp{foo.bar.baz},
The University of Melbourne Mercury implementation
requires the source to be located in a file named
@file{foo.bar.baz.m}, @file{bar.baz.m}, or @file{baz.m}.)
The separate source file must contain the declaration (interface)
and definition (implementation) of the sub-module.
It must start with a @samp{:- module} declaration
which matches that in the @samp{:- include_module} declaration in the parent,
followed by the interface and (if necessary) implementation sections,
and it may optionally end with a @samp{:- end_module} declaration.
(Note: the module names in the @samp{:- module}, @samp{:- end_module},
and @w{@samp{:- include_module}} declarations need not be fully-qualified.
However, if the file name used for a particular module
does not include all the module qualifiers,
then the University of Melbourne Mercury implementation
requires the module name in the @samp{:- module} declaration
for that module to be fully qualified.)

The semantics of separate sub-modules
are identical to those of nested sub-modules.
The procedure to transform a separate sub-module
into a nested sub-module is as follows:

@enumerate
@item
Replace the @samp{:- include_module @var{submodule}} declaration
with the interface section of the sub-module
enclosed within @samp{:- module @var{submodule}}
and @samp{:- end_module @var{submodule}} declarations.
@item
Place the implementation section of the sub-module
enclosed within @samp{:- module @var{submodule}}
and @samp{:- end_module @var{submodule}} declarations
in the implementation section of the parent module.
@end enumerate

For example

@example
:- module x.
:- interface.
:- include_module y.
:- end_module x.
@end example

@noindent
is equivalent to

@example
:- module x.
:- interface.
    :- module y.
    % interface section of module @samp{y}
    :- end_module y.
:- implementation.
    :- module y.
    % implementation section of module @samp{y}
    :- end_module y.
:- end_module x.
@end example

@node Visibility rules
@subsection Visibility rules

Any declarations in the parent module,
including those in the parent module's implementation section,
are visible in the parent's sub-modules,
including indirect sub-modules (i.e.@: sub-sub-modules, etc.).
Similarly, declarations in the interfaces of any modules
imported using an @samp{:- import_module} or a @samp{:- use_module}
in the parent module
are visible in the parent's sub-modules, including indirect sub-modules.

Declarations in a child module are not visible in the parent module,
or in ``sibling'' modules (other children of the same parent),
or in other unrelated modules
unless the child is explicitly imported using
an @samp{:- import_module} or @samp{:- use_module} declaration.
It is an error to import a module without importing all of its parent modules.

Note that a sub-module for which
the @samp{:- module} or @samp{:- include_module} declaration
occurs only in the implementation section of the parent module
may only be imported or used by its parent module
or by sub-modules of its parent module.

Note that as mentioned previously,
all @samp{:- import_module} and @samp{:- use_module} declarations
must use fully-qualified module names.

@node Implementation bugs and limitations
@subsection Implementation bugs and limitations

The current implementation of sub-modules has a couple of minor limitations.

@itemize @bullet
@item
The compiler sometimes reports spurious errors
if you define an equivalence type in a sub-module
and export it as an abstract type.
@item
Using @samp{mmake} to do parallel makes (e.g.@: @samp{mmake --jobs 2})
doesn't always work correctly if you are using nested sub-modules.
(The work-around is to use separate sub-modules instead of nested sub-modules,
i.e.@: to put the sub-modules in separate source files.)
@end itemize

@node Module initialisation
@section Module initialisation

Modules that interact with foreign libraries or services
may require special initialisation before use.
Such modules may include any number of @samp{initialise} directives
in their implementation sections.
An @samp{initialise} directive has the following form:

@example
:- initialise @var{initpredname}/@var{arity}.
@end example

where the predicate @var{initpredname} must be declared
with one of the following signatures:

@example
:- pred @var{initpredname}(io::di, io::uo) is @var{Det}.
:- impure pred @var{initpredname} is @var{Det}.
@end example

@var{Det} must be either @code{det} or @code{cc_multi}.

The effect of the @samp{initialise} declaration
is to ensure that @samp{@var{initpredname}/@var{arity}} is invoked
before the program's @samp{main/2} predicate.
Initialisation predicates within a module are executed
in the order in which they are specified,
although no order may be assumed between different modules or sub-modules.
Initialisation predicates are only invoked
after any initialisation required by the Mercury standard library.

If @samp{@var{initpredname}/@var{arity}} terminates with an uncaught exception
then the program will immediately abort execution.
In this circumstance, those predicates specified by other @samp{initialise}
directives that have not yet been executed will not be executed,
@samp{main/2} will not be executed,
and no predicate specified in a @samp{finalise} directive will be executed.

@samp{initialize} is also allowed as a synonym for @samp{initialise}.

@node Module finalisation
@section Module finalisation

Modules that require special finalisation at program termination
may include any number of @samp{finalise} directives
in their implementation sections.

A @samp{finalise} directive has the following form:

@example
:- finalise @var{finalpredname}/@var{arity}.
@end example

where the predicate @samp{finalpredname/arity} must be declared
with one of the following signatures:

@example
:- pred @var{finalpredname}(io::di, io::uo) is @var{Det}.
:- impure pred @var{finalpredname} is @var{Det}
@end example

@var{Det} must be either @code{det} or @code{cc_multi}.

The effect of the @samp{finalise} declaration
is to ensure that @samp{@var{finalpredname}/@var{arity}} is invoked
after the program's @samp{main} predicate.
Finalisation predicates within a module
are executed in the order in which they are specified,
although no order may be assumed between different modules or sub-modules.
Any finalisation required by the Mercury standard library
will always occur after any finalisation predicates have been invoked.

If @samp{@var{finalpredname}/@var{arity}}
terminates with an uncaught exception,
then the program will immediately abort execution.
No predicates specified by other @samp{finalise} directives
that have not yet been executed will be executed.
If the program's @samp{main/2} predicate terminates with an uncaught exception,
then no finalisation predicates will be executed.

@samp{finalize} is also allowed as a synonym for @samp{finalise}.

@node Module-local mutable variables
@section Module-local mutable variables

Certain special cases require a module to have
one or more mutable (i.e. destructively updatable) variables,
for example to hold the constraint store for a solver type.

A mutable variable is declared using the @samp{mutable} directive:

@example
:- mutable(@var{varname}, @var{vartype}, @var{initial_value}, @var{varinst}, [@var{attribute}, @dots{}]).
@end example

This constructs a new mutable variable with access predicates
that have the following signatures:

@example
:- semipure pred get_@var{varname}(@var{vartype}::out(@var{varinst})) is det.
:- impure   pred set_@var{varname}(@var{vartype}::in(@var{varinst})) is det.
@end example

The initial value of @var{varname} is @var{initial_value},
which is set before the program's @samp{main/2} predicate is executed.

The type @var{vartype} is not allowed
to contain any type variables or have any type class constraints.

The inst @var{varinst} is not allowed to contain any inst variables.
It is also not allowed to be equivalent to,
or contain components that are equivalent to,
the builtin insts @code{free}, @code{unique}, @code{mostly_unique},
@code{dead} (@code{clobbered})
or @code{mostly_dead} (@code{mostly_clobbered}).

The initial value of a mutable, @var{initial_value},
may be any Mercury expression with type @var{vartype} and inst @var{varinst}
subject to the above restrictions.
It may be impure or semipure.

The following @var{attributes} must be supported:

@table @asis

@item @samp{trailed}/@samp{untrailed}
This attribute specifies whether
the implementation should generate code
to undo the effects of @samp{set_@var{varname}/1} on backtracking
(@samp{trailed}) or not (@samp{untrailed}).
The default, in case none is specified, is @samp{trailed}.

@item @samp{attach_to_io_state}
This attribute causes the compiler
to also construct access predicates that have the following signatures:

@example
:- pred get_@var{varname}(@var{vartype}::out(@var{varinst}), io::di, io::uo) is det.
:- pred set_@var{varname}(@var{vartype}::in(@var{varinst}),  io::di, io::uo) is det.
@end example

@item @samp{constant}
This attribute causes the compiler to construct
only a @samp{get} access predicate, but not a @samp{set} access predicate.
Since @var{varname} will always have the initial value given to it,
the @samp{get} access predicate is pure; its signature will be:

@example
:- pred get_@var{varname}(@var{vartype}::out(@var{varinst})) is det.
@end example

The @samp{constant} attribute cannot be specified together with
the @samp{attach_to_io_state} attribute
(since they disagree on this signature).
It also cannot be specified together with an explicit @samp{trailed} attribute.

@end table

The Melbourne Mercury compiler also supports the following attributes:

@table @asis

@item @samp{foreign_name(@var{Lang}, @var{Name})}
Allow foreign code to access the mutable variable
in some implementation dependent manner.
@var{Lang} must be a valid target language for this Mercury implementation.
@var{Name} must be a valid identifier in that language.
It is an error to specify
more than one foreign name attribute for each language.

For the C backends,
this attribute allows foreign code to access the mutable variable
as an external variable called @var{Name}.
For the low-level C backend, e.g. the asm_fast grades,
the type of this variable will be @code{MR_Word}.
For the high-level C backend, e.g. the hlc grades,
the type of this variable depends upon the Mercury type of the mutable.
For mutables of a Mercury primitive type,
the corresponding C type is given
by the mapping in @ref{C data passing conventions}.
For mutables of any other type,
the corresponding C type will be @code{MR_Word}.

This attribute is not currently implemented for the non-C backends.

@item @samp{thread_local}
This attribute allows a mutable to take on different values in each thread.
When a child thread is spawned,
it inherits all the values of thread-local mutables of the parent thread.
Changing the value of a thread-local mutable
does not affect its value in any other threads.

The @samp{thread_local} attribute cannot be specified
together with either of the @samp{trailed} or @samp{constant} attributes.

@end table

It is an error for a @samp{mutable} directive
to appear in the interface section of a module.
The usual visibility rules for sub-modules
apply to the mutable variable access predicates.

For the purposes of determining
when mutables are assigned their initial values,
the expression @var{initial_value} behaves
as though it were a predicate specified in an @samp{initialise} directive.

@example
:- initialise foo/2.
:- mutable(bar, int, 561, ground, [untrailed]).
:- initialise baz/2.
@end example

In the above example, @samp{foo/2} is invoked first,
then @samp{bar} is set with an initial value of 561
and the @samp{baz/2} is invoked.

The effect of a mutable initial value expression
terminating with an uncaught exception
is also the same as though it were
a predicate specified in an @samp{initialise} directive.

@node Type classes
@chapter Type classes

Mercury supports constrained polymorphism in the form of type classes.
Type classes allow the programmer to write predicates and functions
which operate on variables of any type (or sequence of types)
for which a certain set of operations is defined.

@menu
* Typeclass declarations::
* Instance declarations::
* Abstract typeclass declarations::
* Abstract instance declarations::
* Type class constraints on predicates and functions::
* Type class constraints on type class declarations::
* Type class constraints on instance declarations::
* Functional dependencies::
@end menu

@node Typeclass declarations
@section Typeclass declarations

A @dfn{type class} is a name for a set of types
(or a set of sequences of types)
for which certain predicates and/or functions,
called the @dfn{methods} of that type class, are defined.
A @samp{typeclass} declaration defines a new type class,
and specifies the set of predicates and/or functions
that must be defined on a type (or sequence of types)
for it (them) to be considered to be an instance of that type class.

The @code{typeclass} declaration
gives the name of the type class that it is defining,
the names of the type variables which are parameters to the type class,
and the operations (i.e.@: methods) which form the interface of the type class.
For each method, all parameters of the typeclass must be determined by
the type variables appearing in the type signature of the method.
A variable is determined by a type signature
if it appears in the type signature,
but if functional dependencies are present,
then it may also be determined from the other variables
(@pxref{Functional dependencies}).

For example,

@example
:- typeclass point(T) where [
        % coords(Point, X, Y):
        %       X and Y are the cartesian coordinates of Point
        pred coords(T, float, float),
        mode coords(in, out, out) is det,

        % translate(Point, X_Offset, Y_Offset) = NewPoint:
        %       NewPoint is Point translated X_Offset units in the X direction
        %       and Y_Offset units in the Y direction
        func translate(T, float, float) = T
].
@end example

@noindent
declares the type class @code{point},
which represents points in two dimensional space.

@code{pred}, @code{func} and @code{mode} declarations
are the only legal declarations inside a @code{typeclass} declaration.
The mode and determinism of type class methods
must be explicitly declared or (for functions) defaulted, not inferred.
In other words, for each predicate declared in a type class,
there must be at least one mode declaration,
and each mode declaration in a type class
must include an explicit determinism annotation.
Functions with no explicit mode declaration
get the usual default mode (@pxref{Modes}):
all arguments have mode @code{in}, the result has mode @code{out},
and the determinism is @code{det}.

The number of parameters to the type class (e.g.@: @code{T}) is not limited.
For example, the following is allowed:

@example
:- typeclass a(T1, T2) where [@dots{}].
@end example

The parameters must be distinct variables.
Each @code{typeclass} declaration must have at least one parameter.

It is legal for a @code{typeclass} declaration to declare no methods,
for example

@example
:- typeclass foo(T) where [].
@end example

There must not be more than one type class declaration
with the same name and arity in the same module.

@node Instance declarations
@section Instance declarations

Once the interface of the type class
has been defined in the @code{typeclass} declaration,
we can use an @code{instance} declaration
to define how a particular type (or sequence of types)
satisfies the interface declared in the @code{typeclass} declaration.

An instance declaration has the form

@example
:- instance @var{classname}(@var{typename}(@var{typevar}, @dots{}), @dots{})
        where [@var{methoddefinition}, @var{methoddefinition}, @dots{}].
@end example

An @samp{instance} declaration
gives a type for each parameter of the type class.
Each of these types must be either a type with no arguments,
or a polymorphic type whose arguments are all type variables.
@c If this restriction is ever lifted, the algorithms for encoding the names of
@c the data structures describing the instance, in base_typeclass_info.m
@c and/or rtti.m, would need to be updated as well.
For example @code{int}, @code{list(T)},
@code{bintree(K, V)} and @code{bintree(T, T)} are allowed,
but @code{T} and @code{list(int)} are not.
The types in an instance declaration must not be abstract types
which are elsewhere defined as equivalence types.
A program may not contain
more than one instance declaration for a particular type
(or sequence of types, in the case of a multi-parameter type class)
and typeclass.
These restrictions ensure that there are no overlapping instance declarations,
i.e.@: for each typeclass there is at most one instance declaration
that may be applied to any type (or sequence of types).

Each @var{methoddefinition} entry
in the @samp{where [@dots{}]} part of an @code{instance} declaration
defines the implementation of one of the class methods for this instance.
There are two ways of defining methods.
The first way is to define a method
by giving the name of the predicate or function which implements that method.
In this case, the @var{methoddefinition} must have one of the following forms:

@example
pred(@var{methodname}/@var{arity}) is @var{predname}
func(@var{methodname}/@var{arity}) is @var{funcname}
@end example

@noindent
The @var{predname} or @var{funcname} must name
a predicate or function of the specified arity
whose type, modes, determinism, and purity are at least as permissive
as the declared type, modes, determinism, and purity
of the class method with the specified @var{methodname} and @var{arity},
after the types of the arguments in the instance declaration
have been substituted in place of the parameters in the type class declaration.

The second way of defining methods is
by listing the clauses for the definition inside the instance declaration.
A @var{methoddefinition} can be a clause.
These clauses are just like the clauses
used to define ordinary predicates or functions (@pxref{Items}),
and so they can be facts, rules, or DCG rules.
The only difference is that in instance declarations,
clauses are separated by commas rather than being terminated by periods,
and so rules and DCG rules in instance declarations
must normally be enclosed in parentheses.
As with ordinary predicates,
you can have more than one clause for each method.
The clauses must satisfy
the declared type, modes, determinism and purity for the method,
after the types of the arguments in the instance declaration
have been substituted in place of the parameters in the type class declaration.

These two ways are mutually exclusive:
each method must be defined either by a single naming definition
(using the @samp{pred(@dots{}) is @var{predname}}
or @samp{func(@dots{}) is @var{funcname}} form),
or by a set of one or more clauses, but not both.

Here is an example of an instance declaration
and the different kinds of method definitions that it can contain:

@example
@group
:- typeclass foo(T) where [
    func method1(T, T) = int,
    func method2(T) = int,
    pred method3(T::in, int::out) is det,
    pred method4(T::in, io.state::di, io.state::uo) is det,
    func method5(bool, T) = T
].

:- instance foo(int) where [
    % method defined by naming the implementation
    func(method1/2) is (+),

    % method defined by a fact
    method2(X) = X + 1,

    % method defined by a rule
    (method3(X, Y) :- Y = X + 2),

    % method defined by a DCG rule
    (method4(X) --> io.print(X), io.nl),

    % method defined by multiple clauses
    method5(no, _) = 0,
    (method5(yes, X) = Y :- X + Y = 0)
].
@end group
@end example

Each @samp{instance} declaration
must define an implementation for every method
declared in the corresponding @samp{typeclass} declaration.
It is an error to define more than one implementation
for the same method within a single @samp{instance} declaration.

Any call to a method must have argument types
(and in the case of functions, return type)
which are constrained to be a member of that method's type class,
or which match one of the instance declarations
visible at the point of the call.
A method call will invoke the predicate or function
specified for that method in the instance declaration
that matches the types of the arguments to the call.

Note that even if a type class has no methods,
an explicit instance declaration is required
for a type to be considered an instance of that type class.

Here is an example of some code using an instance declaration:

@example
:- type coordinate
    --->    coordinate(
                float,  % X coordinate
                float   % Y coordinate
            ).

:- instance point(coordinate) where [
    pred(coords/3) is coordinate_coords,
    func(translate/3) is coordinate_translate
].

:- pred coordinate_coords(coordinate, float, float).
:- mode coordinate_coords(in, out, out) is det.

coordinate_coords(coordinate(X, Y), X, Y).

:- func coordinate_translate(coordinate, float, float) = coordinate.

coordinate_translate(coordinate(X, Y), Dx, Dy) = coordinate(X + Dx, Y + Dy).
@end example

We have now made the @code{coordinate} type
an instance of the @code{point} type class.
If we introduce a new type @code{coloured_coordinate}
which represents a point in two dimensional space
with a colour associated with it,
it can also become an instance of the type class:

@example
:- type rgb
    --->    rgb(
                int,
                int,
                int
            ).

:- type coloured_coordinate
    --->    coloured_coordinate(
                float,
                float,
                rgb
            ).

:- instance point(coloured_coordinate) where [
    pred(coords/3) is coloured_coordinate_coords,
    func(translate/3) is coloured_coordinate_translate
].

:- pred coloured_coordinate_coords(coloured_coordinate, float, float).
:- mode coloured_coordinate_coords(in, out, out) is det.

coloured_coordinate_coords(coloured_coordinate(X, Y, _), X, Y).

:- func coloured_coordinate_translate(coloured_coordinate, float, float)
    = coloured_coordinate.

coloured_coordinate_translate(coloured_coordinate(X, Y, Colour), Dx, Dy)
    = coloured_coordinate(X + Dx, Y + Dy, Colour).
@end example

If we call @samp{translate/3}
with the first argument having type @samp{coloured_coordinate},
this will invoke @samp{coloured_coordinate_translate}.
Likewise, if we call @samp{translate/3}
with the first argument having type @samp{coordinate},
this will invoke @samp{coordinate_translate}.

Further instances of the type class could be made,
e.g.@: a type that represents the point using polar coordinates.

@node Abstract typeclass declarations
@section Abstract typeclass declarations

Abstract typeclass declarations
are typeclass declarations whose definitions are hidden.
An abstract typeclass declaration has the same form as a typeclass declaration,
but without the @samp{where[@dots{}]} part.
An abstract typeclass declaration defines
a name for a set of (sequences of) types,
but does not define what methods must be implemented
for instances of the type class.

Like abstract type declarations,
abstract typeclass declarations are only useful
in the interface section of a module.
Each abstract typeclass declaration must be accompanied
by a corresponding non-abstract typeclass declaration
that defines the methods for that type class.

Non-abstract instance declarations can only be made
in scopes where the non-abstract typeclass declaration is visible.

@node Abstract instance declarations
@section Abstract instance declarations

Abstract instance declarations are
instance declarations whose implementations are hidden.
An abstract instance declaration has the same form as an instance declaration,
but without the @samp{where [@dots{}]} part.
An abstract instance declaration declares that
a sequence of types is an instance of a particular type class
without defining how the type class methods are implemented for those types.
Like abstract type declarations,
abstract instance declarations are only useful
in the interface section of a module.
Each abstract instance declaration must be accompanied
by a corresponding non-abstract instance declaration
that defines how the type class methods are implemented.

Here is an example:

@example
:- module hashable.
:- interface.
:- import_module int, string.

:- typeclass hashable(T) where [func hash(T) = int].
:- instance hashable(int).
:- instance hashable(string).

:- implementation.

:- instance hashable(int) where [func(hash/1) is hash_int].
:- instance hashable(string) where [func(hash/1) is hash_string].

:- func hash_int(int) = int.
hash_int(X) = X.

:- func hash_string(string) = int.
hash_string(S) = H :-
    % Use the standard library predicate string.hash/2.
    string.hash(S, H).

:- end_module hashable.
@end example

@node Type class constraints on predicates and functions
@section Type class constraints on predicates and functions

Mercury allows a type class constraint
to appear as part of a predicate or function's type signature.
This constrains the values that can be taken by type variables
in the signature to belong to particular type classes.

A type class constraint has the form:

@example
<= @var{Typeclass}(@var{Type}, @dots{}), @dots{}
@end example

@noindent
where @var{Typeclass} is the name of a type class and @var{Type} is a type.
Any variable that appears in @var{Type} must be determined
by the predicate's or function's type signature.
A variable is determined by a type signature
if it appears in the type signature,
but if functional dependencies are present,
then it may also be determined from other variables
(@pxref{Functional dependencies}).
Each type class constraint in a predicate or function declaration
must contain at least one variable.

For example

@example
:- pred distance(P1, P2, float) <= (point(P1), point(P2)).
:- mode distance(in, in, out) is det.

distance(A, B, Distance) :-
    coords(A, Xa, Ya),
    coords(B, Xb, Yb),
    XDist = Xa - Xb,
    YDist = Ya - Yb,
    Distance = sqrt(XDist*XDist + YDist*YDist).
@end example

In the above example,
the @code{distance} predicate
is able to calculate the distance between any two points,
regardless of their representation,
as long as the @code{coords} operation has been defined.
These constraints are checked at compile time.

@node Type class constraints on type class declarations
@section Type class constraints on type class declarations

Type class constraints may also appear in @code{typeclass} declarations,
meaning that one type class is a ``superclass'' of another.

The arguments of a constraint on a type class declaration
must be either type variables or ground types.
Each constraint must contain at least one variable argument
and all variables that appear in the arguments
must also be arguments to the type class in question.

For example, the following declares the @samp{ring} type class,
which describes types with a particular set of numerical operations defined:

@example
:- typeclass ring(T) where [
    func zero = (T::out) is det,               % '+' identity
    func one = (T::out) is det,                % '*' identity
    func plus(T::in, T::in) = (T::out) is det, % '+'/2 (forward mode)
    func mult(T::in, T::in) = (T::out) is det, % '*'/2 (forward mode)
    func negative(T::in) = (T::out) is det     % '-'/1 (forward mode)
].
@end example

We can now add the following declaration:

@example
@group
:- typeclass euclidean(T) <= ring(T) where [
    func div(T::in, T::in) = (T::out) is det,
    func mod(T::in, T::in) = (T::out) is det
].
@end group
@end example

This introduces a new type class, @code{euclidean},
of which @code{ring} is a superclass.
The operations defined by the @code{euclidean} type class
are @code{div}, @code{mod},
as well as all those defined by the @code{ring} type class.
Any type declared to be an instance of @code{euclidean}
must also be declared to be an instance of @code{ring}.

Type class constraints on type class declarations
gives rise to a superclass relation.
This relation must be acyclic.
That is, it is an error
if a type class is its own (direct or indirect) superclass.

@node Type class constraints on instance declarations
@section Type class constraints on instance declarations

Type class constraints may also be placed upon instance declarations.
The arguments of such constraints
must be either type variables or ground types.
Each constraint must contain at least one variable argument
and all variables that appear in the arguments
must be type variables that appear in the types in the instance declaration.

For example, consider the following declaration
of a type class of types that may be printed:

@example
:- typeclass portrayable(T) where [
    pred portray(T::in, io.state::di, io.state::uo) is det
].
@end example

The programmer could declare instances such as

@example
:- instance portrayable(int) where [
    pred(portray/3) is io.write_int
].

:- instance portrayable(char) where [
    pred(portray/3) is io.write_char
].
@end example

However, when it comes to writing the instance declaration
for a type such as @code{list(T)},
we want to be able print out the list elements
using the @code{portray/3} for the particular type of the list elements.
This can be achieved by
placing a type class constraint on the @code{instance} declaration,
as in the following example:

@example
:- instance portrayable(list(T)) <= portrayable(T) where [
    pred(portray/3) is portray_list
].

:- pred portray_list(list(T), io.state, io.state) <= portrayable(T).
:- mode portray_list(in, di, uo) is det.

portray_list([], !IO).
portray_list([X | Xs], !IO) :-
    portray(X, !IO),
    io.write_char(' ', !IO),
    portray_list(Xs, !IO).
@end example

For abstract instance declarations,
the type class constraints on an abstract instance declaration
must exactly match the type class constraints
on the corresponding non-abstract instance declaration
that defines that instance.
@c XXX The current implementation does not enforce that rule.

@node Functional dependencies
@section Functional dependencies

Type class constraints may include any number of functional dependencies.
A @dfn{functional dependency} constraint
takes the form @code{(@var{Domain} -> @var{Range})}.
The @var{Domain} and @var{Range} arguments are either single type variables,
or conjunctions of type variables separated by commas.

@example
	:- typeclass @var{Typeclass}(@var{Var}, @dots{})@
<= ((@var{D} -> @var{R}), @dots{}) @dots{}

	:- typeclass @var{Typeclass}(@var{Var}, @dots{})@
<= (@var{D1}, @var{D2}, @dots{} -> @var{R1}, @var{R2}, @dots{}), @dots{}
@end example

Each type variable must appear in the parameter list of the typeclass.
Abstract typeclass declarations must have
exactly the same functional dependencies as in the implementation.

Mutually recursive functional dependencies are allowed,
so the following examples are legal:

@example
	:- typeclass foo(A, B) <= ((A -> B), (B -> A)).
	:- typeclass bar(A, B, C, D)@
<= ((A, B -> C), (B, C -> D), (D -> A, C)).
@end example

A functional dependency on a typeclass places an additional requirement
on the set of instances which are allowed for that type class.
The requirement is that
all types bound to variables in the range of the functional dependency
must be able to be uniquely determined
by the types bound to variables in the domain of the functional dependency.
If more than one functional dependency is present,
then the requirement for each one must be satisfied.

For example, given the typeclass declaration

@example
:- typeclass baz(A, B) <= (A -> B) where @dots{}
@end example

@noindent
it would be illegal to have both of the instances

@example
:- instance baz(int, int) where @dots{}
:- instance baz(int, string) where @dots{}
@end example

@noindent
although either one would be acceptable on its own.

The following instance would also be illegal

@example
:- instance baz(string, list(T)) where @dots{}
@end example

@noindent
since the variable @code{T} may not always be bound to the same type.
However, the instance

@example
:- instance baz(list(S), list(T)) <= baz(S, T) where @dots{}
@end example

is legal because
the @samp{baz(S, T)} constraint ensures that
whatever @code{T} is bound to,
it is always uniquely determined from the binding of @code{S}.

The extra requirements that result from the use of functional dependencies
allow the bindings of some variables
to be determined from the bindings of others.
This in turn relaxes some of the requirements
of typeclass constraints on predicate and function signatures,
and on existentially typed data constructors.

Without any functional dependencies, all variables in constraints
must appear in the signature of the predicate or function being declared.
However, variables which are in the range of a functional dependency
need not appear in the signature,
since it is known that their bindings will be determined
from the bindings of the variables in the domain.

More formally, the constraints on a predicate or function signature
@emph{induce} a set of functional dependencies
on the variables appearing in those constraints.
A functional dependency @samp{(A1, @dots{} -> B1, @dots{})}
is induced from a constraint
@samp{@var{Typeclass}(@var{Type1}, @dots{})}
if and only if the typeclass @samp{@var{Typeclass}}
has a functional dependency @samp{(D1, @dots{} -> R1, @dots{})},
and for each typeclass parameter @samp{Di} there exists an @samp{Aj}
every type variable appearing in the @samp{@var{Typek}}
corresponding to @samp{Di},
and each @samp{Bi} appears in the @samp{@var{Typej}}
bound to the typeclass parameter @samp{Rk} for some @var{k}.

For example, with the definition of @code{baz} above,
the constraint @code{baz(map(X, Y), list(Z))}
induces the constraint @code{(X, Y -> Z)},
since @var{X} and @var{Y} appear in the domain argument,
and @var{Z} appears in the range argument.

The set of type variables determined from a signature
is the @emph{closure} of the set appearing in the signature
under the functional dependencies induced from the constraints.
The closure is defined as the smallest set of variables
which includes all of the variables appearing in the signature,
and is such that, for each induced functional dependency
@samp{@var{Domain} -> @var{Range}},
if the closure includes all of the variables in @var{Domain}
then it includes all of the variables in @var{Range}.

For example, the declaration

@example
:- pred p(X, Y) <= baz(map(X, Y), list(Z)).
@end example

@noindent
is acceptable since the closure of @{@var{X},
@var{Y}@} under the induced functional dependency must include @var{Z}.
Moreover, the typeclass @code{baz/2} would be allowed
to have a method that only uses the first parameter, @var{A},
since the second parameter, @var{B}, would always be determined from the first.

Note that, since all instances must satisfy the superclass constraints,
the restrictions on instances obviously transfer from superclass to subclass.
Again, this allows the requirements of typeclass constraints to be relaxed.
Thus, the functional dependencies on the ancestors of constraints
also induce functional dependencies on the variables,
and the closure that we calculate takes these into account.

For example, in this code

@example
:- typeclass quux(P, Q, R) <= baz(R, P) where @dots{}

:- pred q(Q, R) <= quux(P, Q, R).
@end example
the signature of @code{q/2} is acceptable
since the superclass constraint on @code{quux/2}
induces the dependency @samp{R -> P} on the type variables,
hence @var{P} is in the closure of @{@var{Q}, @var{R}@}.

The presence of functional dependencies
also allows ``improvement'' to occur during type inference.
This can occur in two ways.
First, if two constraints of a given class match
on all of the domain arguments of a functional dependency on that class,
then it can be inferred that they also match on the range arguments.
For example,
given the constraints @w{@code{baz(A, B1)}} and @w{@code{baz(A, B2)}},
it will be inferred that @code{B1 = B2}.

Similarly, if a constraint of a given class
is subsumed by a known instance of that class in the domain arguments,
then its range arguments can be unified
with the corresponding instance range arguments.
For example, given the instance:

@example
:- instance baz(list(T), string) where @dots{}
@end example

@noindent
then the constraint @code{baz(list(int), X)}
can be improved with the inference that @w{@code{X = string}}.

@node Existential types
@chapter Existential types

Existentially quantified type variables
(or simply ``existential types'' for short)
are useful tools for data abstraction.
In combination with type classes,
they allow you to write code in an ``object oriented'' style
that is similar to the use of interfaces in Java
or abstract base classes in C++.

Mercury supports existential type quantifiers
on predicate and function declarations, and in data type definitions.
You can put type class constraints on existentially quantified type variables.

@menu
* Existentially typed predicates and functions::
* Existential class constraints::
* Existentially typed data types::
* Some idioms using existentially quantified types::
@end menu

@node Existentially typed predicates and functions
@section Existentially typed predicates and functions

@menu
* Syntax for explicit type quantifiers::
* Semantics of type quantifiers::
* Examples of correct code using type quantifiers::
* Examples of incorrect code using type quantifiers::
@end menu

@node Syntax for explicit type quantifiers
@subsection Syntax for explicit type quantifiers

Type variables in type declarations for polymorphic predicates or functions
are normally universally quantified.
However, it is also possible to existentially quantify such type variables,
by using an explicit existential quantifier of the form @samp{some @var{Vars}}
before the @samp{pred} or @samp{func} declaration,
where @var{Vars} is a list of variables.

For example:

@example
% Here the type variables `T' is existentially quantified
:- some [T] pred foo(T).

% Here the type variables `T1' and `T2' are existentially quantified.
:- some [T1, T2] func bar(int, list(T1), set(T2)) = pair(T1, T2).

% Here the type variable `T2' is existentially quantified,
% but the type variables `T1' and `T3' are universally quantified.
:- some [T2] pred foo(T1, T2, T3).
@end example

Explicit universal quantifiers, of the form @samp{all @var{Vars}},
are also permitted on @samp{pred} and @samp{func} declarations,
although they are not necessary, since universal quantification is the default.
(If both universal and existential quantifiers are present,
the universal quantifiers must precede the existential quantifiers.)
For example:

@example
% Here the type variable `T2' is existentially quantified,
% but the type variables `T1' and `T3' are universally quantified.
:- all [T3] some [T2] pred foo(T1, T2, T3).
@end example

@node Semantics of type quantifiers
@subsection Semantics of type quantifiers

If a type variable in the type declaration
for a polymorphic predicate or function is universally quantified,
this means the caller will determine the value of the type variable,
and the callee must be defined so that it will work
for @emph{all} types which are an instance of its declared type.

For an existentially quantified type variable,
the situation is the converse:
the @emph{callee} must determine the value of the type variable,
and all @emph{callers} must be defined so as to work
for all types which are an instance of the called procedure's declared type.

When type checking a predicate or function,
if a variable has a type that occurs
as a universally quantified type variable
in the predicate or function declaration,
or a type that occurs as an existentially quantified type variable
in the declaration of one of the predicates or functions that it calls,
then its type is treated as an opaque type.
This means that there are very few things
which it is legal to do with such a variable ---
basically you can only pass it to another procedure expecting the same type,
unify it with another value of the same type,
put it in a polymorphic data structure,
or pass it to a polymorphic procedure
whose argument type is universally quantified.
(Note, however, that the standard library includes some quite powerful
procedures such as @samp{io.write} which can be useful in this context.)

A non-variable type (i.e.@: a type that is not a type variable)
is considered @emph{more general}
than an existentially quantified type variable.
Type inference will therefore never infer
an existentially quantified type for a predicate or function
unless that predicate or function calls (directly or indirectly)
a predicate or function which was explicitly declared
to have an existentially quantified type.

Note that an existentially typed procedure
is not allowed to have different types
for its existentially typed arguments in different clauses
(even mode-specific clauses)
or in different subgoals of a single clause;
however, the same effect can be achieved in other ways
(@pxref{Some idioms using existentially quantified types}).

For procedures involving calls to existentially-typed predicates or functions,
the compiler's mode analysis must take account
of the modes for type variables in all polymorphic calls.
Universally quantified type variables have mode @code{in},
whereas existentially quantified type variables have mode @code{out}.
As usual, the compiler's mode analysis
will attempt to reorder the elements of conjunctions
in order to satisfy the modes.

@node Examples of correct code using type quantifiers
@subsection Examples of correct code using type quantifiers

Here are some examples of type-correct code
using universal and existential types.

@example
/* simple examples */

:- pred foo(T).
foo(_).
	% ok

:- pred call_foo.
call_foo :- foo(42).
	% ok (T = int)

:- some [T] pred e_foo(T).
e_foo(X) :- X = 42.
	% ok (T = int)

:- pred call_e_foo.
call_e_foo :- e_foo(_).
	% ok

/* examples using higher-order functions */

:- func bar(T, T, func(T) = int) = int.
bar(X, Y, F) = F(X) + F(Y).
	% ok

:- func call_bar = int.
call_bar = bar(2, 3, (func(X) = X*X)).
	% ok (T = int)
	% returns 13 (= 2*2 + 3*3)

:- some [T] pred e_bar(T, T, func(T) = int).
:-          mode e_bar(out, out, out(func(in) = out is det)).
e_bar(2, 3, (func(X) = X * X)).
	% ok (T = int)

:- func call_e_bar = int.
call_e_bar = F(X) + F(Y) :- e_bar(X, Y, F).
	% ok
	% returns 13 (= 2*2 + 3*3)

@end example

@node Examples of incorrect code using type quantifiers
@subsection Examples of incorrect code using type quantifiers

Here are some examples of code using universal and existential types
that contains type errors.

@example
/* simple examples */

:- pred bad_foo(T).
bad_foo(42).
	% type error

:- some [T] pred e_foo(T).
e_foo(42).
	% ok

:- pred bad_call_e_foo.
bad_call_e_foo :- e_foo(42).
	% type error

:- some [T] pred e_bar1(T).
e_bar1(42).
e_bar1(42).
e_bar1(43).
	% ok (T = int)

:- some [T] pred bad_e_bar2(T).
bad_e_bar2(42).
bad_e_bar2("blah").
	% type error (cannot unify types `int' and `string')

:- some [T] pred bad_e_bar3(T).
bad_e_bar3(X) :- e_foo(X).
bad_e_bar3(X) :- e_foo(X).
	% type error (attempt to bind type variable `T' twice)

@end example

@node Existential class constraints
@section Existential class constraints

Existentially quantified type variables
are especially useful in combination with type class constraints.

Type class constraints can be either universal or existential.
Universal type class constraints are written using @samp{<=},
as described in @ref{Type class constraints on predicates and functions};
they signify a constraint that the @emph{caller} must satisfy.
Existential type class constraints are written in the same syntax
as universal constraints, but using @samp{=>} instead of @samp{<=};
they signify a constraint that the @emph{callee} must satisfy.
If a declaration has both universal and existential constraints,
then the existential constraints must precede the universal constraints.

For example:

@example
% Here `c1(T2)' and `c2(T2)' are existential constraints,
% and `c3(T1)' is a universal constraint,
:- all [T1] some [T2] ((pred p(T1, T2) => (c1(T2), c2(T2))) <= c3(T1)).
@end example

Existential constraints must only constrain type variables
that are explicitly existentially quantified.
Likewise, universal constraints must only constrain type variables
that are universally quantified,
although in this case the quantification does not have to be explicit
because universal quantification is the default
(see @ref{Syntax for explicit type quantifiers}).

@node Existentially typed data types
@section Existentially typed data types

Type variables occurring in the body of a discriminated union type
definition may be existentially quantified.
Constructor definitions within discriminated union type definitions
may be preceded by an existential type quantifier
and followed by one or more existential type class constraints.

For example:

@example
% A simple heterogeneous list type.
:- type list_of_any
    --->    nil_any
    ;       some [T] cons_any(T, list_of_any).

% A heterogeneous list type with a type class constraint.
:- typeclass showable(T) where [ func show(T) = string ].
:- type showable_list
    --->    nil
    ;       some [T] (cons(T, showable_list) => showable(T)).

% A different way of doing the same kind of thing, this
% time using the standard type list(T).
:- type showable
    --->    some [T] (s(T) => showable(T)).
:- type list_of_showable == list(showable).

% Here's an arbitrary example involving multiple
% type variables and multiple constraints.
:- typeclass foo(T1, T2) where [ /* @dots{} */ ].
:- type bar(T)
    --->    f1
    ;       f2(T)
    ;       some [T]
            f4(T)
    ;       some [T1, T2]
            (f4(T1, T2, T) => showable(T1), showable(T2))
    ;       some [T1, T2]
            (f5(list(T1), T2) => fooable(T1, list(T2))).
@end example

Construction and deconstruction of existentially quantified data types
are inverses:
when constructing a value of an existentially quantified data type,
the ``existentially quantified'' functor acts
for purposes of type checking like a universally quantified function:
the caller will determine the values of the type variables.
Conversely, for deconstruction the functor acts
like an existentially quantified function:
the caller must be defined so as to work
for all possible values of the existentially quantified type variables
which satisfy the declared type class constraints.

In order to make this distinction clear to the compiler,
whenever you want to construct a value
using an existentially quantified functor,
you must prepend @samp{new } onto the functor name.
This tells the compiler to treat it as though it were universally quantified:
the caller can bind that functor's existentially quantified type variables
to any type which satisfies the declared type class constraints.
Conversely, any occurrence without the @samp{new } prefix
must be a deconstruction, and is therefore existentially quantified:
the caller must not bind the existentially quantified type variables,
but the caller is allowed to depend on those type variables
satisfying the declared type class constraints, if any.

For example, the function @samp{make_list} constructs
a value of type @samp{list_of_showable}
containing a sequence of values of different types,
all of which are instances of the @samp{showable} class

@example
:- instance showable(int).
:- instance showable(float).
:- instance showable(string).

:- func make_list = showable_list.
make_list = List :-
	Int = 42,
	Float = 1.0,
	String = "blah",
	List =  'new cons'(Int,
		'new cons'(Float,
		'new cons'(String, nil))).
@end example

@noindent
while the function @samp{process_list} below
applies the @samp{show} method of the @samp{showable} class
to the values in such a list.

@example
:- func process_list(list_of_showable) = list(string).
process_list(nil) = "".
process_list(cons(Head, Tail)) = [show(Head) | process_list(Tail)].
@end example

@node Some idioms using existentially quantified types
@section Some idioms using existentially quantified types

The standard library module @samp{univ}
provides an abstract type named @samp{univ} which can hold values of any type.
You can form heterogeneous containers
(containers that can hold values of different types at the same time)
by using data structures that contain @code{univ}s, e.g.@: @samp{list(univ)}.

The interface to @samp{univ} includes the following:

@example
% `univ' is a type which can hold any value.
:- type univ.

% The function univ/1 takes a value of any type and constructs
% a `univ' containing that value (the type will be stored along
% with the value)
:- func univ(T) = univ.

% The function univ_value/1 takes a `univ' argument and extracts
% the value contained in the `univ' (together with its type).
% This is the inverse of the function univ/1.
:- some [T] func univ_value(univ) = T.
@end example

The @samp{univ} type in the standard library
is in fact a simple example of an existentially typed data type.
It could be implemented as follows:

@example
:- implementation.
:- type univ
    --->    some [T] mkuniv(T).
univ(X) = 'new mkuniv'(X).
univ_value(mkuniv(X)) = X.
@end example

An existentially typed procedure
is not allowed to have different types for its existentially typed arguments
in different clauses or in different subgoals of a single clause.
For instance, both of the following examples are illegal:

@example
:- some [T] pred bad_example(string, T).

bad_example("foo", 42).
bad_example("bar", "blah").
    % type error (cannot unify `int' and `string')

:- some [T] pred bad_example2(string, T).

bad_example2(Name, Value) :-
    ( Name = "foo", Value = 42
    ; Name = "bar", Value = "blah"
    ).
    % type error (cannot unify `int' and `string')
@end example

However, using @samp{univ},
it is possible for an existentially typed function
to return values of different types at each invocation.

@example
:- some [T] pred good_example(string, T).

good_example(Name, univ_value(Univ)) :-
    ( Name = "foo", Univ = univ(42)
    ; Name = "bar", Univ = univ("blah")
    ).
@end example

Using @samp{univ} doesn't work if you also want to use type class constraints.
If you want to use type class constraints,
then you must define your own existentially typed data type,
analogous to @samp{univ}, and use that:

@example
:- type univ_showable
    --->    some [T] (mkshowable(T) => showable(T)).

:- some [T] pred harder_example(string, T) => showable(T).

harder_example(Name, Showable) :-
    ( Name = "bar", Univ = 'new mkshowable'(42)
    ; Name = "bar", Univ = 'new mkshowable'("blah")
    ),
    Univ = mkshowable(Showable).
@end example

The issue can also arise for mode-specific clauses
(@pxref{Different clauses for different modes}).
For instance, the following example is illegal:

@example
:- some [T] pred bad_example3(string, T).
:-         mode bad_example3(in(bound("foo")), out) is det.
:-          mode bad_example3(in(bound("bar")), out) is det.
:- pragma promise_pure(bad_example3/2).
bad_example3("foo"::in(bound("foo")), 42::out).
bad_example3("bar"::in(bound("bar")), "blah"::out).
    % type error (cannot unify `int' and `string')
@end example

The solution is similar,
although in this case an intermediate predicate is required:

@example
:- some [T] pred good_example3(string, T).
:-          mode good_example3(in(bound("foo")), out) is det.
:-          mode good_example3(in(bound("bar")), out) is det.
good_example3(Name, univ_value(Univ)) :-
	good_example3_univ(Name, Univ).

:- pred good_example3_univ(string, univ).
:- mode good_example3_univ(in(bound("foo")), out) is det.
:- mode good_example3_univ(in(bound("bar")), out) is det.
:- pragma promise_pure(good_example3_univ/2).
good_example3_univ("foo"::in(bound("foo")), univ(42)::out).
good_example3_univ("bar"::in(bound("bar")), univ("blah")::out).
@end example

@node Exception handling
@chapter Exception handling

Mercury procedures may throw exceptions.
Exceptions may be caught
using the predicates defined in the @samp{exception} library module,
or using try goals.

@noindent
A @samp{try} goal has the following form:

@example
    try @var{Params} @var{Goal}
    then @var{ThenGoal}
    else @var{ElseGoal}
    catch @var{Term} -> @var{CatchGoal}
    @dots{}
    catch_any @var{CatchAnyVar} -> @var{CatchAnyGoal}
@end example

@var{Goal}, @var{ThenGoal}, @var{ElseGoal}, @var{CatchGoal},
@var{CatchAnyGoal} must be valid goals.

@var{Goal} must have one of the following determinisms:
@code{det}, @code{semidet}, @code{cc_multi}, or @w{@code{cc_nondet}}.

The non-local variables of @var{Goal}
must not have an inst equivalent to
@code{unique}, @w{@code{mostly_unique}} or @code{any},
unless they have the type @samp{io.state}.
@c or (later) the store/1.)

@var{Params} must be a valid list of zero or more try parameters.

The ``then'' part is mandatory.
The ``else'' part is mandatory if @var{Goal} may fail;
otherwise it must be omitted.
There may be zero or more ``catch'' branches.
The ``catch_any'' part is optional.
@var{CatchAnyVar} must be a single variable.

The try parameter @samp{io} takes a single argument,
which must be the name of a state variable prefixed by @samp{!};
for example, @samp{io(!IO)}.
The state variable must have the type @samp{io.state},
and be in scope of the try goal.
The state variable is threaded through @var{Goal},
so it may perform I/O but cannot fail.
If no @samp{io} parameter exists, @var{Goal} may not perform I/O and may fail.

A try goal has determinism @code{cc_multi}.
@c Exception: if all of the then/else/catch/catch_any parts only succeed
@c without binding non-local variables then the determinism is det.
@c In the implementation we may still infer cc_multi though.

On entering a try goal, @var{Goal} is executed.
If it succeeds without throwing an exception, @var{ThenGoal} is executed.
Any variables bound by @var{Goal} are visible in @var{ThenGoal} only.
If @var{Goal} fails, then @var{ElseGoal} is executed.

If @var{Goal} throws an exception,
the exception value is unified with
each of the @var{Term}s in the ``catch'' branches in turn.
On the first successful unification,
the corresponding @var{CatchGoal} is executed
(and other ``catch'' and ``catch_any'' branches ignored).
Variables bound during the unification of the @var{Term}
are in scope of the corresponding @var{CatchGoal}.

If the exception value does not unify
with any of the terms in ``catch'' branches,
and a ``catch_any'' branch is present,
the exception is bound to @var{CatchAnyVar}
and the @var{CatchAnyGoal} executed.
@var{CatchAnyVar} is visible in the @var{CatchAnyGoal} only,
and is existentially typed, i.e. it has type @samp{some [T] T}.

Finally, if the thrown value did not unify with any ``catch'' term,
and there is no ``catch_any'' branch, the exception is rethrown.

@noindent
The declarative semantics of a try goal is:

@example
@group
    (
        try [] Goal
        then Then
        else Else
        catch CP1 -> CG1
        catch CP2 -> CG2
        @dots{}
        catch_any CAV -> CAG
    )
    <=>
    (
        Goal, Then
    ;
        not Goal, Else
    ;
        some [Excp]
        ( if Excp = CP1 then
            CG1
        else if Excp = CP2 then
            CG2
        else if @dots{}
            @dots{}
        else
            Excp = CAV,
            CAG
        )
    ).
@end group
@end example

If no @samp{else} branch is present, then @samp{Else = fail}.
If no @samp{catch_any} branch is present, then @samp{CAG = fail}.

@noindent
An example of a try goal that performs I/O is:

@example
:- pred p_carefully(io::di, io::uo) is cc_multi.

p_carefully(!IO) :-
    (try [io(!IO)] (
        io.write_string("Calling p\n", !IO),
        p(Output, !IO)
    )
    then
        io.write_string("p returned: ", !IO),
        io.write(Output, !IO),
        io.nl(!IO)
    catch S ->
        io.write_string("p threw a string: ", !IO),
        io.write_string(S, !IO),
        io.nl(!IO)
    catch 42 ->
        io.write_string("p threw 42\n", !IO)
    catch_any Other ->
        io.write_string("p threw something: ", !IO),
        io.write(Other, !IO),
        % Rethrow the value.
        throw(Other)
    ).
@end example

@node Semantics
@chapter Semantics

A legal Mercury program is one that complies with the syntax,
type, mode, determinism, and module system rules specified in earlier chapters.
If a program does not comply with those rules,
the compiler must report an error.

For each legal Mercury program,
there is an associated predicate calculus theory
whose language is specified by the type declarations in the program
and whose axioms are the completion of the clauses for all predicates
in the program,
plus the usual equality axioms extended with the completion of the
equations for all functions in the program,
plus axioms corresponding to the mode-determinism assertions
(@pxref{Determinism}),
plus axioms specifying the semantics of library predicates and functions.
The declarative semantics of a legal Mercury program
is specified by this theory.

Mercury implementations must be sound:
the answers they compute must be true in every model of the theory.
Mercury implementations are not required to be complete:
they may fail to compute an answer in finite time,
or they may exhaust the resource limitations of the execution
environment, even though an answer is provable in the theory.
However, there are certain minimum requirements that they
must satisfy with respect to completeness.

There is an operational semantics of Mercury programs called the
@dfn{strict sequential} operational semantics.  In this semantics,
the program is executed top-down, starting from @samp{main/2}
preceded by any module initialisation goals
(as per @ref{Module initialisation}), followed by any module finalisation
goals (as per @ref{Module finalisation}),
and function calls within a goal, conjunctions and disjunctions are all
executed in depth-first left-to-right order.
Conjunctions and function calls are
``minimally'' reordered as required by the modes:
the order is determined by selecting the first mode-correct sub-goal
(conjunct or function call),
executing that, then selecting the first of the remaining sub-goals
which is now mode-correct, executing that, and so on.
(There is no interleaving of different individual conjuncts or function calls,
however; the sub-goals are reordered, not split and interleaved.)
Function application is strict, not lazy.
@c XXX should document the operational semantics of switches and if-then-elses

Mercury implementations are required to provide a method of processing
Mercury programs which is equivalent to the strict sequential
operational semantics.

There is another operational semantics of Mercury programs
called the @dfn{strict commutative} operational semantics.
This semantics is equivalent to the strict sequential operational semantics
except that there is no requirement that
function calls, conjunctions and disjunctions be executed left-to-right;
they may be executed in any order, and may even be interleaved.
Furthermore, the order may even be different
each time a particular goal is entered.

As well as providing the strict sequential operational semantics,
Mercury implementations may optionally provide
additional implementation-defined operational semantics,
provided that any such implementation-defined operational semantics
are at least as complete as the strict commutative operational semantics.
An implementation-defined semantics
is ``at least as complete'' as the strict commutative semantics
if and only if the implementation-defined semantics
guarantees to compute an answer in finite time
for any program for which an answer would be computed in finite time
for all possible executions under the strict commutative semantics
(i.e.@: for all possible orderings of conjunctions and disjunctions).

Thus, to summarize,
there are in fact a variety of different operational semantics for Mercury.
In one of them, the strict sequential semantics,
there is no nondeterminism --- the behaviour is always specified exactly.
Programs are executed top-down using SLDNF (or something equivalent),
mode analysis does ``minimal'' reordering (in a precisely defined sense),
function calls, conjunctions and disjunctions
are executed depth-first left-to-right,
and function evaluation is strict.
All implementations are required to support the strict sequential semantics,
so that a program which works on one implementation using this semantics
will be guaranteed to work on any other implementation.
However, implementations are also allowed to support
other operational semantics,
which may have non-determinism,
so long as they are sound with respect to the declarative semantics,
and so long as they meet a minimum level of completeness
(they must be at least as complete as the strict commutative semantics,
in the sense that every program which terminates for all possible orderings
must also terminate in any implementation-defined operational semantics).

This compromise allows Mercury to be used in several different ways.
Programmers who care more about ease of programming and portability
than about efficiency can use the strict sequential semantics,
and can then be guaranteed that
if their program works on one correct implementation,
it will work on all correct implementations.
Compiler implementors who want to write optimizing implementations
that do lots of clever code reorderings and other high-level transformations
or that want to offer parallelizing implementations
which take maximum advantage of parallelism
can define different semantic models.
Programmers who care about efficiency more than portability
can write code for these implementation-defined semantic models.
Programmers who care about efficiency @emph{and} portability
can achieve this by writing code for the strict commutative semantics.
Of course, this is not quite as easy as using the strict sequential semantics,
since it is in general not sufficient
to test your programs on just one implementation
if you are to be sure that it will be able to use
the maximally efficient operational semantics on any implementation.
However, if you do write code which works for all possible executions
under the strict commutative semantics
(i.e.@: for all possible orderings of conjunctions and disjunctions),
then you can be guaranteed that it will work correctly
on every implementation, under every possible implementation-defined semantics.

The University of Melbourne Mercury implementation offers
eight different semantics,
which can be selected with different combinations
of the @samp{--no-reorder-conj}, @samp{--no-reorder-disj},
and @samp{--no-fully-strict} options.
(The @samp{--no-fully-strict} option allows the compiler to improve
completeness by optimizing away infinite loops and goals with determinism
@code{erroneous}.)
The default semantics are the strict commutative semantics.
Enabling @samp{--no-reorder-conj} and @samp{--no-reorder-disj}
gives the strict sequential semantics.

Future implementations of Mercury
may wish to offer other operational semantics.
For example, they may wish to provide semantics
in which function evaluation is lazy, rather than strict;
semantics with a guaranteed fair search rule; and so forth.

@node Foreign language interface
@chapter Foreign language interface

@menu
* Calling foreign code from Mercury::  How to implement a Mercury predicate
				       or function as a call to code
				       written in a different
				       programming language.
* Calling Mercury from foreign code::  How to call a Mercury predicate
                                       or function from a different
                                       programming language.
* Data passing conventions::	       How Mercury types are passed to
				       different languages.
* Using foreign types from Mercury::   How to use a type defined in
				       a different programming language
				       in Mercury code.
* Using foreign enumerations in Mercury code:: How to use an enumeration type
                                                defined in a foreign language
                                                in Mercury code.
* Using Mercury enumerations in foreign code:: How to use an enumeration type
                                               defined in Mercury in a
                                               different programming language.
* Adding foreign declarations::        How to add declarations of
  				       entities in other programming
				       languages.
* Declaring Mercury exports to other modules::
                                       How to call Mercury procedures from a
                                       different programming language in
                                       another module.
* Adding foreign definitions::         How to add definitions of
  				       entities in other programming
				       languages.
* Language specific bindings::         Information specific to each
  				       foreign language.

@end menu

This chapter documents the foreign language interface.

@node Calling foreign code from Mercury
@section Calling foreign code from Mercury

Mercury procedures can be implemented
using fragments of foreign language code using @samp{pragma foreign_proc}.

@menu
* pragma foreign_proc::         Defining Mercury procedures using foreign code.
* Foreign code attributes::   	Describing properties of foreign
				functions or code.
@end menu

@node pragma foreign_proc
@subsection pragma foreign_proc

A declaration of the form

@example
:- pragma foreign_proc("@var{Lang}",
    @var{Pred}(@var{Var1}::@var{Mode1}, @var{Var2}::@var{Mode2}, @dots{}),
    @var{Attributes}, @var{Foreign_Code}).
@end example

@noindent
or

@example
:- pragma foreign_proc("@var{Lang}",
    @var{Func}(@var{Var1}::@var{Mode1}, @var{Var2}::@var{Mode2}, @dots{}) = (@var{Var}::@var{Mode}),
    @var{Attributes}, @var{Foreign_Code}).
@end example

@noindent
means that any calls to the specified mode of @var{Pred} or @var{Func}
will result in execution of the foreign code given in @var{Foreign_Code}
written in language @var{Lang},
if @var{Lang} is selected as the foreign language code by this implementation.
See the ``Foreign Language Interface'' chapter of the Mercury User's Guide,
for more information about how the implementation selects
the appropriate @samp{foreign_proc} to use.

The foreign code fragment may refer to the specified variables
(@var{Var1}, @var{Var2}, @dots{}, and @var{Var}) directly by name.
It is an error for a variable to occur more than once in the argument list.
These variables will have foreign language types
corresponding to their Mercury types,
as determined by language and implementation specific rules.

All @samp{foreign_proc} implementations are assumed to be impure.
If they are actually pure or semipure,
they must be explicitly promised as such by the user
(either by using foreign language attributes specified below,
or a @samp{promise_pure} or @samp{promise_semipure} pragma
as specified in @ref{Impurity}).

Additional restrictions on the foreign language interface code
depend on the foreign language and compilation options.
For more information, including the list of supported foreign languages
and the strings used to identify them,
see the language specific information
in the ``Foreign Language Interface'' chapter of the Mercury User's Guide.

If there is a @code{pragma foreign_proc} declaration
for any mode of a predicate or function,
then there must be either a clause or a @code{pragma foreign_proc} declaration
for every mode of that predicate or function.

Here is an example of code using @samp{pragma foreign_proc}.
The following code defines a Mercury function @samp{sin/1}
which calls the C function @samp{sin()} of the same name.

@example
@group
:- func sin(float) = float.
:- pragma foreign_proc("C",
    sin(X::in) = (Sin::out),
    [promise_pure, may_call_mercury],
"
    Sin = sin(X);
").
@end group
@end example

If the foreign language code does not recursively invoke Mercury code,
as in the above example, then you can use @samp{will_not_call_mercury}
in place of @samp{may_call_mercury} in the declarations above.
This allows the compiler to use a slightly more efficient calling convention.
(If you use this form, and the foreign code @emph{does} invoke Mercury code,
then the behaviour is undefined --- your program may misbehave or crash.)

If there are both Mercury definitions and foreign_proc definitions
for a procedure and/or foreign_proc definitions for different languages,
it is implementation-defined which definition is used.

For pure and semipure procedures,
the declarative semantics of the foreign_proc definitions
must be the same as that of the Mercury code.
The only thing that is allowed to differ is the efficiency
(including the possibility of non-termination)
and the order of solutions.

It is an error for a procedure with a @samp{pragma foreign_proc} declaration
to have a determinism of @code{multi} or @code{nondet}.

Since foreign_procs with the determinism @code{multi} or @code{nondet}
cannot be defined directly,
procedures with those determinisms
that require foreign code in their implementation
must be defined using a combination
of Mercury clauses and (semi)deterministic foreign_procs.
The following implementation for the standard library predicate
@samp{string.append/3} in the mode @samp{append(out, out, in) is multi}
illustrates this technique:

@example
:- pred append(string, string, string).
:- mode append(out, out, in) is multi.

append(S1, S2, S3) :-
    S3Len = string.length(S3),
    append_2(0, S3Len, S1, S2, S3).

:- pred append_2(int::in, int::in, string::out, string::out, string::in) is multi.

append_2(NextS1Len, S3Len, S1, S2, S3) :-
    ( NextS1Len = S3Len ->
        append_3(NextS1Len, S3Len, S1, S2, S3)
    ;
        (
            append_3(NextS1Len, S3Len, S1, S2, S3)
        ;
            append_2(NextS1Len + 1, S3Len, S1, S2, S3)
        )
    ).

:- pred append_3(int::in, int::in, string::out, string::out, string::in) is det.

:- pragma foreign_proc("C",
    append_3(S1Len::in, S3Len::in, S1::out, S2::out, S3::in),
    [will_not_call_mercury, promise_pure],
"
    S1 = allocate_string(S1Len);   /* Allocate a new string of length S1Len */
    memcpy(S1, S3, S1Len);
    S1[S1Len] = '\\0';
    S2 = allocate_string(S2, S3Len - S1Len);
    strcpy(S2, S3Len + S1Len);
").

@end example

@node Foreign code attributes
@subsection Foreign code attributes

As described above,
@samp{pragma foreign_proc} declarations may include a list of attributes
describing properties of the given foreign function or code.
All Mercury implementations must support the attributes listed below.
They may also support additional attributes.

The attributes which must be supported by all implementations
are as follows:

@table @asis

@item @samp{may_call_mercury}/@samp{will_not_call_mercury}
This attribute declares whether or not
execution inside this foreign language code may call back into Mercury or not.
The default, in case neither is specified, is @samp{may_call_mercury}.
Specifying @samp{will_not_call_mercury}
may allow the compiler to generate more efficient code.
If you specify @samp{will_not_call_mercury},
but the foreign language code @emph{does} invoke Mercury code,
then the behaviour is undefined.

@item @samp{promise_pure}/@samp{promise_semipure}
This attribute promises that
the purity of the given predicate or function definition is pure or semipure.
It is equivalent to a corresponding @samp{pragma promise_pure}
or @samp{pragma promise_semipure} declaration (@pxref{Impurity}).
If omitted, the clause specified by the @samp{foreign_proc}
is assumed to be impure.

@item @samp{thread_safe}/@samp{not_thread_safe}/@samp{maybe_thread_safe}
This attribute declares whether or not it is safe
for multiple threads to execute this foreign language code concurrently.
The default, in case none is specified, is @samp{not_thread_safe}.
If the foreign language code is declared @samp{thread_safe},
then the Mercury implementation is permitted
to execute the code concurrently from multiple threads
without taking any special precautions.
If the foreign language code is declared @samp{not_thread_safe},
then the Mercury implementation
must not invoke the code concurrently from multiple threads.
If the Mercury implementation does use multithreading,
then it must take appropriate steps to prevent this.
(The multithreaded version
of the University of Melbourne Mercury implementation
protects @samp{not_thread_safe} code using a mutex:
C code that is not thread-safe has code inserted around it
to obtain and release a mutex.
All non-thread-safe foreign language code shares a single mutex.)
@c XXX this can cause deadlocks if not_thread_safe foreign language code calls
@c     Mercury which calls foreign language code
If the foreign language code is declared @samp{maybe_thread_safe}
then whether the code is considered
@samp{thread_safe} or @samp{not_thread_safe}
depends upon a compiler flag.
This attribute is useful when the thread safety of the foreign code itself
is conditional.
The Melbourne Mercury compiler uses the @samp{--maybe-thread-safe} option
to set the value of the @samp{maybe_thread_safe} attribute.
@end table

Additional attributes which are supported by the Melbourne Mercury compiler
are as follows:

@table @asis

@item @samp{tabled_for_io}
This attribute should be attached to foreign procedures that do I/O.
It tells the debugger to make calls to the foreign procedure idempotent.
This allows the debugger to safely retry across such calls
and also allows safe declarative debugging of code containing such calls.
For more information,
see the ``I/O tabling'' section of the Mercury User's Guide.
If the foreign procedure contains gotos or static variables then the
@samp{pragma no_inline} directive should also be given.
Note that currently I/O tabling will only be done
for foreign procedures that take a pair of I/O state arguments.
Impure foreign procedures that perform I/O will not be made idempotent,
even if the tabled_for_io attribute is present.
Note also that the tabled_for_io attribute
will likely be replaced in a future release with a more general solution.

@item @samp{terminates}/@samp{does_not_terminate}
This attribute specifies
the termination properties of the given predicate or function definition.
It is equivalent to the corresponding @samp{pragma terminates}
or @samp{pragma does_not_terminate} declaration.
If omitted, the termination property of the procedure is determined
by the value of the
@samp{may_call_mercury}/@samp{will_not_call_mercury} attribute.
See @ref{Termination analysis} for more details.

@item @samp{will_not_throw_exception}
This attribute promises that the given predicate or function
will not make calls back to Mercury
that may result in an exception being thrown.
It is an error to apply this attribute
to procedures that have determinism @code{erroneous}.
This attribute is ignored for code
that is declared as not making calls back to Mercury
via the @samp{will_not_call_mercury} attribute.
Note: predicates or functions that have polymorphic arguments
but do not explicitly throw an exception,
via a call to @samp{exception.throw/1} or @samp{require.error/1},
may still throw exceptions because they may be called
with arguments whose types have user-defined equality or comparison predicates.
If these user-defined equality or comparison predicates throw exceptions
then unifications or comparisons involving these types
may also throw exceptions.
As such, we recommend that only implementors of the Mercury system
use this annotation for polymorphic predicates and functions.

@c @item @samp{high_level_backend}
@c The foreign_proc will apply only on the high level backend.
@c @item @samp{low_level_backend}
@c The foreign_proc will apply only on the low level backend.

@item @samp{will_not_modify_trail/may_modify_trail}
This attribute declares whether or not
a foreign procedure modifies the trail (see @ref{Trailing}).
Specifying that a foreign procedure will not modify the trail
may allow the compiler to generate more efficient code for that procedure.
In compilation grades that do not support trailing, this attribute is ignored.
The default, in case none is specified, is @samp{may_modify_trail}.

@item @samp{will_not_call_mm_tabled/may_call_mm_tabled}
This attribute declares whether or not
a foreign procedure makes calls back to Mercury procedures
that are evaluated using minimal model tabling
(@pxref{Tabled evaluation}).
Specifying that a foreign procedure will not call
procedures evaluated using minimal model tabling
may allow the compiler to generate more efficient code.
In compilation grades that do not support minimal model tabling,
this attribute is ignored.
These attributes may not be used with procedures
that do not make calls back to Mercury,
i.e. that have the @samp{will_not_call_mercury} attribute.
The default for foreign procedures that @samp{may_call_mercury},
in case none is specified, is
@samp{may_call_mm_tabled}.

@item @samp{affects_liveness/does_not_affect_liveness}
This attribute declares whether or not a foreign procedure
uses and/or modifies any part of the Mercury virtual machine
(registers, stack slots)
through means other than its arguments.
The @samp{affects_liveness} attribute says that it does;
The @samp{does_not_affect_liveness} attribute says that it does not.
In the absence of either attribute,
the compiler assumes @samp{affects_liveness},
unless the code of the foreign_proc in question is empty.

@item @samp{may_duplicate/may_not_duplicate}
This attribute tells the compiler
whether it is allowed to duplicate the foreign code fragment
through optimizations such as inlining.
The @samp{may_duplicate} attribute says that it may;
The @samp{may_not_duplicate} attribute says that it may not.
In the absence of either attribute,
the compiler is allowed make its own judgement in the matter,
based on factors such as the size of the code fragment.

@c @item
@c @samp{does_not_allocate_memory/allocates_bounded_memory/allocates_unbounded_memory}
@c This attribute declares whether a foreign procedure
@c allocates any memory on the Mercury heap,
@c and if it does, whether the amount allocated
@c is guaranteed to be smaller than the bound given
@c by the reserve space of the native garbage collector.

@c @item
@c @samp{registers_roots/does_not_register_roots/does_not_have_roots}
@c This attribute declares whether a foreign procedure
@c registers with the native garbage collector
@c all the root pointers it accesses.
@c This must always include
@c all global variables maintained by the foreign procedure.
@c If the foreign procedure may call Mercury,
@c it must also include any storage location in which
@c the foreign procedure stores roots before any call to Mercury
@c (since a gc may take place during such a call).

@c @item @samp{no_sharing/unknown_sharing/sharing(MaybeTypes, SharingList)}
@c This attribute declares whether or not a foreign procedure creates any
@c structure sharing @ref{Structure sharing analysis} between its input
@c and output arguments.
@c Specifying that a foreign
@c procedure generates no sharing (attribute @samp{no_sharing}) is a promise
@c to the compiler that the procedure does not create any sharing
@c between its arguments. The attribute @samp{unknown_sharing} specifies
@c that the
@c procedure may create any possible sharing between the arguments.
@c Finally, using
@c @samp{sharing(MaybeTypes, SharingList)} it is possible to specify a list of
@c sharing arguments, declaring that the foreign procedure creates at most
@c the specified sharing between the arguments. @samp{MaybeTypes} takes
@c the values
@c @samp{no/yes(Types)}, where @samp{Types} corresponds to the types used in
@c the predicate or function declaration for this foreign procedure.
@c @samp{SharingList} consists of a list
@c @samp{[SharingPairA, SharingPairB, ...]}, where each sharing pair
@c is represented by a pair @samp{cel(Vari, Seli) - cel(Varj, Selj)}.
@c @samp{Vari, Varj} must be variables that are part of the mode declaration
@c of the @samp{foreign_proc} definition. @samp{Seli, Selj} select
@c the subterms of the given arguments that actually share. Each selector
@c @samp{Seli} is written as a list of types @samp{[Type1, Type2, ...]}
@c representing a path in the term structure of the given argument. An
@c empty list designates the complete term to which the argument corresponds.
@c The types can make use of type variables as long as @samp{MaybeTypes} is
@c set to @samp{yes(Types)}, and the type variables occur in any of the types
@c used in @samp{Types}.
@c
@c @example
@c :- pred array.init_2(int::in, T::in, array(T)::array_uo) is det.
@c
@c :- pragma foreign_proc("C",
    @c array.init_2(Size::in, Item::in, Array::array_uo),
    @c [will_not_call_mercury, promise_pure, thread_safe, will_not_modify_trail,
    @c sharing(yes(int, T, array(T)), [cel(Item,[]) - cel(Array,[T])])],
@c "
    @c ML_alloc_array(Array, Size + 1, MR_ALLOC_ID);
    @c ML_init_array(Array, Size, Item);
@c ").
@c @end example
@c
@c This sharing declaration promises that a call
@c @code{init_2(Size, Item, Array)}, with types @code{int, T, array(T)}
@c may create sharing between any
@c subterms of type @code{T} of the resulting array @code{Array} and the
@c term @code{Item}. Reformulated: the elements of @code{Array} may refer
@c to the same memory locations as @code{Item}.

@end table

@c -----------------------------------------------------------------------

@node Calling Mercury from foreign code
@section Calling Mercury from foreign code

Mercury procedures may be exported
so that they can be called by code written in a foreign language.

A declaration of the form:

@example
:- pragma foreign_export("@var{Lang}",
    @var{Pred}(@var{Mode1}, @var{Mode2}, @dots{}), "@var{ForeignName}").
@end example

@noindent
or

@example
:- pragma foreign_export("@var{Lang}",
    @var{Func}(@var{Mode1}, @var{Mode2}, @dots{}) = @var{Mode},
    "@var{ForeignName}").
@end example

@noindent
exports a procedure for use by foreign language @var{Lang}.
For each exported procedure,
the Mercury implementation will create an interface
to the named Mercury procedure in the foreign language
using the name @var{ForeignName}.
The form of this interface is dependent upon the specified foreign language.
For further details see the language specific information below.

It is an error to export a Mercury procedure
that has a determinism of @code{multi} or @code{nondet}.

@c -----------------------------------------------------------------------

@node Data passing conventions
@section Data passing conventions

For each supported foreign language,
we explain how to map a Mercury type to a type in that foreign language.
We also map the Mercury parameter passing convention
to the foreign language's parameter passing convention.

@menu
* C data passing conventions ::
* C# data passing conventions ::
* Java data passing conventions ::
* Erlang data passing conventions ::
@end menu

@node C data passing conventions
@subsection C data passing conventions

The Mercury primitive types are mapped to the following C types:

@multitable {Mercury_type} {MR_Unsigned}
@headitem Mercury type @tab C type
  @item @code{int}    @tab @code{MR_Integer}
  @item @code{int8}   @tab @code{int8_t}
  @item @code{int16}  @tab @code{int16_t}
  @item @code{int32}  @tab @code{int32_t}
  @item @code{int64}  @tab @code{int64_t}
  @item @code{uint}   @tab @code{MR_Unsigned}
  @item @code{uint8}  @tab @code{uint8_t}
  @item @code{uint16} @tab @code{uint16_t}
  @item @code{uint32} @tab @code{uint32_t}
  @item @code{uint64} @tab @code{uint64_t}
  @item @code{float}  @tab @code{MR_Float}
  @item @code{char}   @tab @code{MR_Char}
  @item @code{string} @tab @code{MR_String}
@end multitable

In the current implementation,
@code{MR_Integer} is a typedef for a signed integral type
which is the same size as a pointer of type @samp{void *};
@code{MR_Unsigned} is a typedef for an unsigned integral type
which is the same size as a pointer of type @samp{void *};
@code{MR_Float} is a typedef for @code{double}
(unless the program and the Mercury library
was compiled with @samp{--single-prec-float},
in which case it is a typedef for @code{float});
@code{MR_Char} is a typedef for a signed 32-bit integral type
and @code{MR_String} is a typedef for @samp{char *}.

Mercury variables of primitive types are passed to and from C
as C variables of the corresponding C type.

For the Mercury standard library type @samp{bool.bool},
there is a corresponding C type, @code{MR_Bool}.
C code can refer to the boolean data constructors @samp{yes} and @samp{no},
as @code{MR_YES} and @code{MR_NO} respectively.

For the Mercury standard library type @samp{builtin.comparison_result},
there is a corresponding C type, @code{MR_Comparison_Result}.
C code can refer to the data constructors of this type,
@samp{(<)}, @samp{(=)} and @samp{(>)},
as @code{MR_COMPARE_LESS}, @code{MR_COMPARE_EQUAL}
and @code{MR_COMPARE_GREATER} respectively.

Mercury variables of a type
for which there is a C @samp{pragma foreign_type} declaration
(@pxref{Using foreign types from Mercury})
will be passed as the corresponding C type.

Mercury tuple types are passed as @code{MR_Tuple},
which in the current implementation is a typedef
for a pointer of type @samp{void *} if @samp{--high-level-code} is enabled,
and a typedef for @code{MR_Word} otherwise.

Mercury variables of any other type are passed as a @code{MR_Word},
which in the current implementation is a typedef
for an unsigned type whose size is the same size as a pointer.
(Note: it would in fact be better for each Mercury type
to map to a distinct abstract type in C,
since that would be more type-safe,
and thus we may change this in a future release.
We advise programmers who are manipulating Mercury types in C code
to use typedefs for each user-defined Mercury type,
and to treat each such type as an abstract data type.
This is good style
and it will also minimize any compatibility problems
if and when we do change this.)

Mercury lists can be manipulated by C code using the following macros,
which are defined by the Mercury implementation.

@example
MR_list_is_empty(list)     /* test if a list is empty */
MR_list_head(list)         /* get the head of a list */
MR_list_tail(list)         /* get the tail of a list */
MR_list_empty()            /* create an empty list */
MR_list_cons(head,tail)    /* construct a list with the given head and tail */
@end example

Note that the use of these macros is subject to some caveats
(@pxref{Memory management for C}).

The implementation provides the macro @code{MR_word_to_float}
for converting a value of type @code{MR_Word} to one of type @code{MR_Float},
and the macro @code{MR_float_to_word}
for converting a value of type @code{MR_Float} to one of type @code{MR_Word}.
These macros must be used to perform these conversions
since for some Mercury implementations
@samp{sizeof(MR_Float)} is greater than @samp{sizeof(MR_Word)}.

The following fragment of C code illustrates
the correct way to extract the head of a Mercury list of floats.

@example
MR_Float f;
f = MR_word_to_float(MR_list_head(list));
@end example

Omitting the call to @code{MR_word_to_float} in the above example
would yield incorrect results for implementations
where @samp{sizeof(MR_Float)} is greater than @samp{sizeof(MR_Word)}.

Similarly, the implementation provides
the macros @code{MR_word_to_int64} and @code{MR_word_to_uint64}
for converting values of type @code{MR_Word}
to ones of type @code{int64_t} or @code{uint64_t} respectively,
and the macros @code{MR_int64_to_word} and @code{MR_uint64_to_word}
for converting values of type @code{int64_t} or @code{uint64_t} respectively
to ones of type @code{MR_Word}.
These macros must be used to perform these conversions
since for some Mercury implementations
@samp{sizeof(int64_t)} or @samp{sizeof(uint64_t)}
are greater than @samp{sizeof(MR_Word)}.

@node C# data passing conventions
@subsection C# data passing conventions

The Mercury primitive types are mapped
to the following Common Language Infrastructure (CLI) and C# types:

@multitable {Mercury_type} {System_String} {double}
  @headitem Mercury type @tab CLI type @tab C# type
  @item @code{int}    @tab @code{System.Int32}  @tab @code{int}
  @item @code{int8}   @tab @code{System.Int8}   @tab @code{sbyte}
  @item @code{int16}  @tab @code{System.Int16}  @tab @code{short}
  @item @code{int32}  @tab @code{System.Int32}  @tab @code{int}
  @item @code{int64}  @tab @code{System.Int64}  @tab @code{long}
  @item @code{uint}   @tab @code{System.UInt32} @tab @code{uint}
  @item @code{uint8}  @tab @code{System.UInt8}  @tab @code{byte}
  @item @code{uint16} @tab @code{System.UInt16} @tab @code{ushort}
  @item @code{uint32} @tab @code{System.UInt32} @tab @code{uint}
  @item @code{uint64} @tab @code{System.UInt64} @tab @code{ulong}
  @item @code{float}  @tab @code{System.Double} @tab @code{double}
  @item @code{char}   @tab @code{System.Int32}  @tab @code{int}
  @item @code{string} @tab @code{System.String} @tab @code{string}
@end multitable

Note that the Mercury type @code{char} is mapped like @code{int};
@emph{not} to the CLI type @code{System.Char}
because that only holds 16-bit numeric values.

For the Mercury standard library type @samp{bool.bool},
there is a corresponding C# type, @code{mr_bool.Bool_0}.
C# code can refer to the boolean data constructors @samp{yes} and @samp{no},
as @code{mr_bool.YES} and @code{mr_bool.NO} respectively.

For the Mercury standard library type @samp{builtin.comparison_result},
there is a corresponding C# type, @code{builtin.Comparison_result_0}.
C# code can refer to the data constructors of this type,
@samp{(<)}, @samp{(=)} and @samp{(>)},
as @code{builtin.COMPARE_LESS}, @code{builtin.COMPARE_EQUAL}
and @code{builtin.COMPARE_GREATER} respectively.

Mercury variables of a type
for which there is a C# @samp{pragma foreign_type} declaration
(@pxref{Using foreign types from Mercury})
will be passed as the corresponding C# type.
Both reference and value types are supported.

Mercury tuple types are passed as @samp{object[]}
where the length of the array is the number of elements in the tuple.

Mercury variables whose type is a type variable
will be passed as @code{System.Object}.

Mercury variables whose type is a Mercury discriminated union type
will be passed as a CLI type
whose type name is determined from the Mercury type name
(ignoring any type parameters) followed by an underscore
and then the type arity, expressed as a decimal integer.
The first character of the type name will have its case inverted,
and the name may be mangled to satisfy C# lexical rules.

@noindent
For example, the following Mercury type
corresponds to the C# class that follows (some implementation details elided):

@example
:- type maybe(T)
    --->    yes(yes_field :: T)
    ;       no.

public static class Maybe_1 @{
    public static class Yes_1 : Maybe_1 @{
        public object yes_field;
        public Yes_1(object x) @{ @dots{} @}
    @}
    public static class No_0 : Maybe_1 @{
        public No_0() @{ @dots{} @}
    @}
@}
@end example

C# code generated by the Mercury compiler
is placed in the @samp{mercury} namespace.
Mercury module qualifiers are converted into a C# class name
by concatenating the components with double underscore separators (@samp{__}).
For example the Mercury type @samp{foo.bar.baz/1} will be passed
as the C# type @samp{mercury.foo__bar.Baz_1}.

Mercury array types are mapped to @code{System.Array}.

Mercury variables whose type is a Mercury equivalence type
will be passed as the representation
of the right hand side of the equivalence type.

This mapping is subject to change
and you should try to avoid writing code
that relies heavily upon a particular representation of Mercury terms.

Mercury arguments declared with input modes
are passed by value to the C# function.

Arguments of type @samp{io.state} or @samp{store.store(_)}
are not passed or returned at all.
(The reason for this is that these types represent mutable state,
and in C# modifications to mutable state are done via side effects,
rather than argument passing.)

The handling of multiple output arguments is as follows.

If the Mercury procedure is deterministic and has no output arguments,
then the return type of the C# function is @samp{void};
if it has one output argument,
then the return value of the function is that output argument.

If the Mercury procedure is deterministic and has two or more output arguments,
then the return type of the C# function is @samp{void}.
At the position of each output argument,
the C# function has an @samp{out} parameter.

If the Mercury procedure is semi-deterministic
then the C# function returns a @samp{bool}.
A @samp{true} return value denotes success and @samp{false} denotes failure.
Output arguments are handled in the same way
as multiple outputs for deterministic procedures,
using @samp{out} parameters.
On failure the values of the @samp{val} fields are undefined.

Mercury lists can be manipulated by C# code using the following methods,
which are defined by the Mercury implementation.

@example
bool      list.is_empty(List_1 list)     // test if a list is empty
object    list.det_head(List_1 list)     // get the head of a list
List_1    list.det_tail(List_1 list)     // get the tail of a list
List_1    list.empty_list()              // create an empty list
List_1    list.cons(object head, List_1 tail)
                                         // construct a list with
                                         //  the given head and tail
@end example

@node Java data passing conventions
@subsection Java data passing conventions

The Mercury primitive types are mapped to the following Java types:
@multitable {Mercury_type} {java_lang_String}
  @headitem Mercury type @tab Java type
  @item @code{int}     @tab @code{int}
  @item @code{int8}    @tab @code{byte}
  @item @code{int16}   @tab @code{short}
  @item @code{int32}   @tab @code{int}
  @item @code{int64}   @tab @code{long}
  @item @code{uint}    @tab @code{int}
  @item @code{uint8}   @tab @code{byte}
  @item @code{uint16}  @tab @code{short}
  @item @code{uint32}  @tab @code{int}
  @item @code{uint64}  @tab @code{long}
  @item @code{float}   @tab @code{double}
  @item @code{char}    @tab @code{int}
  @item @code{string}  @tab @code{java.lang.String}
@end multitable

Note that since Java lacks unsigned integer types,
Mercury's unsigned integer types correspond to signed integer types in Java.

Also, note that the Mercury type @code{char} is mapped like @code{int};
@emph{not} to the Java type @code{char}
because that only holds 16-bit numeric values.

For the Mercury standard library type @samp{bool.bool},
there is a corresponding Java type, @code{bool.Bool_0}.
Java code can refer to the boolean data constructors @samp{yes} and @samp{no},
as @code{bool.YES} and @code{bool.NO} respectively.

For the Mercury standard library type @samp{builtin.comparison_result},
there is a corresponding Java type, @code{builtin.Comparison_result_0}.
Java code can refer to the data constructors of this type,
@samp{(<)}, @samp{(=)} and @samp{(>)},
as @code{builtin.COMPARE_LESS}, @code{builtin.COMPARE_EQUAL}
and @code{builtin.COMPARE_GREATER} respectively.

Mercury variables of a type
for which there is a Java @samp{pragma foreign_type} declaration
(@pxref{Using foreign types from Mercury})
will be passed as the corresponding Java type.

Mercury tuple types are passed as @code{java.lang.Object[]}
where the length of the array is the number of elements in the tuple.

Mercury variables whose types are universally quantified type variables
will have generic types.
Mercury variables whose types are existentially quantified type variables
will be passed as @code{java.lang.Object}.

Mercury variables whose type is a Mercury discriminated union type
will be passed as a Java type
whose type name is determined from the Mercury type name
(ignoring any type parameters) followed by an underscore
and then the type arity, expressed as a decimal integer.
The first character of the type name will have its case inverted,
and the name may be mangled to satisfy Java lexical rules.
Generics are used in the Java type for any type parameters.

@noindent
For example, the following Mercury type
corresponds to the Java class that follows
(some implementation details elided):

@example
:- type maybe(T)
    --->    yes(yes_field :: T)
    ;       no.

public static class Maybe_1<T> @{
    public static class Yes_1<T> extends Maybe_1 @{
        public T yes_field;
        public Yes_1(T x) @{ @dots{} @}
    @}
    public static class No_0<T> extends Maybe_1 @{
        public No_0() @{ @dots{} @}
    @}
@}
@end example

Java code generated by the Mercury compiler
is placed in the @samp{jmercury} package.
Mercury module qualifiers are converted into a Java class name
by concatenating the components with double underscore separators (@samp{__}).
For example the Mercury type @samp{foo.bar.baz/1}
will be passed as the Java type @samp{jmercury.foo__bar.Baz_1}.

Mercury array types are mapped to Java array types.

Mercury variables whose type is a Mercury equivalence type will be passed
as the representation of the right hand side of the equivalence type.

This mapping is subject to change and you should try to avoid writing code
that relies heavily upon a particular representation of Mercury terms.

Mercury arguments declared with input modes
are passed by value to the corresponding Java function.
If the Mercury procedure is a function whose result has an input mode,
then the Mercury function result is appended to the list of input parameters,
so that the Mercury function result
becomes the last parameter to the corresponding Java function.

Arguments of type @samp{io.state} or @samp{store.store(_)}
are not passed or returned at all.
(The reason for this is that these types represent mutable state,
and in Java modifications to mutable state are done via side effects,
rather than argument passing.)

The handling of multiple output arguments is as follows.

If the Mercury procedure is deterministic and has no output arguments,
then the return type of the Java function is @code{void};
if it has one output argument,
then the return value of the function is that output argument.

If the Mercury procedure is deterministic and has two or more output arguments,
then the return type of the Java function is @code{void}.
At the position of each output argument,
the Java function takes a value of the type @samp{jmercury.runtime.Ref<T>}
where @samp{T} is the Java type
corresponding to the type of the output argument.
@samp{Ref} is a class with a single field @samp{val},
which is assigned the output value when the function returns.

If the Mercury procedure is semi-deterministic,
then the Java function returns a @samp{boolean}.
A @samp{true} return value denotes success and @samp{false} denotes failure.
Output arguments are handled in the same way
as multiple outputs for deterministic procedures, using the @samp{Ref} class.
On failure the values of the @samp{val} fields are undefined.

Mercury lists can be manipulated by Java code using the following methods,
which are defined by the Mercury implementation.

@example
boolean   list.is_empty(List_1<E> list)     // test if a list is empty
E         list.det_head(List_1<E> list)     // get the head of a list
List_1<E> list.det_tail(List_1<E> list)     // get the tail of a list
List_1<E> list.empty_list()                 // create an empty list
<E, F extends E> List_1<E> list.cons(F head, List_1<E> tail)
                                            // construct a list with
                                            // the given head and tail
@end example

@node Erlang data passing conventions
@subsection Erlang data passing conventions

The Mercury types @code{int}, @code{float} and @code{char}
are mapped to Erlang integers, floats and integers respectively.
A Mercury @code{string} is represented by an Erlang binary,
not by a list of integers.

Mercury variables whose type is a Mercury discriminated union type
will be passed as an Erlang tuple,
with the first element of the tuple
being an Erlang atom named after the Mercury data constructor.
For example, values of the type:

@example
:- type maybe_int
    --->    yes(int)
    ;       no.
@end example

@noindent
would be represented in Erlang
as @samp{@{yes, @var{integer}@}} and @samp{@{no@}}.

Mercury variables whose type is a Mercury equivalence type will be passed
as the representation of the right hand side of the equivalence type.

This mapping is subject to change and you should try to avoid writing code
that relies heavily upon a particular representation of Mercury terms.

Arguments of dummy types, e.g. @samp{io.state},
are represented by the atom @samp{false} when necessary.
They are not passed to and from calls to monomorphic procedures.

Mercury arguments declared with input modes
are passed by value to the corresponding Erlang function.

The result of an Erlang function
depends on the determinism of the Mercury procedure that it was derived from.
Procedures which succeed exactly once and have a single output variable
return the single value directly.
Procedures which succeed exactly once
and have zero or two or more output variables
return a tuple of those output variables in order.

Procedures which are semideterministic return, on success,
a tuple of the variables with output modes
(including when the number of output variables is one).
On failure they return the Erlang atom @samp{fail}.

Procedures which are nondeterministic
take as a final argument a success continuation.
This is an function which has an input variable
for each variable of the Mercury procedure with an output mode.
For each solution, the success continuation is called
with the values of those output variables.
When there are no more solutions,
the Erlang function returns with an undefined value.

@c -----------------------------------------------------------------------

@node Using foreign types from Mercury
@section Using foreign types from Mercury

Types defined in a foreign language can be accessed in Mercury
using a declaration of the form

@example
:- pragma foreign_type(@var{Lang}, @var{MercuryTypeName}, @var{ForeignTypeDescriptor}).
@end example

This defines @var{MercuryTypeName}
as a synonym for type @var{ForeignTypeDescriptor}
defined in the foreign language @var{Lang}.
You must declare @var{MercuryTypeName}
using a (possibly abstract) @samp{:- type} declaration as usual.
The @samp{pragma foreign_type} must not have wider visibility
than the type declaration
(if the @samp{pragma foreign_type} declaration is in the interface,
the @samp{:- type} declaration must be also).

@var{ForeignTypeDescriptor} defines
how the Mercury type is mapped for a particular foreign language.
Specific syntax is given in the language specific information below.

@var{MercuryTypeName} is treated as an abstract type
at all times in Mercury code.
However, if @var{MercuryTypeName}
is one of the parameters of a foreign_proc for @var{Lang},
and the @samp{pragma foreign_type} declaration is visible to the foreign_proc,
it will be passed to that foreign_proc
as specified by @var{ForeignTypeDescriptor}.

Multiple foreign language definitions may be given for the same type ---
the appropriate definition will be used for the appropriate language
(see the language specific information below for details).
All definitions must have the same visibility.
A Mercury definition, which must define a discriminated union type,
may also be given.
The constructors for the type will only be visible in Mercury clauses
for predicates or functions with @samp{pragma foreign_proc} clauses
for all of the languages for which there are
@samp{foreign_type} declarations for the type.

You can also associate assertions about the properties of the foreign type
with the @samp{foreign_type} declaration, using the following syntax:

@example
:- pragma foreign_type(@var{Lang}, @var{MercuryTypeName}, @var{ForeignTypeDescriptor},
    [@var{ForeignTypeAssertion}, @dots{}]).
@end example

Currently, three kinds of assertions are supported.

The @samp{can_pass_as_mercury_type} assertion
states that on the C backends, values of the given type
can be passed to and from Mercury code without boxing,
via simple casts, which is faster.
This requires the type to be either an integer type or a pointer type,
and requires it to be castable to @samp{MR_Word} and back
without loss of information
(which means that its size may not be greater than the size of @samp{MR_Word}).

The @samp{word_aligned_pointer} assertion implies
@samp{can_pass_as_mercury_type} and additionally states that values of the
given type are pointer values clear in the tag bits.
It allows the Mercury implementation to avoid boxing values of the given type
when the type appears as the sole argument of a data constructor.

The @samp{stable} assertion is meaningful
only in the presence of the @samp{can_pass_as_mercury_type}
or @samp{word_aligned_pointer} assertions.
It states that either the C type is an integer type,
or it is a pointer type pointing to memory that will never change.
Together, these assertions are sufficient to allow
tabling (@pxref{Tabled evaluation})
and the @samp{compare_representation} primitive
to work on values of such types.

Violations of any of these assertions are very likely to result
in the generated executable silently doing the wrong thing,
giving no clue to where the problem might be.
Since deciding whether a C type satisfies the conditions of these assertions
requires knowledge of the internals of the Mercury implementation,
we do not recommend the use of any of these assertions
unless you are confident of your expertise in those internals.

As with discriminated union types,
programmers can specify the unification @w{and/or} comparison predicates
to use for values of the type using the following syntax
(@pxref{User-defined equality and comparison}):

@example
:- pragma foreign_type(@var{Lang}, @var{MercuryTypeName}, @var{ForeignTypeDescriptor})
        where equality is @var{EqualityPred}, comparison is @var{ComparePred}.
@end example

You can use Mercury foreign language interfacing declarations
which specify language @var{X} to interface to types
that are actually written in a different language @var{Y},
provided that @var{X} and @var{Y} have compatible interface conventions.
Support for this kind of compatibility
is described in the language specific information below.

@c -----------------------------------------------------------------------

@node Using foreign enumerations in Mercury code
@section Using foreign enumerations in Mercury code

While a @samp{pragma foreign_type} declaration
imports a foreign @emph{type} into Mercury,
a @samp{pragma foreign_enum} declaration
imports @emph{the values of the constants of an enumeration type} into Mercury.

While languages such as C have special syntax for defining enumeration types,
in Mercury, an enumeration type is simply an ordinary discriminated union type
whose function symbols all have arity zero.

Given an enumeration type such as
@example
:- type unix_file_permissions
    --->    user_read
    ;       user_write
    ;       user_executable
    ;       group_read
    ;       group_write
    ;       group_executable
    ;       other_read
    ;       other_write
    ;       other_executable.
@end example

the values used to represent each constant
are usually decided by the Mercury compiler.
However, the values assigned this way
may not match the values expected by foreign language code
that uses values of the enumeration,
and even if they happen to match,
programmers probably would not want to @emph{rely} on this coincidence.

This is why Mercury supports a mechanism that allows programmers
to specify the representation of each constant in an enumeration type
when generating code for a given target language.
This mechanism is the @samp{pragma foreign_enum} declaration,
which looks like this:

@example
@group
:- pragma foreign_enum("C", unix_file_permissions/0,
[
    user_read        - "S_IRUSR",
    user_write       - "S_IWUSR",
    user_executable  - "S_IXUSR",
    group_read       - "S_IRGRP",
    group_write      - "S_IWGRP",
    group_executable - "S_IXGRP",
    other_read       - "S_IROTH",
    other_write      - "S_IWOTH",
    other_executable - "S_IXOTH"
]).
@end group
@end example

(Unix systems have a standard header file
that defines each of @samp{S_IRUSR}, @dots{}, @samp{S_IXOTH}
as macros that each expand to an integer constant;
these constants happen @emph{not} to be the ones
that the Mercury compiler would assign to those constants.)

The general form of @samp{pragma foreign_enum} declarations is

@example
:- pragma foreign_enum("@var{Lang}", @var{MercuryType}, @var{CtorValues}).
@end example

where @var{CtorValues} is a list of pairs of the form:

@example
@group
[
    ctor_0 - "ForeignValue_0",
    ctor_1 - "ForeignValue_1",
    @dots{}
    ctor_N - "ForeignValue_N"
]
@end group
@end example

The first element of each pair
is a constant (function symbol of arity 0) of the type @var{MercuryType},
and the second is either a numeric or a symbolic name
for the integer value in the language @var{Lang}
that the programmer wants to be used to represent that constructor.

The mapping defined by this list of pairs must form a bijection,
i.e. the list must map distinct constructors to distinct values,
and vice versa.
The Mercury compiler is not required to check this, because it cannot;
even if two symbolic names (such as C macros) are distinct,
they may expand to the same integer in the target language.

Mercury implementations may impose
further foreign-language-specific restrictions
on the form that values used to represent enumeration constructors may take.
See the language specific information below for details.

It is an error for any given @var{MercuryType}
to be the subject of more than one @samp{pragma foreign_enum} declaration
for any given foreign language,
since that would amount to an attempt
to specify two or more (probably) conflicting representations
for each of the type's function symbols.

@c XXX we need to specify a behaviour when there are multiple supported
@c foreign languages.

A @samp{pragma foreign_enum} declaration must occur in the implementation
section of the module that defines the type @var{MercuryType}.
Because of this, the names of the constants
need not and must not be module qualified.

Note that the default comparison for types
that are the subject of a @samp{pragma foreign_enum} declaration
will be defined by the foreign values,
rather than the order of the constructors in the type declaration
(as would otherwise be the case).

@c -----------------------------------------------------------------------

@node Using Mercury enumerations in foreign code
@section Using Mercury enumerations in foreign code

A @samp{pragma foreign_enum} declaration
imports the values of the constants of an enumeration type into Mercury.
However, sometimes one needs the reverse:
the ability to @emph{export}
the values of the constants of an enumeration type
(whether those values were assigned by @samp{foreign_enum} pragmas or not)
from Mercury to foreign language code in
@samp{foreign_proc} and @samp{foreign_code} pragmas.
This is what @samp{pragma foreign_export_enum} declarations are for.

These pragmas have the following general form:

@example
:- pragma foreign_export_enum("@var{Lang}", @var{MercuryType},
    @var{Attributes}, @var{Overrides}).
@end example

When given such a pragma,
the compiler will define a symbolic name in language @var{Lang}
for each of the constructors of @var{MercuryType}
(which must be an enumeration type).
Each symbolic name allows code in that foreign language
to create a value corresponding to that of the constructor it represents.
(The exact mechanism used depends upon the foreign language;
see the language specific information below for further details.)

For each foreign language,
there is a default mapping between the name of a Mercury constructor
and its symbolic name in the language @var{Lang}.
This default mapping is not required to map
every valid constructor name to a valid name in language @var{Lang};
where it does not, the programmer must specify a valid symbolic name.
The programmer may also choose to map a constructor to a symbolic name
that differs from the one supplied
by the default mapping for language @var{Lang}.
@var{Overrides} is a list
whose elements are pairs of constructor names and strings.
The latter specify the name that the implementation should use
as the symbolic name in the foreign language.
@var{Overrides} has the following form:

@example
[cons_I - "symbol_I", @dots{}, cons_J - "symbol_J"]
@end example

This can be used to provide
either a valid symbolic name where the default mapping does not,
or to override a valid symbolic name generated by the default mapping.
This argument may be omitted if @var{Overrides} is empty.

The argument @var{Attributes} is a list of optional attributes.
If empty,
it may be omitted from the @samp{pragma foreign_export_enum} declaration
if the @var{Overrides} argument is also omitted.
The following attributes must be supported by all Mercury implementations.

@table @asis

@item @samp{prefix(@var{Prefix})}
Prefix each symbolic name, regardless of how it was generated,
with the string @var{Prefix}.
A @samp{pragma foreign_export_enum} declaration
may contain at most one @samp{prefix} attribute.

@item @samp{uppercase}
Convert any alphabetic characters in a Mercury constructor name to uppercase
when generating the symbolic name using the default mapping.
Symbolic names specified by the programmer using @var{Overrides}
are not affected by this attribute.
If the @samp{prefix} attribute is also specified,
then the prefix is added to the symbolic name
@emph{after} the conversion to uppercase has been performed,
i.e. the characters in the prefix
are not affected by the @samp{uppercase} attribute.

@end table

The implementation does not check
the validity of a symbolic name in the foreign language
until after the effects of any attributes have been applied.
This means that attributes may cause
an otherwise valid symbolic name to become invalid, or vice versa.

A Mercury module may contain @samp{pragma foreign_export_enum} declarations
that refer to imported types, subject to the usual visibility restrictions.

A Mercury module, or program, may contain
more than one @samp{pragma foreign_export_enum} declaration
for a given Mercury type for a given language.
This can be useful when a project is transitioning
from using one naming scheme for Mercury constants in foreign code
to another naming scheme.

It is an error if the mapping between constructors and symbolic names
in a @samp{pragma foreign_export_enum} declaration
does not form a bijection.
It is also an error
if two separate @samp{pragma foreign_export_enum} declarations
for a given foreign language, @emph{whether or not for the same type},
specify the same symbolic name,
since in that case, the Mercury compiler would generate
two conflicting definitions for that symbolic name.
However, the Mercury implementation is not required to check either condition.

A @samp{pragma foreign_export_enum} declaration
may occur only in the implementation section of a module.

@c -----------------------------------------------------------------------

@node Adding foreign declarations
@section Adding foreign declarations

Foreign language declarations
(such as type declarations, header file inclusions or macro definitions)
can be included in the Mercury source file
as part of a @samp{foreign_decl} declaration of the form

@example
:- pragma foreign_decl("@var{Lang}", @var{DeclCode}).
@end example

This declaration will have effects equivalent to
including the specified @var{DeclCode}
in an automatically generated source file
of the specified programming language,
in a place appropriate for declarations,
and linking that source file with the Mercury program
(after having compiled it with a compiler
for the specified programming language, if appropriate).

Entities declared in @samp{pragma foreign_decl} declarations
are visible in @samp{pragma foreign_code}, @samp{pragma foreign_type},
@samp{pragma foreign_proc}, and @samp{pragma foreign_enum} declarations
that specify the same foreign language and occur in the same Mercury module.

By default, the contents of @samp{pragma foreign_decl} declarations
are also visible in the same kinds of declarations in other modules
that import the module containing the @samp{pragma foreign_decl} declaration.
This is because they may be required to make sense
of types defined using @samp{pragma foreign_type}
and/or predicates defined using @samp{pragma foreign_proc}
in the containing module,
and these may be visible in other modules,
especially in the presence of intermodule optimization,

If you do not want the contents of a @samp{pragma foreign_decl} declaration
to be visible in foreign language code in other modules,
you can use the following variant of the declaration:

@example
:- pragma foreign_decl("@var{Lang}", local, @var{DeclCode}).
@end example

Note: currently only the C and Erlang backends
support this variant of the @samp{pragma foreign_decl} declaration.

The Melbourne Mercury implementation additionally supports the forms

@example
:- pragma foreign_decl("@var{Lang}", include_file("@var{Path}")).
:- pragma foreign_decl("@var{Lang}", local, include_file("@var{Path}")).
@end example

These have the same effects as the standard forms
except that the contents of the file referenced by @var{Path}
are included in place of the string literal in the last argument,
without further interpretation.
@var{Path} may be an absolute path to a file,
or a path to a file relative to the directory
that contains the source file of the module containing the declaration.
The interpretation of the path is platform-dependent.
If the filesystem uses a different character set or encoding
from the Mercury source file (which must be UTF-8),
the file may not be found.

@samp{mmc --make} and @samp{mmake} treat included files
as dependencies of the module.

@c -----------------------------------------------------------------------

@node Declaring Mercury exports to other modules
@section Declaring Mercury exports to other modules

The declarations for Mercury predicates or functions
exported to a foreign language using a @samp{pragma foreign_export} declaration
are visible to foreign code
in a @samp{pragma foreign_code} or @samp{pragma foreign_proc} declaration
of the same module, and also in those of any submodules.
By default, they are not visible to the foreign code
in @samp{pragma foreign_code} or @samp{pragma foreign_proc} declarations
in any other module,
but this default can be overridden (giving access to all other modules)
using a declaration of the form:

@example
:- pragma foreign_import_module("@var{Lang}", @var{ImportedModule}).
@end example

@noindent
where @var{ImportedModule} is the name of the module
containing the @samp{pragma foreign_export} declarations.

If @var{Lang} is @code{"C"}, this is equivalent to

@example
:- pragma foreign_decl("C", "#include ""@var{ImportedModule}.mh""").
@end example

@noindent
where @file{@var{ImportedModule}.mh} is the automatically generated header file
containing the C declarations for the predicates and functions exported to C.

@samp{pragma foreign_import_module} should be used
instead of the explicit @code{#include}
because @samp{pragma foreign_import_module} tells the implementation
that @file{@var{ImportedModule}.mh} must be built before the object file
for the module containing the @samp{pragma foreign_import_module} declaration.

@c This sentence used to be here:
@c
@c  A cycle of @samp{pragma foreign_import_module}, where the language is
@c  @samp{"C#"} or @samp{"Java"}, is not permitted.
@c
@c but seems to be obsolete now. Julien says (on m-dev, 2019 jun 20):
@c
@c  That line (minus the bit about the Java) grade was added by Peter Ross
@c  in commit e868b11d. At the time, it was with reference to the old IL
@c  backend, the foreign languages involved were IL, C# and MC++.
@c
@c  I suspect the restriction on foreign_import_module cycles may have
@c  arisen because C# and MC++ were secondary (i.e. non-target) foreign
@c  languages. Compilation of secondary foreign languages is handled by
@c  hoisting the code out to a separate source file and that requires
@c  the foreign_import_module graph to be acyclic.
@c
@c  None of that line is applicable to C# and Java when they are the target
@c  language.

Note that the Melbourne Mercury implementation often behaves
as if @samp{pragma foreign_import_module} declarations
were implicitly added to modules.
However, programmers should @emph{not} should not depend on this behaviour;
they should always write explicit
@samp{pragma foreign_import_module} declarations wherever they are needed.

@c -----------------------------------------------------------------------

@node Adding foreign definitions
@section Adding foreign definitions

Definitions of foreign language entities
(such as functions or global variables)
may be included using a declaration of the form

@example
:- pragma foreign_code("@var{Lang}", @var{Code}).
@end example

This declaration will have effects equivalent to
including the specified @var{Code} in an automatically generated source file
of the specified programming language,
in a place appropriate for definitions,
and linking that source file with the Mercury program
(after having compiled it with a compiler
for the specified programming language, if appropriate).

Entities declared in @samp{pragma foreign_code} declarations
are visible in @samp{pragma foreign_proc} declarations
that specify the same foreign language and occur in the same Mercury module.

The Melbourne Mercury implementation additionally supports the form

@example
:- pragma foreign_code("@var{Lang}", include_file("@var{Path}")).
@end example

This has the same effect as the standard form
except that the contents of the file referenced by @var{Path}
are included in place of the string literal in the last argument,
without further interpretation.
@var{Path} may be an absolute path to a file,
or a path to a file relative to the directory
that contains the source file of the module containing the declaration.
The interpretation of the path is platform-dependent.
If the filesystem uses a different character set or encoding
from the Mercury source file (which must be UTF-8),
the file may not be found.

@samp{mmc --make} and @samp{mmake} treat included files
as dependencies of the module.

@c -----------------------------------------------------------------------

@node Language specific bindings
@section Language specific bindings

@c Please keep this menu in alphabetical order

@menu
* Interfacing with C 		:: How to write code to interface with C
* Interfacing with C# 		:: How to write code to interface with C#
* Interfacing with Java 	:: How to write code to interface with Java
* Interfacing with Erlang 	:: How to write code to interface with Erlang
@end menu

All Mercury implementations should support interfacing with C.
The set of other languages supported is implementation-defined.
A suitable compiler or assembler for the foreign language
must be available on the system.

The University of Melbourne Mercury implementation supports
interfacing with the following languages:

@table @asis

@c Please keep this table in alphabetical order

@item @samp{C}
Use the string @code{"C"} to set the foreign language to C.

@item @samp{C#}
Use the string @code{"C#"} to set the foreign language to C#.

@item @samp{Java}
Use the string @code{"Java"} to set the foreign language to Java.

@item @samp{Erlang}
Use the string @code{"Erlang"} to set the foreign language to Erlang.

@end table

@c -----------------------------------------------------------------------

@node Interfacing with C
@subsection Interfacing with C

@menu
* Using pragma foreign_type for C 	 :: Declaring C types in Mercury
* Using pragma foreign_enum for C        :: Assigning Mercury enumerations
                                            values in C
* Using pragma foreign_export_enum for C :: Using Mercury enumerations in C
* Using pragma foreign_proc for C 	 :: Calling C code from Mercury
* Using pragma foreign_export for C      :: Calling Mercury code from C
* Using pragma foreign_decl for C 	 :: Including C declarations in Mercury
* Using pragma foreign_code for C 	 :: Including C code in Mercury
* Memory management for C                :: Caveats about passing dynamically
                                            allocated memory to or from C.
* Linking with C object files            :: Linking with C object files and
                                            libraries.

@end menu

@node Using pragma foreign_type for C
@subsubsection Using pragma foreign_type for C

A C @samp{pragma foreign_type} declaration has the form:

@example
:- pragma foreign_type("C", @var{MercuryTypeName}, "@var{CForeignType}").
@end example

For example,

@example
:- pragma foreign_type("C", long_double, "long double").
@end example

The @var{CForeignType} can be any C type name
that obeys the following restrictions.
Function types, array types, and incomplete types are not allowed.
The type name must be such that when declaring a variable in C of that type,
no part of the type name is required after the variable name.
(This rule prohibits, for example,
function pointer types such as @samp{void (*)(void)};
however, it would be OK to use a typedef name
which was defined as a function pointer type.)

C preprocessor directives (such as @samp{#if})
may not be used in @var{CForeignType}.
(You can however use a typedef name that refers to a type
defined in a @samp{pragma foreign_decl} declaration,
and the @samp{pragma foreign_decl} declaration
may contain C preprocessor directives.)

@c @strong{With @samp{--gc accurate}, foreign_types which are C pointer types
@c must not point to the Mercury heap.}

If the @var{MercuryTypeName} is the type of a parameter of a procedure
defined using @samp{pragma foreign_proc},
it will be passed to the foreign_proc's foreign language code
as @var{CForeignType}.

Furthermore, any Mercury procedure exported with @samp{pragma foreign_export}
will use @var{CForeignType} as the type
for any parameters whose Mercury type is @var{MercuryTypeName}.

The builtin Mercury type @code{c_pointer} may be used
to pass C pointers between C functions which are called from Mercury.
For example:

@example
:- module pointer_example.
:- interface.

:- type complicated_c_structure.

% Initialise the abstract C structure that we pass around in Mercury.
:- pred initialise_complicated_structure(complicated_c_structure::uo) is det.

% Perform a calculation on the C structure.
:- pred do_calculation(int::in, complicated_c_structure::di,
        complicated_c_structure::uo) is det.

:- implementation.

% Our C structure is implemented as a c_pointer.
:- type complicated_c_structure
    --->    complicated_c_structure(c_pointer).

:- pragma foreign_decl("C",
   extern struct foo *init_struct(void);
   extern struct foo *perform_calculation(int, struct foo *);
");

:- pragma foreign_proc("C",
    initialise_complicated_structure(Structure::uo),
    [will_not_call_mercury, may_call_mercury],
"
    Structure = init_struct();
").

:- pragma foreign_proc("C",
    do_calculation(Value::in, Structure0::di, Structure::uo),
    [will_not_call_mercury, may_call_mercury],
"
    Structure = perform_calculation(Value, Structure0);
").
@end example

We strongly recommend the use of @samp{pragma foreign_type}
instead of @code{c_pointer}
as the use of @samp{pragma foreign_type} results in more type-safe code.

@node Using pragma foreign_enum for C
@subsubsection Using pragma foreign_enum for C

Foreign enumeration values in C must be constants of type @code{MR_Integer}.
They may be specified as either integer literals
or via preprocessor macros that expand to integer literals.

@node Using pragma foreign_export_enum for C
@subsubsection Using pragma foreign_export_enum for C

For C the symbolic names generated by a @samp{pragma foreign_export_enum}
must form valid C identifiers.
These identifiers are used as the names of preprocessor macros.
The body of each of these macros expands to a value
that is identical to that of the constructor
to which the symbolic name corresponds
in the mapping established
by the @w{@samp{pragma foreign_export_enum}} declaration.

As noted in the @ref{C data passing conventions},
the type of these values is @code{MR_Word}.

The default mapping
used by @samp{pragma foreign_export_enum} declarations for C
is to use the Mercury constructor name as the base of the symbolic name.
For example, the symbolic name for the Mercury constructor @samp{foo}
would be @code{foo}.

@c It would be useful if there were some documented way of mapping
@c these things into [0, N - 1], e.g. for array lookups.

@node Using pragma foreign_proc for C
@subsubsection Using pragma foreign_proc for C

The input and output variables
will have C types corresponding to their Mercury types,
as determined by the rules specified in @ref{C data passing conventions}.

The C code fragment may declare local variables,
up to a total size of 10kB for the procedure.
@c The relevant parameter is LOCALS_SIZE, defined in runtime/mercury_engine.c.
If a procedure requires more than this for its local variables,
the code can be moved into a separate function
(defined in a @samp{pragma foreign_code} declaration, for example).

The C code fragment should not declare any labels or static variables
unless there is also a @samp{pragma no_inline} declaration
or a @samp{may_not_duplicate} foreign code attribute for the procedure.
The reason for this is that otherwise
the Mercury implementation may inline the procedure
by duplicating the C code fragment for each call.
If the C code fragment declared a static variable,
inlining it in this way could result
in the program having multiple instances of the static variable,
rather than a single shared instance.
If the C code fragment declared a label,
inlining it in this way could result in an error
due to the same label being defined twice inside a single C function.

C code in a @code{pragma foreign_proc} declaration
for any procedure whose determinism indicates that it can fail
must assign a truth value to the macro @code{SUCCESS_INDICATOR}.
For example:

@example
:- pred string.contains_char(string, character).
:- mode string.contains_char(in, in) is semidet.

:- pragma foreign_proc("C",
    string.contains_char(Str::in, Ch::in),
    [will_not_call_mercury, promise_pure],
"
    SUCCESS_INDICATOR = (strchr(Str, Ch) != NULL);
").
@end example

@code{SUCCESS_INDICATOR} should not be used
other than as the target of an assignment.
(For example, it may be @code{#define}d to a register,
so you should not try to take its address.)
Procedures whose determinism indicates that they cannot fail
should not access @code{SUCCESS_INDICATOR}.

Arguments whose mode is input
will have their values set by the Mercury implementation
on entry to the C code.
If the procedure succeeds,
the C code must set the values of all output arguments.
If the procedure fails,
the C code need only set @code{SUCCESS_INDICATOR} to false (zero).

The behaviour of a procedure
defined using a @samp{pragma foreign_proc} declaration
whose body contains a @code{return} statement is undefined.

@node Using pragma foreign_export for C
@subsubsection Using pragma foreign_export for C

A @samp{pragma foreign_export} declaration for C has the form:

@example
:- pragma foreign_export("C", @var{MercuryMode}, "@var{C_Name}").
@end example

For example,

@example
:- pragma foreign_export("C", foo(in, in, out), "FOO").
@end example

For each Mercury module
containing @samp{pragma foreign_export} declarations for C,
the Mercury implementation
will automatically create a header file for that module
which declares a C function @var{C_Name}()
for each of the @samp{pragma foreign_export} declarations.
Each such C function is the C interface to the specified Mercury procedure.

The type signature of the C interface to a Mercury procedure
is determined as follows.
Mercury types are converted to C types
according to the rules in @ref{C data passing conventions}.
Input arguments are passed by value.
For output arguments,
the caller must pass the address in which to store the result.
If the Mercury procedure can fail,
then its C interface function returns a truth value
indicating success or failure.
If the Mercury procedure is a Mercury function that cannot fail,
and the function result has an output mode,
then the C interface function will return the Mercury function result value.
Otherwise the function result is appended as an extra argument.
@c XXX We need to update this for dummy unit types.
Arguments of type @samp{io.state} or @samp{store.store(_)}
are not passed at all.
(The reason for this is that these types represent mutable state,
and in C modifications to mutable state are done via side effects,
rather than argument passing.)

Calling polymorphically typed Mercury procedures from C
is a little bit more difficult
than calling ordinary (monomorphically typed) Mercury procedures.
The simplest method is to just create monomorphic forwarding procedures
that call the polymorphic procedures, and export them,
rather than exporting the polymorphic procedures.

If you do export a polymorphically typed Mercury procedure,
the compiler will prepend one @samp{type_info} argument
to the parameter list of the C interface function
for each distinct type variable in the Mercury procedure's type signature.
The caller must arrange to pass in appropriate @samp{type_info} values
corresponding to the types of the other arguments passed.
These @samp{type_info} arguments can be obtained
using the Mercury @samp{type_of} function
in the Mercury standard library module @samp{type_desc}.

To use the C declarations produced see @ref{Using pragma foreign_decl for C}.

Throwing an exception across the C interface is not supported.
That is, if a Mercury procedure that is exported to C using
@samp{pragma foreign_export} throws an exception
which is not caught within that procedure,
then you will get undefined behaviour.

@node Using pragma foreign_decl for C
@subsubsection Using pragma foreign_decl for C

Any macros, function prototypes, or other C declarations
that are used in @samp{foreign_code}, @samp{foreign_type}
or @samp{foreign_proc} pragmas
must be included using a @samp{foreign_decl} declaration of the form

@example
:- pragma foreign_decl("C", @var{HeaderCode}).
@end example

@noindent
@var{HeaderCode} can be a C @samp{#include} line, for example

@example
:- pragma foreign_decl("C", "#include <math.h>")
@end example

@noindent
or

@example
:- pragma foreign_decl("C", "#include ""tcl.h""").
@end example

@noindent
or it may contain any C declarations, for example

@example
:- pragma foreign_decl("C", "
        extern int errno;
        #define SIZE 200
        struct Employee @{
                char name[SIZE];
        @};
        extern int bar;
        extern void foo(void);
").
@end example

Mercury automatically includes certain headers such as @code{<stdlib.h>},
but you should not rely on this,
as the set of headers which Mercury automatically includes
is subject to change.

If a Mercury predicate or function exported
using a @samp{pragma foreign_export} declaration
is to be used within a @samp{:- pragma foreign_code}
or @samp{:- pragma foreign_proc} declaration
the header file for the module containing
the @samp{pragma foreign_export} declaration
should be included using a @samp{pragma foreign_import_module} declaration,
for example

@example
:- pragma foreign_import_module("C", exporting_module).
@end example

@node Using pragma foreign_code for C
@subsubsection Using pragma foreign_code for C

Definitions of C functions or global variables
may be included using a declaration of the form

@example
:- pragma foreign_code("C", @var{Code}).
@end example

For example,

@example
:- pragma foreign_code("C", "
        int bar = 42;
        void foo(void) @{@}
").
@end example

Such code is copied verbatim into the generated C file.

@node Memory management for C
@subsubsection Memory management for C

Passing pointers to dynamically-allocated memory
from Mercury to code written in other languages, or vice versa,
is in general implementation-dependent.

The current Mercury implementation
supports two different methods of memory management:
conservative garbage collection, or no garbage collection.
The latter is suitable only for programs
with very short running times (less than a second),
which makes the former the standard method for almost all Mercury programs.

Conservative garbage collection makes inter-language calls simplest.
Mercury uses the Boehm-Demers-Weiser conservative garbage collector,
which we also call simply Boehm gc.
This has its own set of functions for allocating memory blocks,
such as @samp{MR_GC_NEW},
which are documented in @file{runtime/mercury_memory.h}.
Memory blocks allocated by these functions,
either in C code generated by the Mercury compiler
or in C code hand written by programmers,
are automatically reclaimed when they are no longer referred to
either from the stack, from global variables,
or from other memory blocks allocated by Boehm gc functions.
Note that these are the @emph{only} places
where Boehm gc looks for pointers to the blocks it has allocated.
If the only pointers to such a block occur in other parts of memory,
such as in memory blocks allocated by @samp{malloc},
the Boehm collector won't see them, and may collect the block prematurely.
Programmers can avoid this either
by not storing pointers to Boehm-allocated memory in malloc-allocated blocks,
or by storing them e.g. on the stack as well.

Boehm gc recognizes pointers to the blocks it has allocated
only if they point either to the start to the block,
or to a byte in the first word of the block;
pointers into the middle of a block beyond the first word
won't keep the block alive.

Pointers to Boehm-allocated memory blocks
can be passed freely between Mercury and C code
provided these restrictions are observed.

Note that the Boehm collector cannot and does not recover
memory allocated by other methods, such as @samp{malloc}.

When using no garbage collection,
heap storage is reclaimed only on backtracking.
This requires programmers to be careful
not to retain pointers to memory on the Mercury heap
after Mercury has backtracked
to before the point where that memory was allocated.
They must also avoid the use of the macros
@code{MR_list_empty()} and @code{MR_list_cons()}.
(The reason for this is that they may access Mercury's @samp{MR_hp} register,
which might not be valid in C code.
Using them in the bodies of procedures
defined using @samp{pragma foreign_proc} with
@samp{will_not_call_mercury} would probably work,
but we don't advise it.)
Instead, you can write Mercury functions to perform these actions
and use @samp{pragma foreign_export} to access them from C.
This alternative method also works with conservative garbage collection.

Future Mercury implementations
may use non-conservative methods of garbage collection.
For such implementations,
it will be necessary to explicitly register pointers passed to C
with the garbage collector.
The mechanism for doing this has not yet been decided on.
It would be desirable to provide a single memory management interface
for use when interfacing with other languages
that can work for all methods of memory management,
but more implementation experience is needed
before we can formulate such an interface.

@node Linking with C object files
@subsubsection Linking with C object files

A Mercury implementation should allow you
to link with object files or libraries that were produced by compiling C code.
The exact mechanism for linking with C object files
is implementation-dependent.
The following text describes how it is done
for the University of Melbourne Mercury implementation.

To link an existing object file or archive of object files
into your Mercury code,
use the command line option @samp{--link-object}.
For example, the following will link the object file @samp{my_function.o}
from the current directory when compiling the program @samp{prog}:

@example
mmc --link-object my_functions.o prog
@end example

The command line option @samp{--library} (or @samp{-l} for short)
can be used to link an existing library into your Mercury code.
For example, the following will link the library file @file{libfancy_library.a},
or perhaps the shared version @file{libfancy_library.so},
from the directory @file{/usr/local/contrib/lib},
when compiling the program @samp{prog}:

@example
mmc -R/usr/local/contrib/lib -L/usr/local/contrib/lib -lfancy_library prog
@end example

As illustrated by the example,
the command line options @samp{-R}, @samp{-L} and @samp{-l},
have the same meaning as they do with the Unix linker.

For more information,
see the ``Libraries'' chapter of the Mercury User's Guide.

@c ----------------------------------------------------------------------------

@node Interfacing with C#
@subsection Interfacing with C#

@menu
* Using pragma foreign_type for C#	:: Declaring C# types in Mercury
* Using pragma foreign_enum for C#      :: Assigning Mercury enumerations
                                           values in C#
* Using pragma foreign_export_enum for C# :: Using Mercury enumerations in C#
* Using pragma foreign_proc for C# 	:: Calling C# code from Mercury
* Using pragma foreign_export for C#    :: Calling Mercury code from C#
* Using pragma foreign_decl for C# 	:: Including C# declarations in Mercury
* Using pragma foreign_code for C# 	:: Including C# code in Mercury
@end menu

@node Using pragma foreign_type for C#
@subsubsection Using pragma foreign_type for C#

A C# @samp{pragma foreign_type} declaration has the form:

@example
:- pragma foreign_type("C#", @var{MercuryTypeName}, "@var{C#-Type}").
@end example

The @var{C#-Type} can be any accessible C# type.

The effect of this declaration is that
Mercury values of type @var{MercuryTypeName}
will be passed to and from C# foreign_procs as having type @var{C#-Type}.

Furthermore, any Mercury procedure exported with @samp{pragma foreign_export}
will use @var{C#-Type} as the type
for any parameters whose Mercury type is @var{MercuryTypeName}.

@node Using pragma foreign_enum for C#
@subsubsection Using pragma foreign_enum for C#

Foreign enumeration values in C# must be a constant value expression
which is a valid initializer
within an enumeration of underlying type @code{int}.

@node Using pragma foreign_export_enum for C#
@subsubsection Using pragma foreign_export_enum for C#

For C# the symbolic names generated by a @samp{pragma foreign_export_enum}
must form valid C# identifiers.
These identifiers are used as the names of static class members.

The default mapping
used by @samp{pragma foreign_export_enum} declarations for C#
is to use the Mercury constructor name as the base of the symbolic name.
For example, the symbolic name for the Mercury constructor @samp{foo}
would be @code{foo}.

@node Using pragma foreign_proc for C#
@subsubsection Using pragma foreign_proc for C#

The C# code from C# @samp{pragma foreign_proc} declarations
will be placed in the bodies of static member functions
of an automatically generated C# class.
Since such C# code will become part of a static member function,
it must not refer to the @code{this} keyword.
It may however refer to static member variables or static member functions
declared with @samp{pragma foreign_code}.

The input and output variables for a C# @samp{pragma foreign_proc}
will have C# types corresponding to their Mercury types.
The exact rules for mapping Mercury types to C# types
are described in @ref{C# data passing conventions}.

C# code in a @code{pragma foreign_proc} declaration
for any procedure whose determinism indicates that it can fail
must assign a value of type @code{bool}
to the variable @code{SUCCESS_INDICATOR}.
For example:

@example
:- pred string.contains_char(string, character).
:- mode string.contains_char(in, in) is semidet.

:- pragma foreign_proc("C#",
    string.contains_char(Str::in, Ch::in),
    [will_not_call_mercury, promise_pure],
"
    SUCCESS_INDICATOR = (Str.IndexOf(Ch) != -1);
").
@end example

@noindent
C# code for procedures whose determinism indicates that they cannot fail
should not access @code{SUCCESS_INDICATOR}.

Arguments whose mode is input
will have their values set by the Mercury implementation
on entry to the C# code.
If the procedure succeeds,
the C# code must set the values of all output arguments.
If the procedure fails,
the C# code need only set @code{SUCCESS_INDICATOR} to false.

@node Using pragma foreign_export for C#
@subsubsection Using pragma foreign_export for C#

A @samp{pragma foreign_export} declaration for C# has the form:

@example
:- pragma foreign_export("C#", @var{MercuryMode}, "@var{C#_Name}").
@end example

For example,

@example
:- pragma foreign_export("C#", foo(in, in, out), "FOO").
@end example

The type signature of the C# interface to a Mercury procedure
is as described in @ref{C# data passing conventions}.

Calling polymorphically typed Mercury procedures from C#
is a little bit more difficult
than calling ordinary (monomorphically typed) Mercury procedures.
The simplest method is to just create monomorphic forwarding procedures
that call the polymorphic procedures, and export them,
rather than exporting the polymorphic procedures.

If you do export a polymorphically typed Mercury procedure,
the compiler will prepend one @samp{type_info} argument
to the parameter list of the C# interface function
for each distinct type variable in the Mercury procedure's type signature.
The caller must arrange to pass in appropriate @samp{type_info} values
corresponding to the types of the other arguments passed.
These @samp{type_info} arguments can be obtained
using the Mercury @samp{type_of} function
in the Mercury standard library module @samp{type_desc}.

@node Using pragma foreign_decl for C#
@subsubsection Using pragma foreign_decl for C#

@samp{pragma foreign_decl} declarations for C#
can be used to provide any top-level C# declarations
(e.g.@: @samp{using} declarations or auxiliary class definitions)
which are needed by C# code in @samp{pragma foreign_proc} declarations
in that module.

For example:

@example
:- pragma foreign_decl("C#", "
	using System;
").
:- pred hello(io.state::di, io.state::uo) is det.
:- pragma foreign_proc("C#",
     hello(_IO0::di, _IO::uo),
     [will_not_call_mercury, promise_pure],
"
    // here we can refer directly to Console rather than System.Console
    Console.WriteLine(""hello world"");
").
@end example

@node Using pragma foreign_code for C#
@subsubsection Using pragma foreign_code for C#

The C# code from @samp{pragma foreign_proc} declarations for C#
will be placed in the bodies of static member functions
of an automatically generated C# class.
@samp{pragma foreign_code} can be used to define
additional members of this automatically generated class,
which can then be referenced by @samp{pragma foreign_proc} declarations
for C# from that module.

For example:

@example
:- pragma foreign_code("C#", "
    static int counter = 0;
").

:- impure pred incr_counter is det.
:- pragma foreign_proc("C#",
    incr_counter,
    [will_not_call_mercury], "
    counter++;
").

:- semipure func get_counter = int.
:- pragma foreign_proc("C#",
    get_counter = (Result::out),
    [will_not_call_mercury, promise_semipure],
"
    Result = counter;
").
@end example

@c ----------------------------------------------------------------------------

@node Interfacing with Java
@subsection Interfacing with Java

@menu
* Using pragma foreign_type for Java :: Declaring Java types in Mercury
* Using pragma foreign_enum for Java :: Assigning Mercury enumerations
                                        values in Java
* Using pragma foreign_export_enum for Java :: Using Mercury enumerations in
                                               Java
* Using pragma foreign_proc for Java :: Calling Java code from Mercury
* Using pragma foreign_export for Java :: Calling Mercury from Java code
* Using pragma foreign_decl for Java :: Including Java declarations in Mercury
* Using pragma foreign_code for Java :: Including Java code in Mercury
@end menu


@node Using pragma foreign_type for Java
@subsubsection Using pragma foreign_type for Java

A Java @samp{pragma foreign_type} declaration has the form:

@example
:- pragma foreign_type("Java", @var{MercuryTypeName}, "@var{JavaType}").
@end example

The @var{JavaType} can be any accessible Java type.

The effect of this declaration is that
Mercury values of type @var{MercuryTypeName}
will be passed to and from Java foreign_procs as having type @var{JavaType}.

Furthermore, any Mercury procedure exported with @samp{pragma foreign_export}
will use @var{JavaType} as the type
for any parameters whose Mercury type is @var{MercuryTypeName}.

@node Using pragma foreign_enum for Java
@subsubsection Using pragma foreign_enum for Java

@samp{pragma foreign_enum} is currently not supported for Java.

@node Using pragma foreign_export_enum for Java
@subsubsection Using pragma foreign_export_enum for Java

For Java the symbolic names generated by a @samp{pragma foreign_export_enum}
must form valid Java identifiers.
These identifiers are used as the names of static class members
which are assigned instances of the enumeration class.

The @code{equals} method should be used
for equality testing of enumeration values in Java code.

The default mapping
used by @samp{pragma foreign_export_enum} declarations for Java
is to use the Mercury constructor name as the base of the symbolic name.
For example, the symbolic name for the Mercury constructor @samp{foo}
would be @code{foo}.

@node Using pragma foreign_proc for Java
@subsubsection Using pragma foreign_proc for Java

The Java code from Java @samp{pragma foreign_proc} declarations
will be placed in the bodies of static member functions
of an automatically generated Java class.
Since such Java code will become part of a static member function,
it must not refer to the @code{this} keyword.
It may however refer to static member variables or static member functions
declared with @samp{pragma foreign_code}.

The input and output variables for a Java @samp{pragma foreign_proc}
will have Java types corresponding to their Mercury types.
The exact rules for mapping Mercury types to Java types
are described in @ref{Java data passing conventions}.

The Java code in a @code{pragma foreign_proc} declaration
for a procedure whose determinism indicates that it can fail
must assign a value of type @code{boolean}
to the variable @code{SUCCESS_INDICATOR}.
For example:

@example
:- pred string.contains_char(string, character).
:- mode string.contains_char(in, in) is semidet.

:- pragma foreign_proc("Java",
    string.contains_char(Str::in, Ch::in),
    [will_not_call_mercury, promise_pure],
"
    SUCCESS_INDICATOR = (Str.IndexOf(Ch) != -1);
").
@end example

@noindent
Java code for procedures whose determinism indicates that they cannot fail
should not refer to the @code{SUCCESS_INDICATOR} variable.

Arguments whose mode is input
will have their values set by the Mercury implementation
on entry to the Java code.
With our current implementation,
the Java code must set the values of all output variables,
even if the procedure fails
(i.e. sets the @code{SUCCESS_INDICATOR} variable to @code{false}).
@c If the procedure
@c succeeds, the Java code must set the values of all output arguments
@c If the procedure fails, the Java code need only
@c set the @code{SUCCESS_INDICATOR} variable to false.

@node Using pragma foreign_export for Java
@subsubsection Using pragma foreign_export for Java

A @samp{pragma foreign_export} declaration for Java has the form:

@example
:- pragma foreign_export("Java", @var{MercuryMode}, "@var{Java_Name}").
@end example

For example,

@example
:- pragma foreign_export("Java", foo(in, in, out), "FOO").
@end example

The type signature of the Java interface to a Mercury procedure
is as described in @ref{Java data passing conventions}.

Calling polymorphically typed Mercury procedures from Java
is a little bit more difficult
than calling ordinary (monomorphically typed) Mercury procedures.
The simplest method is to just create monomorphic forwarding procedures
that call the polymorphic procedures, and export them,
rather than exporting the polymorphic procedures.

If you do export a polymorphically typed Mercury procedure,
the compiler will prepend one @samp{type_info} argument
to the parameter list of the Java interface function
for each distinct type variable in the Mercury procedure's type signature.
The caller must arrange to pass in appropriate @samp{type_info} values
corresponding to the types of the other arguments passed.
These @samp{type_info} arguments can be obtained
using the Mercury @samp{type_of} function
in the Mercury standard library module @samp{type_desc}.

@node Using pragma foreign_decl for Java
@subsubsection Using pragma foreign_decl for Java

@samp{pragma foreign_decl} declarations for Java
can be used to provide any top-level Java declarations
(e.g.@: @samp{import} declarations or auxiliary class definitions)
which are needed by Java code in @samp{pragma foreign_proc} declarations
in that module.

For example:

@example
:- pragma foreign_decl("Java", "
import javax.swing.*;
import java.awt.*;

class MyApplet extends JApplet @{
    public void init() @{
        JLabel label = new JLabel(""Hello, world"");
        label.setHorizontalAlignment(JLabel.CENTER);
        getContentPane().add(label);
    @}
@}
").
:- pred hello(io.state::di, io.state::uo) is det.
:- pragma foreign_proc("Java",
    hello(_IO0::di, _IO::uo),
    [will_not_call_mercury],
"
    MyApplet app = new MyApplet();
    // @dots{}
").
@end example

@node Using pragma foreign_code for Java
@subsubsection Using pragma foreign_code for Java

The Java code from @samp{pragma foreign_proc} declarations for Java
will be placed in the bodies of static member functions
of an automatically generated Java class.
@samp{pragma foreign_code} can be used to define additional members
of this automatically generated class,
which can then be referenced by @samp{pragma foreign_proc} declarations
for Java from that module.

For example:

@example
:- pragma foreign_code("Java", "
    static int counter = 0;
").

:- impure pred incr_counter is det.
:- pragma foreign_proc("Java",
    incr_counter,
    [will_not_call_mercury],
"
    counter++;
").

:- semipure func get_counter = int.
:- pragma foreign_proc("Java",
    get_counter = (Result::out),
    [will_not_call_mercury, promise_semipure],
"
    Result = counter;
").
@end example

@c ----------------------------------------------------------------------------

@node Interfacing with Erlang
@subsection Interfacing with Erlang

@menu
* Using pragma foreign_type for Erlang :: Declaring Erlang types in Mercury
* Using pragma foreign_export_enum for Erlang :: Using Mercury enumerations in
                                               Erlang
* Using pragma foreign_proc for Erlang :: Calling Erlang code from Mercury
* Using pragma foreign_export for Erlang :: Calling Mercury from Erlang code
* Using pragma foreign_decl for Erlang :: Including Erlang declarations in Mercury
* Using pragma foreign_code for Erlang :: Including Erlang code in Mercury
@end menu


@node Using pragma foreign_type for Erlang
@subsubsection Using pragma foreign_type for Erlang

An Erlang @samp{pragma foreign_type} declaration has the form:

@example
:- pragma foreign_type("Erlang", @var{MercuryTypeName}, "").
@end example

The effect of this declaration is that
Mercury values of type @var{MercuryTypeName}
will be passed to and from Erlang foreign_procs
as having some representation unknown to Mercury.

@node Using pragma foreign_export_enum for Erlang
@subsubsection Using pragma foreign_export_enum for Erlang

Values of Mercury enumeration types may be referred to from Erlang code
using the convention for discriminated union types
described in @ref{Erlang data passing conventions}.
As such, @samp{pragma foreign_export_enum} declarations
are neither required or supported for Erlang.

@node Using pragma foreign_proc for Erlang
@subsubsection Using pragma foreign_proc for Erlang

The input and output variables for a Erlang @samp{pragma foreign_proc}
will be the Erlang representations
as described in @ref{Erlang data passing conventions}.

The Erlang code in a @code{pragma foreign_proc} declaration
for a procedure whose determinism indicates that it can fail
must assign either @samp{true} or @samp{false}
to the variable @code{SUCCESS_INDICATOR}.
For example:

@example
:- pred contains_char(list(char)::in, char::in) is semidet.

:- pragma foreign_proc("Erlang",
    contains_char(Str::in, Ch::in),
    [will_not_call_mercury, promise_pure, thread_safe],
"
    SUCCESS_INDICATOR = (string:chr(Str, Ch) =/= 0)
").
@end example

Arguments whose mode is input
will have their values set by the Mercury implementation
on entry to the Erlang code.
The Erlang code must set the values of all output variables,
even if the procedure fails
(i.e. sets the @code{SUCCESS_INDICATOR} variable to @code{false}).

@node Using pragma foreign_export for Erlang
@subsubsection Using pragma foreign_export for Erlang

A @samp{pragma foreign_export} declaration for Erlang has the form:

@example
:- pragma foreign_export("Erlang", @var{MercuryMode}, "@var{Erlang_Name}").
@end example

For example,

@example
:- pragma foreign_export("Erlang", foo(in, in, out), "foo").
@end example

The type signature of the Erlang interface to a Mercury procedure
is described in @ref{Erlang data passing conventions}.

Calling polymorphically typed Mercury procedures from Erlang
is a little bit more difficult
than calling ordinary (monomorphically typed) Mercury procedures.
The simplest method is to just create monomorphic forwarding procedures
that call the polymorphic procedures, and export them,
rather than exporting the polymorphic procedures.

If you do export a polymorphically typed Mercury procedure,
the compiler will prepend one @samp{type_info} argument
to the parameter list of the Erlang interface function
for each distinct type variable in the Mercury procedure's type signature.
The caller must arrange to pass in appropriate @samp{type_info} values
corresponding to the types of the other arguments passed.
These @samp{type_info} arguments can be obtained
using the Mercury @samp{type_of} function
in the Mercury standard library module @samp{type_desc}.

@node Using pragma foreign_decl for Erlang
@subsubsection Using pragma foreign_decl for Erlang

@samp{pragma foreign_decl} declarations for Erlang
can be used to provide any top-level Erlang declarations
(e.g.@: @samp{-define} macro declarations) which are needed by Erlang code.

@samp{pragma foreign_decl} blocks
which do not have the @samp{local} attribute
will be copied into the @samp{.hrl} header file for that module,
and automatically included by other modules that import the module.
Therefore @samp{-export} directives and Erlang module attributes
should only appear in @samp{local} blocks.

For example:

@example
:- pragma foreign_decl("Erlang", "
    -define(FOO, 42).
").
:- pred hello(io.state::di, io.state::uo) is det.
:- pragma foreign_proc("Erlang",
    hello(_IO0::di, _IO::uo),
    [will_not_call_mercury, promise_pure],
"
    io:format(""FOO = ~w~n"", [?FOO])
").
@end example

@node Using pragma foreign_code for Erlang
@subsubsection Using pragma foreign_code for Erlang

@samp{pragma foreign_code} can be used to define additional Erlang functions
which can then be referenced by @samp{pragma foreign_proc} declarations
for Erlang from that module.
By adding @samp{-export} directives
inside @samp{pragma foreign_decl} declarations,
those functions can additionally be called from outside the defining module.

For example:

@example
:- pragma foreign_code("Erlang", "
    foo() -> io:put_chars(""Foo."").
").

:- impure pred say_foo is det.
:- pragma foreign_proc("Erlang",
    say_foo,
    [will_not_call_mercury],
"
    foo()
").
@end example

@c ----------------------------------------------------------------------------

@node Impurity
@chapter Impurity declarations

In order to efficiently implement certain predicates,
it is occasionally necessary to venture outside pure logic programming.
Other predicates cannot be implemented at all
within the paradigm of logic programming,
for example, all solutions predicates.
Such predicates are often written using the foreign language interface.
Sometimes, however, it would be more convenient, or more efficient,
to write such predicates using the facilities of Mercury.
For example, it is much more convenient to access
arguments of compound Mercury terms in Mercury than in C,
and the ability of the Mercury compiler to specialize code
can make higher-order predicates written in Mercury
significantly more efficient than similar C code.

One important aim of Mercury's impurity system
is to make the distinction between the pure and impure code very clear.
This is done by requiring every impure predicate or function to be so declared,
and by requiring every call to an impure predicate or function
to be flagged as such.
Predicates or functions that are implemented
in terms of impure predicates or functions
are assumed to be impure themselves
unless they are explicitly promised to be pure.

Please note that the facilities described here are needed only very rarely.
The main intent is for implementing language primitives
such as the all solutions predicates,
or for implementing interfaces to foreign language libraries
using the foreign language interface.
Any other use of @samp{impure} or @samp{semipure} probably indicates
either a weakness in the Mercury standard library,
or the programmer's lack of familiarity with the standard library.
Newcomers to Mercury are hence encouraged to @strong{skip this section}.

@menu
* Purity levels::       	Choosing the right level of purity.
* Purity ordering::     	How purity levels are ordered
* Impurity semantics::  	What impure code means.
* Declaring impurity::  	Declaring predicates impure.
* Impure goals::        	Marking a goal as impure.
* Promising purity::    	Promising that a predicate is pure.
* Impurity example::    	A simple example using impurity.
* Higher-order impurity::    	Using impurity with higher-order code.
@end menu


@node Purity levels
@section Choosing the right level of purity

Mercury distinguishes three ``levels'' of purity:

@table @dfn
@item pure
For pure procedures,
the set of solutions depends only on the values of the input arguments.
They do not interact with the ``real'' world (i.e., do any input/output)
without taking an io.state (@pxref{Types}) as input
and returning one as output,
and do not change the value of any data structure
that will not be undone on backtracking
(unless the data structure would be unreachable on backtracking).
Note that equality axioms are important
when considering the value of data structures.
The declarative semantics of pure predicates
is never affected by the invocation of other predicates.
It is possible for the invocation of pure predicates
to affect the operational behaviour of non-pure predicates and vice versa.

By default, Mercury predicates and functions are pure.
Without using the foreign language interface,
writing mode-specific clauses
or calling other impure predicates and functions,
it is impossible to write impure code in Mercury.

@item semipure
Semipure predicates are just like pure predicates,
except that their declarative semantics may be affected
by the invocation of impure predicates.
That is, they are sensitive to the state of the computation
other than as reflected by their input arguments,
though they do not affect the state themselves.

@item impure
Impure predicates may perform I/O or modify hidden state,
even if these side effects alter the operational semantics of other code.
However, impure predicates may not change
the declarative semantics of pure code.
They must be type-, mode-, determinism- and uniqueness correct.

@end table

@node Purity ordering
@section Purity ordering

The three levels of purity have a total ordering defined upon them
(which we will simply call the purity),
where @code{pure > semipure > impure}.

@node Impurity semantics
@section Semantics

It is important to the proper operation of impure and semipure code,
to the flexibility of the compiler to optimize pure code,
and to the semantics of the Mercury language,
that a clear distinction be drawn
between ordinary Mercury code and imperative code written with Mercury syntax.
How this distinction is drawn will be explained below;
the purpose of this section
is to explain the semantics of programs with impure predicates.

A @emph{declarative} semantics of impure Mercury code
would be largely useless,
because the declarative semantics cannot capture the intent of the programmer.
Impure predicates are executed for their side-effects,
which by definition are not part of their declarative semantics.
Thus it is the @emph{operational} semantics of impure predicates
that Mercury must specify, and Mercury implementations must respect.

The operational semantics
of a Mercury predicate which invokes @emph{impure} code
is a modified form of the @emph{strict sequential} semantics
(@pxref{Semantics}).
@emph{Impure} goals may not be reordered relative to any other goals;
not even ``minimal'' reordering as implied by the modes is permitted.
If any such reordering is needed, this is a mode error.
However, @emph{pure} and @emph{semipure} goals
may be reordered as the compiler desires
(within the bounds of the semantics the user has specified for the program)
as long as they are not moved across an impure goal.
Execution of impure goals is strict: they must be executed if they are reached,
even if it can be determined that
the computation cannot lead to successful termination.

Semipure goals can be given a ``contextual'' declarative semantics.
They cannot have any side-effects,
so it is expected that,
given the context in which they are called
(relative to any impure goals in the program),
their declarative semantics fully captures the intent of the programmer.
Thus a semipure goal has a perfectly consistent declarative semantics,
until an impure goal is reached.
After that, it has another (possibly different) declarative semantics,
until the next impure goal is executed, and so on.
Mercury implementations must respect
this contextual nature of the semantics of semipure goals;
within a single context,
an implementation may treat a semipure goal as if it were pure.

@node Declaring impurity
@section Declaring impure functions and predicates

Every Mercury predicate or function
has exactly two purity values associated with it.
One is the @emph{declared} purity of the predicate or function,
which is given by the programmer.
The other value is the @emph{inferred} purity,
which is calculated from the purity of goals
in the body of the predicate or function.

A predicate is declared to be impure or semipure
by preceding the word @code{pred} in its @code{pred} declaration
with @code{impure} or @code{semipure}, respectively.
Similarly, a function is declared impure or semipure
by preceding the word @code{func} in its @code{func} declaration
with @code{impure} or @code{semipure}.
That is, the declarations

@example
:- impure pred @var{Pred}(@var{Arguments}@dots{}).
:- semipure pred @var{Pred}(@var{Arguments}@dots{}).
:- impure func @var{Func}(@var{Arguments}@dots{}) = @var{Result}.
:- semipure func @var{Func}(@var{Arguments}@dots{}) = @var{Result}.
@end example

@noindent
declare the predicate @var{Pred} and the function @var{Func}
to be impure and semipure, respectively.

Type class methods may also be declared as @code{impure} or @code{semipure}
by preceding the word @code{pred} or @code{func}
with the appropriate purity level.
An instance of the type class must provide method implementations
that are at least as pure as the method declaration.

@node Impure goals
@section Marking a goal as impure

If predicate @code{p/N} is declared to be @code{impure} (@code{semipure})
then all calls to @code{p/N} must be annotated
with @code{impure} (@code{semipure}):

@example
impure p(X1, X2, @dots{}, XN)
@end example

If function @code{f/N} is declared to be @code{impure} (@code{semipure})
then all applications of @code{f/N}
must be obtained by unification with a variable
and the unification goal as a whole be annotated with @code{impure}

@example
impure X = f(X1, X2, @dots{}, XN)
@end example

Any call or unification goal containing a non-local variable
with inst @code{any} that appears in a negated context
(i.e., in a negation or in the condition of an if-then-else goal)
must be given an @code{impure} annotation
because it may violate referential transparency.

Compound goals should not have purity annotations.

The compiler will report an error
if a required purity annotation is omitted from a call or unification goal
or if a @code{semipure} annotation is used
where an @code{impure} annotation is required.
The compiler will report a warning
if a semipure goal is annotated with @code{impure}
or a pure goal is annotated with @code{semipure}.

The requirement that impure or semipure calls
be marked with @code{impure} or @code{semipure}
allows someone reading the code to tell which goals are not pure,
making code which relies on side effects somewhat less mysterious.
Furthermore, it means that
if a call is @emph{not} preceded by @code{impure} or @code{semipure},
then the reader can rely on the call having a proper declarative semantics,
without hidden side-effects.

@node Promising purity
@section Promising that a predicate is pure

Predicates that are implemented in terms of impure or semipure predicates
are assumed to have the least of the purity of the goals in their body.
The declared purity of a predicate
must not be more pure than the inferred purity;
if it is, the compiler must generate an error.
If the declared purity is less pure than the inferred purity,
the compiler should issue a warning
(this is similar to the above case for goals).
Because the inferred purity of the predicate
is calculated from the declared purity of the calls it executes,
the lowest purity bound is propagated up
from callee to caller through the program.

In some cases,
the impurity of a predicate's body is an implementation detail
which should not be exposed to callers.
These predicates are pure or semipure
even though they call impure or semipure predicates.
The only way for the programmer to stop the propagation of impurity
is to explicitly promise that the predicate or function is pure or semipure.

Of course, the Mercury compiler cannot verify
that the predicate's purity matches the promise,
so it is the programmer's responsibility to ensure this.
If a predicate is promised pure or semipure and is not,
the behaviour of the program is undefined.

The programmer may promise that a predicate or function is pure or semipure
using the @code{promise_pure} and @code{promise_semipure} pragmas:

@example
:- pragma promise_pure(@var{Name}/@var{Arity}).
:- pragma promise_semipure(@var{Name}/@var{Arity}).
@end example

Programmers should be very careful
about mixing code that is promised pure
with impure predicates or functions that may manipulate the same hidden state
(for example, the impure predicates
used to implement a predicate that is promised pure);
the @samp{promise_pure} declaration is supposed to promise that
impure code cannot change the declarative semantics of pure code.
The module system can be used to minimize the possibility
of making errors with such code,
by keeping impure predicates or functions
behind the interface where code is promised pure.

Note that the @samp{promise_pure}, @samp{promise_semipure},
and @samp{promise_impure} scopes described in @ref{Goals}
may be used to promise purity at the finer level of goals within clauses.

@node Impurity example
@section An example using impurity

The following example illustrates
how a pure predicate may be implemented using impure code.
Note that this code is not reentrant, and so is not useful as is.
It is meant only as an example.

@example
:- pragma foreign_decl("C", "#include <limits.h>").
:- pragma foreign_decl("C", "extern MR_Integer max;").

:- pragma foreign_code("C", "MR_Integer max;").

:- impure pred init_max is det.
:- pragma foreign_proc("C",
    init_max,
    [will_not_call_mercury],
"
    max = INT_MIN;
").

:- impure pred set_max(int::in) is det.
:- pragma foreign_proc("C",
   set_max(X::in),
   [will_not_call_mercury],
"
    if (X > max) max = X;
").

:- semipure func get_max = (int::out) is det.
:- pragma foreign_proc("C",
    get_max = (X::out),
    [promise_semipure, will_not_call_mercury],
"
    X = max;
").

:- pragma promise_pure(max_solution/2).
:- pred max_solution(pred(int), int).
:- mode max_solution(pred(out) is multi, out) is det.

max_solution(Generator, Max) :-
    impure init_max,
    (
        Generator(X),
        impure set_max(X),
        fail
    ;
        semipure Max = get_max
    ).
@end example

@node Higher-order impurity
@section Using impurity with higher-order code

Higher-order code can manipulate impure or semipure predicates and functions,
provided that explicit purity annotations are used in three places:
on the higher-order types, on lambda expressions, and on higher-order calls.
(There are no purity annotations on higher-order insts and modes, however.)

@menu
* Purity annotations on higher-order types::
* Purity annotations on lambda expressions::
* Purity annotations on higher-order calls::
@end menu

@node Purity annotations on higher-order types
@subsection Purity annotations on higher-order types

Ordinary higher-order types,
such as @samp{pred(T1, T2)} and @samp{func(T1, T2) = T},
represent only pure predicates or pure functions.
But for each ordinary higher-order type @var{Foo},
there are two corresponding types
@samp{semipure @var{Foo}} and @samp{impure @var{Foo}}.
These types can be used for higher-order code
that needs to manipulate impure or semipure procedures.
For example the type @samp{impure func(int) = int}
represents impure functions from @code{int} to @code{int}.

There are no implicit conversions and no subtyping relationship
between ordinary higher-order types
and the corresponding impure or semipure higher-order types.
However, a value of an ordinary higher-order type
can be explicitly ``converted''
to a value of an impure (or semipure) higher-order type
by wrapping it in an impure (or semipure) lambda expression
that just calls the pure higher-order term.

@node Purity annotations on lambda expressions
@subsection Purity annotations on lambda expressions

Purity annotations are required on lambda expressions
that call semipure or impure code.
Lambda expressions can be declared as @samp{semipure} or @samp{impure}
by including such an annotation
before the @samp{pred} or @samp{func} identifier in the lambda expression.
Such lambda expressions have
the corresponding @samp{semipure} or @samp{impure} higher-order type.
For example, the expression

@example
(impure func(X) = Y :- semipure get_max(Y), impure set_max(X))
@end example

@noindent
is an example of an impure function lambda expression
with type @samp{(impure func(int) = int)},
and the expression

@example
(impure pred(X::in, Y::out) is det :-
    semipure get_max(Y),
    impure set_max(X))
@end example
is an example of an impure predicate lambda expression
with type @samp{impure pred(int, int)}.

@node Purity annotations on higher-order calls
@subsection Purity annotations on higher-order calls

Any calls to impure or semipure higher-order terms
must be explicitly annotated as such.
For impure or semipure higher-order predicates, the annotation is indicated
by putting @samp{impure} or @samp{semipure} before the call.
For example:

@example
:- func foo(impure pred(int)) = int.
:- mode foo(in(pred(out) is det)) = out is det.

foo(ImpurePred) = X1 + X2 :-
    % Using higher-order syntax.
    impure ImpurePred(X1),
    % Using the call/N syntax.
    impure call(ImpurePred, X2).
@end example

For calling impure or semipure higher-order functions,
the notation is different than what you might expect.
In addition to using an @samp{impure} or @samp{semipure} operator
on the unification which invokes the higher-order function application,
you must also use @samp{impure_apply} or @samp{semipure_apply}
rather than using @samp{apply} or higher-order syntax.
@c XXX it would be nicer to change the implementation to support
@c     nice syntax, rather than documenting this hack
For example:

@example
:- func map(impure func(T1) = T2, list(T1)) = list(T2).

map(_ImpureFunc, []) = [].
map(ImpureFunc, [X|Xs]) = [Y|Ys] :-
    impure Y = impure_apply(ImpureFunc, X),
    impure Ys = map(ImpureFunc, Ys).
@end example

@node Solver types
@chapter Solver types

@menu
* The any inst::
* Abstract solver type declarations::
* Solver type definitions::
* Implementing solver types::
* Solver types and negated contexts::
@end menu

Solver types are an experimental addition to the language
supporting the implementation of constraint solvers.
A program may place constraints on and between variables of a solver type,
limiting the values those variables may take on before they are actually bound.
For example, if @code{X} and @code{Y} are variables
belonging to a constrained integer solver type,
we might place constraints upon them such that
@w{@code{X > 3 + Y}} and @w{@code{Y =< 7}}.
A later attempt to unify @code{Y} with @code{10} will fail
(it would violate the second constraint);
similarly an attempt to unify @code{X} with @code{5} and @code{Y} with @code{4}
would fail (it would violate the first constraint).

@node The any inst
@section The @samp{any} inst

Variables with solver types can have one of three possible insts:
@code{free}, @code{ground} or @code{any}.
A variable with a solver type with inst @code{any}
may not (yet) be semantically ground, in the following sense:
if a variable is semantically ground,
then the set of values it unifies with form an equivalence class;
if a variable is non-ground,
then the set of values it unifies with do not form an equivalence class.

More formally, @code{X} is ground
if for values @code{Y} and @code{Z} that unify with @code{X},
it is the case that @code{Y} and @code{Z} also unify with each other.
@code{X} is non-ground
if there are values @code{Y} and @code{Z} that unify with @code{X},
but which do not unify with each other.

A non-solver type value will have inst @code{any}
if it is constructed using one or more inst @code{any} values.

The builtin modes @code{ia} and @code{oa}
are equivalent to @code{in(any)} and @code{out(any)} respectively.

@node Abstract solver type declarations
@section Abstract solver type declarations

The type declarations

@example
:- solver type t1.
:- solver type t2(T1, T2).
@end example

@noindent
declare types @code{t1/0} and @code{t2/2} to be abstract solver types.
Abstract solver type declarations are
identical to ordinary abstract type declarations
except for the @code{solver} keyword.

@node Solver type definitions
@section Solver type definitions

A solver type definition takes the following form:

@example
@group
:- solver type @var{solver_type}
    where   representation   is @var{representation_type},
            ground           is @var{ground_inst},
            any              is @var{any_inst},
            constraint_store is @var{mutable_decls},
            equality         is @var{equality_pred},
            comparison       is @var{comparison_pred}.
@end group
@end example

The @code{representation} attribute is mandatory.
The @var{ground_inst} and @var{any_inst} attributes are optional
and default to @code{ground}.
The @code{constraint_store} attribute is mandatory:
@var{mutable_decls} must be either a single mutable declaration
(@pxref{Module-local mutable variables}),
or a comma separated list of mutable declarations in brackets.
The @code{equality} and @code{comparison} attributes are optional,
although a solver type without equality would not be very useful.
The attributes that are not omitted must appear in the order shown above.

The @var{representation_type}
is the type used to implement the @var{solver_type}.
A two-tier scheme of this kind is necessary for a number of reasons,
including
@itemize @bullet
@item
a semantic gap is necessary to accommodate the fact that
non-ground @var{solver_type} values
may be represented by ground @var{representation_type} values
(in the context of the corresponding constraint solver state);
@item
this approach greatly simplifies
the definition of equality and comparison predicates for the @var{solver_type}.
@end itemize

@c XXX The following paragraph describes the old support for automatic
@c     initialisation of solver types.  We no longer officially support
@c     automatic initialisation as part of the language but the compiler
@c     still contains the code necessary to implement it.
@c
@c The @code{initialisation_pred} is the name of a predicate defined in the
@c same module as the solver type, with the following signature:
@c
@c @example
@c :- pred initialisation_pred(solver_type::out(any)) is det.
@c @end example
@c
@c Calls to this predicate are inserted automatically by the compiler when a
@c @code{free} @code{solver_type} variable has to be given inst @code{any}.
@c (The initialisation predicate is responsible for registering the new,
@c unbound variable with the corresponding constraint solver state.)

The @var{ground_inst} is the inst associated with
@var{representation_type} values denoting @code{ground}
@var{solver_type} values.

The @var{any_inst} is the inst associated with @var{representation_type} values
denoting @code{any} @code{solver_type} values.

The compiler constructs four impure functions
for converting between @var{solver_type} values
and @var{representation_type} values
(@var{name} is the function symbol used to name @var{solver_type}
and @var{arity} is the number of type parameters it takes):

@example
:- impure func 'representation of ground @var{name}/@var{arity}'(@var{solver_type}) =
                        @var{representation_type}.
:-        mode 'representation of ground @var{name}/@var{arity}'(in) =
                        out(@var{ground_inst}) is det.

:- impure func 'representation of any @var{name}/@var{arity}'(@var{solver_type}) =
                        @var{representation_type}.
:-        mode 'representation of any @var{name}/@var{arity}'(in(any)) =
                        out(@var{any_inst}) is det.

:- impure func 'representation to ground @var{name}/@var{arity}'(@var{representation_type}) =
                        @var{solver_type}.
:-        mode 'representation to ground @var{name}/@var{arity}'(in(@var{ground_inst})) =
                        out is det.

:- impure func 'representation to any @var{name}/@var{arity}'(@var{representation_type}) =
                        @var{solver_type}.
:-        mode 'representation to any @var{name}/@var{arity}'(in(@var{any_inst})) =
                        out(any) is det.
@end example

These functions are impure because of the semantic gap issue mentioned above.

Solver types may be exported from their defining module,
but only in an abstract form.
This requires the full definition
to appear in the implementation section of the module,
and an abstract declaration like the following in its interface:

@example
:- solver type @var{solver_type}.
@end example

If a solver type is exported,
then its representation type,
and, if specified, its equality and/or comparison predicates
must also exported from the same module.

If a solver type has no equality predicate specified,
then the compiler will generate an equality predicate
that throws an exception of type @samp{exception.software_error/0} when called.

Likewise, if a solver type has no equality comparison specified,
then the compiler will generate a comparison predicate
that throws an exception of type @samp{exception.software_error/0} when called.

If provided,
any mutable declarations given for the @code{constraint_store} attribute
are equivalent to separate mutable declarations;
their association with the solver type is for the purposes of documentation.
That is,

@example
:- solver type t
    where @dots{},
          constraint_store is [ mutable(a, int, 42, ground, []),
                                mutable(b, string, "Hi", ground, [])
                               ],
          @dots{}
@end example

@noindent
is equivalent to

@example
:- solver type t
    where @dots{}
:- mutable(a, int, 42, ground, []).
:- mutable(b, string, "Hi", ground, []).
@end example

@node Implementing solver types
@section Implementing solver types

A solver type is an abstraction,
implemented using a combination of a private representation type
and a constraint store.

The constraint store is an (impure) piece of state
used to keep track of the extant constraints on variables of the solver type.
This will typically be implemented using foreign code.

It is important that changes to the constraint store
are properly trailed (see @ref{Trailing})
so that changes can be undone on backtracking.

The solver type implementation should provide functions and predicates
@itemize @bullet
@item
to construct and deconstruct solver type values,
@item
to place constraints on solver type variables,
@item
to convert @code{any} solver type variables to @code{ground} if possible
(this is obviously an impure operation --- see @ref{Impurity}),
@item
to convert solver type values to non-solver type values
(again, this is impure
and requires the argument solver type values be sufficiently ground),
@item
to ask questions about the extant constraints on solver type variables
without constraining them further
(this too is impure because the set of constraints on a variable
may change during execution of the program).
@end itemize

@node Solver types and negated contexts
@section Solver types and negated contexts

Mercury's negation and if-then-else goals
(and hence also inequalities and universal quantifications)
are implemented using @emph{negation as failure},
meaning that the failure to find a proof of one statement
is regarded as a proof of its negation.
Negation as failure is sound
provided that no non-local variable becomes further bound
during the execution of a goal which may be negated.
This includes negated goals themselves,
as well as the conditions of if-then-elses,
which are negated iff they fail without producing any solution,
and the bodies of pred or func expressions,
which may be called or applied in one of the other contexts,
or indeed in another pred or func expression.

Mercury checks that any solver variables that are used in the above contexts
are used in such a way that negation as failure remains sound.
In the case of negation and if-then-else goals,
if any non-local solver type variable or higher-order variable
with inst @code{any} is used in a negated context,
the goal must be placed inside
a @code{promise_pure}, @code{promise_semipure}, or @code{promise_impure} scope.
The first two promises assert that (among other things)
no solver variable becomes further bound in the negated context.
The third promise makes the weaker assertion that the goal satisfies
the requirements of all impure goals
(namely, that it doesn't interfere with the semantics of other pure goals).

In the case of pred and func expressions, Mercury allows three possibilities.
The higher-order value may be considered @code{ground},
which means that all non-local variables used in the body of the expression
(including those with other higher-order values) must themselves be ground.
Higher-order values that are ground
can be safely called or applied in any context, including negated contexts,
since none of their (ground) non-local variables
can become further bound by doing so.
Alternatively, the higher-order value
may be considered to have inst @code{any},
which allows non-local variables used in the body of the expression
to have inst @code{any}.
Calling or applying these values
@emph{may} further bind non-local variables,
so if this occurs in a negated context
then, as in the case of solver variables,
a promise will be required around the negation or if-then-else.

Pred and func expressions with inst @code{any}
are written using @code{any_pred} and @code{any_func}
in place of @code{pred} and @code{func}, respectively.

The third possibility is that
the higher-order value can be given an impure type
(@pxref{Higher-order impurity}).

@node Trace goals
@chapter Trace goals

Sometimes, programmers find themselves
needing to perform some side-effects in the middle of declarative code.
One example is an operation that takes so long that
users may think the program has gone into an infinite loop:
periodically printing a progress message can give them reassurance.
Another example is a program that is
too long-running for its behaviour to be analyzed via debuggers
and too complex for analysis via profilers;
a programmable logging facility generating data
for analysis by a specially-written program may be the best option.
However, inserting arbitrary side effects into declarative code
is against the spirit of Mercury.
Trace goals exist to provide a mechanism
to code these side effects in a disciplined fashion.

The format of trace goals is @code{trace @var{Params} @var{Goal}}.
@var{Goal} must be a valid goal;
@var{Params} must be a valid list of one or more trace parameters.
The following example shows all four of the available kinds of parameters:
@samp{compile_time}, @samp{run_time}, @samp{io} and @samp{state}.
(In practice, it is far more typical to have just one parameter, @samp{io}.)

@example
:- mutable(logging_level, int, 0, ground, []).

:- pred time_consuming_task(data::in, result::out) is det.

time_consuming_task(In, Out) :-
    trace [
        compile_time(flag("do_logging") or grade(debug)),
        run_time(env("VERBOSE")),
        io(!IO),
        state(logging_level, !LoggingLevel)
    ] (
        io.write_string("Time_consuming_task start\n", !IO),
        ( !.LoggingLevel > 1 ->
            io.write_string("Input is ", !IO),
            io.write(In, !IO),
            io.nl(!IO)
        ;
            true
        )
    ),
    @dots{}
    % perform the actual task
@end example

The @samp{compile_time} parameter says under what circumstances
the trace goal should be included in the executable program.
In the example, at least one of two conditions has to be true:
either this module has to be compiled
with the option @samp{--trace-flag=do_logging},
or it has to be compiled in a debugging grade.

In general, the single argument of the @samp{compile_time} function symbol
is a boolean expression of primitive compile-time conditions.
Valid boolean operators in these expressions
are @samp{and}, @samp{or} and @samp{not}.
There are three kinds of primitive compile-time conditions.
The first has the form @samp{flag(@var{FlagName})},
where @var{FlagName} is an arbitrary name picked by the programmer;
this condition is true
if the module is compiled with the option @samp{--trace-flag=@var{FlagName}}.
The second has the form @samp{tracelevel(shallow)}, or @samp{tracelevel(deep)};
this condition is true (irrespective of grade)
if the module is compiled with at least the specified trace level.
The third has the form @samp{grade(GradeTest)}.
The supported @samp{GradeTests}s and their meanings are as follows.

@table @asis
@item @samp{debug}
True if the module is compiled with execution tracing enabled.
@item @samp{ssdebug}
True if the module is compiled with source-to-source debugging enabled.
@item @samp{prof}
True if the module is compiled with non-deep profiling enabled.
@item @samp{profdeep}
True if the module is compiled with deep profiling enabled.
@item @samp{par}
True if the module is compiled with parallel execution enabled.
@item @samp{trail}
True if the module is compiled with trailing enabled.
@c The next one is commented because the rbmm grades are not yet publicly
@c documented.
@c @item @samp{rbmm}
@c True if the module is compiled with region based memory management enabled.
@item @samp{llds}
True if the module is compiled with @samp{--highlevel-code} disabled.
@item @samp{mlds}
True if the module is compiled with @samp{--highlevel-code} enabled.
@item @samp{c}
True if the target language of the compilation is C.
@item @samp{csharp}
True if the target language of the compilation is C#.
@item @samp{java}
True if the target language of the compilation is Java.
@item @samp{erlang}
True if the target language of the compilation is Erlang.
@end table
@c (We may support the specification of other kinds of grades in the future.)

The @samp{run_time} parameter says under what circumstances the trace goal,
if included in the executable program, should actually be executed.
In this case, the environment variable @samp{VERBOSE} has be to set
when the program starts execution.
(It doesn't matter what value it is set to.)

In general, the single argument of the @samp{run_time} function symbol
is a boolean expression of primitive run-time conditions.
Valid boolean operators in these expressions
are @samp{and}, @samp{or} and @samp{not}.
There is just one primitive run-time condition.
It has the form @samp{env(@var{EnvVarName})},
this condition is true
if the environment variable @var{EnvVarName} exists
when the program starts execution.

The @samp{compile_time} and @samp{run_time} parameters
may not appear in the parameter list more than once;
programmers who want more than one condition
have to specify how (with what boolean operators)
their values should be combined.
However, it is ok for them not to appear in the parameter list at all.
If there is no @samp{compile_time} parameter,
the trace goal is always compiled into the executable;
if there is no @samp{run_time} parameter,
the trace goal is always executed (if it is compiled into the executable).

Since the trace goal may end up
either not compiled into the executable or just not executed,
it cannot bind any variables that occur in the surrounding code.
(If it were allowed to bind such variables,
then those variables would stay unbound
if either the compile time or the run time condition were false.)
This greatly restricts what trace goals can do.

The usual reason for including a trace goal
in a procedure body is to perform some I/O,
which requires access to the I/O state.
The @samp{io} parameter supplies this access.
Its argument must be the name of a state variable prefixed by @samp{!};
by convention, it is usually @samp{!IO}.
The language implementation supplies
the initial unique value of the I/O state
as the value of @samp{!.IO} at the start of the trace goal;
it requires the trace goal to give back
the final unique value of the I/O state
as the value of @samp{!.IO} current at the end of the trace goal.

Note that trace goals that wish to do I/O
must include this parameter in their parameter list
@emph{even if} the surrounding code already has access to an I/O state.
This is because otherwise,
doing any I/O inside the trace goal
would destroy the value of the current I/O state,
changing the instantiation state of the variable holding it,
and trace goals are not allowed to do that.

The @samp{io} parameter may appear in the parameter list at most once,
since it doesn't make sense to have
two copies of the I/O state available to the trace goal.

Besides doing I/O, trace goals may read and possibly write
the values of mutable variables.
Each mutable the trace goal wants access to should be listed
in its own @samp{state} parameter
(which may therefore appear in the parameter list more than once).
Each @samp{state} parameter has two arguments:
the first gives the name of the mutable,
while the second must be the name of a state variable prefixed by @samp{!},
e.g. @samp{!LoggingLevel}.
The language implementation supplies
the initial value of the mutable
as the value of (in this case) @samp{!.LoggingLevel}
at the start of the trace goal;
at the end of the trace goal,
it puts the value of @samp{!.LoggingLevel} current then
back into the mutable.

The intention here is that trace goals
should be able to access mutables that give them information
about the parameters within which they should operate.
The ability of trace goals to actually @emph{update} the values of mutables
is intended to allow the implementation of trace goals
whose actions depend on the actions executed by previous trace goals.
For example, a trace goal could test
whether the current input value is the same as the previous input value,
and if it is, then it can say so instead of printing the value out again.
Another possibility is a progress message
which is printed not for every item processed, but for every 1000th item,
reassuring users without overwhelming them with a deluge of output.

This kind of code is the @emph{only} intended use of this ability.
Any program in which the value of a mutable set by a trace goal
is inspected by code that is not itself within a trace goal
is explicitly violating the intended uses of trace goals.
Only the difficulty of implementing the required global program analysis
prevents the language design from outlawing such programs in the first place.

The compiler will not delete trace goals
from the bodies of the procedures containing them.
However, trace goals inside a procedure don't prevent
calls to that procedure from being optimized away,
if such optimization is otherwise possible.
(There is no point in debugging or logging
operations that don't actually occur.)
In their effect on program optimizations,
trace goals function as a kind of impure code,
but one with an implicit promise_pure around the clause in which they occur.
@c zs: I think saying the following is more likely to confuse than enlighten:
@c The trace goal scope itself acts
@c as a promise_pure scope for any impure code inside it.

@node Pragmas
@chapter Pragmas

The pragma declarations described below
are a standard part of the Mercury language,
as are the pragmas for controlling the foreign language interface
(@pxref{Foreign language interface}) and impurity (@pxref{Impurity}).
As an extension,
implementations may also choose to support additional pragmas
with implementation-dependent semantics
(@pxref{Implementation-dependent extensions}).

@menu
* Inlining::                    Pragmas can be used to suggest or prevent
                                procedure inlining.
* Type specialization::         Pragmas can be used to produce specialized
                                versions of polymorphic procedures.
* Obsolescence::                Library developers can declare old versions
                                of predicates or functions to be obsolete.
* No determinism warnings::     Pragmas can be used to suppress warnings
                                about too loose determinism declarations.
* No dead predicate warnings::  Pragmas can be used to suppress warnings
                                about unused predicates.
* Source file name::            The @samp{source_file} pragma and
                                @samp{#@var{line}} directives provide support
                                for preprocessors and other tools that
                                generate Mercury code.
@end menu

@node Inlining
@section Inlining

A declaration of the form

@example
:- pragma inline(@var{Name}/@var{Arity}).
@end example

@noindent
is a hint to the compiler that
all calls to the predicate(s) or function(s)
with name @var{Name} and arity @var{Arity} should be inlined.

The current Mercury implementation is smart enough
to inline simple predicates even without this hint.

A declaration of the form

@example
:- pragma no_inline(@var{Name}/@var{Arity}).
@end example

@noindent
ensures the compiler will not inline this predicate.
This may be used simply for performance concerns
(inlining can cause unwanted code bloat in some cases)
or to prevent possibly dangerous inlining when using low-level C code.

@node Type specialization
@section Type specialization

The overhead of polymorphism can in some cases be significant,
especially where polymorphic predicates make heavy use
of class method calls or the builtin unification and comparison routines.
To avoid this, the programmer can suggest to the compiler
that a specialized version of a procedure should be created
for a specific set of argument types.

@menu
* Syntax and semantics of type specialization pragmas::
* When to use type specialization::
* Implementation specific details::
@end menu

@node Syntax and semantics of type specialization pragmas
@subsection Syntax and semantics of type specialization pragmas

A declaration of the form

@example
:- pragma type_spec(@var{Name}/@var{Arity}, @var{Subst}).
:- pragma type_spec(@var{Name}(@var{Modes}), @var{Subst}).
@end example

@noindent
suggests to the compiler that
a specialized version of predicate(s) or function(s)
with name @var{Name} and arity @var{Arity}
should be created
with the type substitution given by @var{Subst} applied to the argument types.
The second form of the declaration only suggests
specialization of the specified mode of the predicate or function.

The substitution is written as a conjunction of bindings
of the form @w{@samp{@var{TypeVar} = @var{Type}}},
for example @w{@samp{K = int}} or @w{@samp{(K = int, V = list(int))}}.

The declarations

@example
:- pred map.lookup(map(K, V), K, V).
:- pragma type_spec(map.lookup/3, K = int).
@end example

@noindent
give a hint to the compiler that
a version of @samp{map.lookup/3} should be created for integer keys.

Implementations are free to ignore @samp{pragma type_spec} declarations.
Implementations are also free to perform type specialization
even in the absence of any @samp{pragma type_spec} declarations.

@node When to use type specialization
@subsection When to use type specialization

The set of types for which a predicate or function should be specialized
is best determined by profiling your application.
Overuse of type specialization will result in code bloat.

Type specialization of predicates or functions
which unify or compare polymorphic variables
is most effective when the specialized types
are builtin types such as @code{int}, @code{float} and @code{string},
or enumeration types,
since their unification and comparison procedures
are simple and can be inlined.

Predicates or functions which make use of type class method calls
may also be candidates for specialization.
Again, this is most effective
when the called type class methods are simple enough to be inlined.

@node Implementation specific details
@subsection Implementation specific details

The University of Melbourne Mercury compiler
performs user-requested type specializations
when invoked with @samp{--user-guided-type-specialization},
which is enabled at optimization level @samp{-O2} or higher.
However, for the Java back-end,
user-requested type specializations are ignored.

@node Obsolescence
@section Obsolescence

Declarations of the forms

@example
:- pragma obsolete(@var{Name}/@var{Arity}).
:- pragma obsolete(@var{Name}/@var{Arity},
    [@var{ReplName1}/@var{ReplArity1}, ..., @var{ReplNameN}/@var{ReplArityN}]).
@end example

@noindent
declare that the predicate(s) or function(s)
with name @var{Name} and arity @var{Arity} are ``obsolete'':
they instruct the compiler to issue a warning
whenever the named predicate(s) and/or function(s) are used.
The second form tells the compiler to suggest the use
of one of the listed possible replacements.

Declarations of the forms

@example
:- pragma obsolete_proc(@var{PredName}(@var{ArgMode1}, ..., @var{ArgModeN})).
:- pragma obsolete_proc(@var{PredName}(@var{ArgMode1}, ..., @var{ArgModeN}),
    [@var{ReplName1}/@var{ReplArity1}, ..., @var{ReplNameN}/@var{ReplArityN}]).
:- pragma obsolete_proc(@var{FuncName}(@var{ArgMode1}, ..., @var{ArgModeN}) = @var{RetMode}).
:- pragma obsolete_proc(@var{FuncName}(@var{ArgMode1}, ..., @var{ArgModeN}) = @var{RetMode},
    [@var{ReplName1}/@var{ReplArity1}, ..., @var{ReplNameN}/@var{ReplArityN}]).
@end example

@noindent
similarly declare that the predicate named @var{PredName} with arity @var{N},
or the function named @var{FuncName} with arity @var{N},
is obsolete when called in the specified mode.
These forms also allow the specification
of an optional list of possible replacements.

These declarations are intended for use by library developers,
to allow gradual (rather than abrupt) evolution of library interfaces.
If a library developer changes
the interface of a library predicate or procedure,
they should leave its old version in the library,
but mark it as obsolete using one of these declarations,
and document how library users should modify their code
to suit the new interface.
The users of the library will then get a warning if they use obsolete features,
and can consult the library documentation to determine how to fix their code.
Eventually, when the library developer
believes that users have had sufficient warning,
they can remove the old version entirely.

@node No determinism warnings
@section No determinism warnings

A declaration of the form

@example
:- pragma no_determinism_warning(@var{Name}/@var{Arity}).
@end example

@noindent
tells the compiler not to generate any warnings
that the determinism declarations of procedures of the predicate or function
with name @var{Name} and arity @var{Arity} are not as tight as they could be.

@samp{pragma no_determinism_warning} declarations are intended for use
in situations in which the code of a predicate has one determinism,
but the declared determinism of the procedure must be looser
due to some outside requirement.
One such situation is when a set of procedures are all possible values
of the same higher-order variable,
which requires them to have the same argument types, modes, and determinisms.
If (say) most of the procedures are @code{det}
but some are @code{erroneous} (that is, they always throws an exception),
the procedures that are declared @code{det}
but whose bodies have determinism @code{erroneous}
will get a warning saying their determinism declaration could be tighter,
unless the programmer specifies this pragma for them.

@node No dead predicate warnings
@section No dead predicate warnings

A declaration of the form

@example
:- pragma consider_used(@var{Name}/@var{Arity}).
@end example

@noindent
tells the compiler to consider the predicate or function
with name @var{Name} and arity @var{Arity} to be used,
and not generate any dead procedure/predicate/function warnings
either for the named predicate,
@emph{or} for the other predicates and functions that it calls,
either directly or indirectly.

@samp{pragma consider_used} declarations are intended for use in situations
in which the code that was intended to call such a predicate or function
is not yet written.

@node Source file name
@section Source file name

The @samp{source_file} pragma and @samp{#@var{line}} directives
provide support for preprocessors and other tools that generate Mercury code.
The tool can insert these directives into the generated Mercury code
to allow the Mercury compiler to report diagnostics
(error and warning messages) at the original source code location,
rather than at the location in the automatically generated Mercury code.

A @samp{source_file} pragma is a declaration of the form

@example
:- pragma source_file(@var{Name}).
@end example

@noindent
where @var{Name} is a string that specifies the name of the source file.

For example, if a preprocessor generated a file @file{foo.m}
based on a input file @file{foo.m.in},
and it copied lines 20, 30, and 31 from @file{foo.m.in},
the following directives would ensure that
any error or warnings for those lines copied from @file{foo.m}
were reported at their original source locations in @file{foo.m.in}.

@example
:- module foo.
:- pragma source_file("foo.m.in").
#20
% this line comes from line 20 of foo.m
#30
% this line comes from line 30 of foo.m
% this line comes from line 31 of foo.m
:- pragma source_file("foo.m").
#10
% this automatically generated line is line 10 of foo.m
@end example

Note that if a generated file contains some text
which is copied from a source file,
and some which is automatically generated,
it is a good idea
to use @samp{pragma source_file} and @samp{#@var{line}} directives
to reset the source file name and line number
to point back to the generated file for the automatically generated text,
as in the above example.

@node Implementation-dependent extensions
@chapter Implementation-dependent extensions

The University of Melbourne Mercury implementation
supports the following extensions to the Mercury language:

@menu
* Fact tables::                 Support for very large tables of facts.
@c XXX STM
@c The documentation of STM is commented out because its support is
@c not yet complete. All such lines are preceded by XXX STM.
@c * Software Transactional Memory::
@c                              Support for synchronisation of threads without
@c                              explicit locking.
* Tabled evaluation::           Support for automatically recording previously
                                calculated results and detecting or avoiding
                                certain kinds of infinite loops.
* Termination analysis::        Support for automatic proofs of termination.
@c * Tail recursion check::        Require that a predicate is tail recursive.
* Feature sets::                Support for checking that optional features of
                                the implementation are supported at compile
                                time.
* Trailing::                    Undoing side-effects on backtracking.

@end menu

@node Fact tables
@section Fact tables

Large tables of facts can be compiled using a different algorithm
that is more efficient and can produce more efficient code.

A declaration of the form

@example
:- pragma fact_table(@var{Name}/@var{Arity}, @var{FileName}).
@end example

@noindent
tells the compiler that the predicate or function
with name @var{Name} and arity @var{Arity}
is defined by a set of facts in an external file @var{FileName}.
Defining large tables of facts in this way allows the compiler
to use a more efficient algorithm for compiling them.
This algorithm uses less memory
than would normally be required to compile the facts,
so much larger tables are possible.

Each mode is indexed on all its input arguments
so the compiler can produce very efficient code using this technique.

In the current implementation, the table of facts
is compiled into a separate C file named @file{@var{FileName}.c}.
The compiler will automatically generate
the correct dependencies for this file
when the command @samp{mmake @var{main_module}.depend} is invoked.
This ensures that the C file will be compiled to @file{@var{FileName}.o}
and then linked with the other object files
when @samp{mmake @var{main_module}} is invoked.

The main limitation of the @samp{fact_table} pragma
is that in the current implementation,
predicates or functions defined as fact tables
can only have arguments of types @code{string}, @code{int} or @code{float}.

Another limitation is that the @samp{--high-level-code} back-end
does not support @samp{pragma fact_table}
for procedures with determinism @code{nondet} or @code{multi}.

@c XXX STM
@c @node Software Transactional Memory
@c @section Software Transactional Memory
@c
@c (Note: Software Transactional Memory is still in development and many
@c aspects c documented here might change without notice.
@c Please use with caution.)
@c
@c Software Transactional Memory or STM
@c is an method of synchronising access to shared data
@c between concurrently running threads.
@c It is an alternative to the use of explicit locking.
@c
@c The way to synchronise threads using Software Transactional Memory
@c is through the use of the @samp{atomic} scope.
@c The syntax of an atomic scope is @code{atomic @var{Params} @var{Goal}}.
@c @var{Goal} must be a valid goal;
@c @var{Params} must be a list of atomic parameters
@c which must include the @samp{outer} and @samp{inner} parameters.
@c The following example shows the use of the atomic scope:
@c
@c @example
@c :- pred add_2_atomically(stm_var(int)::in, io::di, io::uo) is cc_multi.
@c
@c add_2_atomically(TVar, IO0, IO) :-
@c         atomic [ outer(IO0, IO1), inner(STM0, STM) ] (
@c                 read_stm_var(TVar, X, STM0, STM1),
@c                 Y = X + 2,
@c                 write_stm_var(TVar, Y, STM1, STM)
@c         ),
@c         io.write_string("Value of Y is ", IO1, IO2),
@c         io.write(Y, IO2, IO3),
@c         io.nl(IO3, IO).
@c @end example
@c
@c
@c The @samp{outer} parameter takes a pair of variables of type @samp{io.io}.
@c As the atomic scope can be seen as an operation which changes the I/O state,
@c the modes of these variables must be @code{di} and @code{uo} respectively.
@c
@c The @samp{inner} parameter takes a pair of variables of type @samp{stm}.
@c When the atomic scope is executed,
@c these variables supply and consume the @samp{stm} state
@c which can be used by the Software Transactional Memory primitives.
@c Calling these primitives requires threading the @samp{stm} state
@c in a way similar to I/O operations and,
@c as such, the modes of these variables must also be @code{di} and @code{uo}.
@c
@c The code within the atomic scope is restricted
@c in the same way as code which takes the I/O state.
@c The code within the atomic scope
@c must be either @code{det} or @code{cc_multi}.
@c Due to the way Software Transactional Memory provides synchronous behaviour,
@c it is likely that the goal will be executed more than once.
@c As it is unknown how many times (if any) the inner goal will be repeated,
@c only pure code or code which makes use of the @samp{stm} state
@c should be placed inside an atomic scope.
@c (Trace goals are permitted but should not be used for any action
@c that depends on the number of times the goal is executed).
@c
@c Using the atomic scope requires the program to explicitly import the modules
@c @samp{stm_builtin}, @samp{exception} and @samp{univ}.
@c This restriction will soon be dropped,
@c as the compiler itself will do the required imports.
@c
@c In STM systems, data shared between threads
@c is stored in @samp{Transaction Variables}.
@c This is the only form of shared data
@c which the atomic scope will synchronise.
@c @samp{Transaction Variables} can be operated on
@c using the following predicates:
@c
@c @example
@c :- pred new_stm_var(T::in, stm_var(T)::out, io::di, io::uo) is det.
@c
@c :- pred read_stm_var(stm_var(T)::in, T::out, stm::di, stm::uo) is det.
@c
@c :- pred write_stm_var(stm_var(T)::in, T::in, stm::di, stm::uo) is det.
@c @end example
@c
@c The @samp{new_stm_var} creates a new transaction variable
@c whose the type and initial value are given by the first argument,
@c and returns a reference to it.
@c Only one copy of the transaction variable exists in memory,
@c but references to it can be duplicated.
@c Unifications and tests of references
@c affect only the references themselves,
@c and do not affect the underlying transaction variables.
@c
@c To get or set the value of the actual transaction variable,
@c programs must call
@c the builtins @samp{read_stm_var} and @samp{write_stm_var}.
@c These calls take a reference to a transaction variable
@c and either set or return the value of the transaction variable.
@c @footnote{In actual fact, write_stm_var does not update the variable.
@c The update is instead written to a log,
@c and the real transaction variable is changed
@c only when the atomic goal has completed
@c and the whole log has been validated.}
@c As the calls to @samp{read_stm_var} and @samp{write_stm_var}
@c take a pair of @samp{stm} states,
@c they can only appear within an atomic scope.

@node Tabled evaluation
@section Tabled evaluation

(Note: ``Tabled evaluation'' has no relation
to the ``fact tables'' described above.)

Ordinarily, the results of each procedure call are not recorded;
if the same procedure is called with the same arguments,
then the answer(s) must be recomputed again.
For some procedures, this recomputation can be very wasteful.

With tabled evaluation, the implementation keeps a table
containing the previously computed results of the specified procedure;
this table is sometimes called the memo table
(since it ``remembers'' previous answers).
At each procedure call, the implementation will search the memo table
to check whether the answer(s) have already been computed,
and if so, the answers will be returned directly from the memo table
rather than being recomputed.
This can result in much faster execution,
at the cost of additional space to record answers in the table.

The implementation can also check at runtime for the situation
where a procedure calls itself recursively with the same arguments,
which would normally result in a infinite loop;
if this situation is encountered, it can (at the programmer's option)
either throw an exception,
or avoid the infinite loop
by computing solutions using a ``minimal model'' semantics.
(Specifically, the minimal model computed by our implementation
is the perfect model.)

The current Mercury implementation supports
three different pragmas for tabling, to cover these three cases:
@samp{loop_check}, @samp{memo}, and @samp{minimal_model}.

@itemize @bullet
@item
The @samp{loop_check} pragma asks only for loop checking.
With this pragma, the memo table will map each distinct set of input arguments
only to a single boolean saying whether
a call with those arguments is currently active or not;
the pragma's only effect is to cause the predicate to throw an exception
if this boolean says that the current call has the same arguments
as one of its ancestors, which indicates an infinite recursive loop.

Note that loop checking for nondet and multi predicates assumes that
calls to these predicates generate all their solutions and then fail.
If a caller asks them only for some solutions
and then cuts away all later solutions
(e.g. via a quantification
that only asks whether a solution satisfying a particular test exists),
then the cut-away call never gets a chance
to record the fact that it is not longer active.
The next call to that predicate with the same arguments
will therefore think that the previous call is still active,
and will consider this call to be an infinite loop.
@item
The @samp{memo} pragma asks for both loop checking and memoization.
With this pragma, the memo table will map each distinct set of input arguments
either to the set of results computed previously for those arguments,
or to an indication that the call is still active
and thus those results are still being computed.
This predicate will thus look for infinite recursive loops
(and throw an exception if and when it finds one)
but it will also record all its solutions in the memo table,
and will avoid recomputing solutions
that are already available in the memo table.
@item
The @samp{minimal_model} pragma asks
for the computation of a ``minimal model'' semantics.
These differ from the @samp{memo} pragma in that
the detection of what appears to be an infinite recursive loop is not fatal.
The implementation will consider
the apparently infinitely recursive calls to fail
if the call concerned has no way of computing
any solutions it has not already computed and recorded,
and if it does have such a way,
then it switches the execution to explore those ways
before coming back to the apparently infinitely recursive call.

Minimal model evaluation is applicable
only to procedures that can succeed more than once,
and only in grades that explicitly support it.
@end itemize

The syntax for each of these declarations is

@example
:- pragma memo(@var{Name}/@var{Arity}).
:- pragma memo(@var{Name}/@var{Arity}, [@var{list of tabling attributes}]).
:- pragma loop_check(@var{Name}/@var{Arity}).
:- pragma loop_check(@var{Name}/@var{Arity}, [@var{list of tabling attributes}]).
:- pragma minimal_model(@var{Name}/@var{Arity}).
:- pragma minimal_model(@var{Name}/@var{Arity}, [@var{list of tabling attributes}]).
@end example

@noindent
where @var{Name}/@var{Arity} specifies
the predicate or function to which the declaration applies.
The declaration applies to all modes of the predicate and/or function named.
At most one of these declarations may be specified
for any given predicate or function.

Programmers can also request the application of tabling
only to one particular mode of a predicate or function,
via declarations such as these:

@example
:- pragma memo(@var{Name}(in, in, out)).
:- pragma memo(@var{Name}(in, in, out), [@var{list of tabling attributes}]).
:- pragma loop_check(@var{Name}(in, out)).
:- pragma loop_check(@var{Name}(in, out), [@var{list of tabling attributes}]).
:- pragma minimal_model(@var{Name}(in, in, out, out)).
:- pragma minimal_model(@var{Name}(in, in, out, out), [@var{list of tabling attributes}]).
@end example

Because all variants of tabling record the values of input arguments,
and all except @samp{loop_check} also record the values of output arguments,
you cannot apply any of these pragmas to procedures
whose arguments' modes include any unique component.

Tabled evaluation of a predicate or function
that has an argument whose type is a foreign type
will result in a run-time error
unless the foreign type is one for which
the @samp{can_pass_as_mercury_type} and @samp{stable} assertions
have been made (@pxref{Using foreign types from Mercury}).

The optional list of attributes allows programmers
to control some aspects of the management of the memo table(s)
of the procedure(s) affected by the pragma.

The @samp{allow_reset} attribute asks the compiler
to define a predicate that, when called, resets the memo table.
The name of this predicate will be ``table_reset_for'',
followed by the name of the tabled predicate, followed by its arity,
and (if the predicate has more than one mode) by the mode number
(the first declared mode is mode 0, the second is mode 1, and so on).
These three or four components are separated by underscores.
The reset predicate takes a di/uo pair of I/O states as arguments.
The presence of these I/O state arguments in the reset predicate,
and the fact that tabled predicates cannot have unique arguments
together imply that a memo table cannot be reset
while a call using that memo table is active.

The @samp{statistics} attribute asks the compiler
to define a predicate that, when called,
returns statistics about the memo table.
The name of this predicate will be ``table_statistics_for'',
followed by the name of the tabled predicate, followed by its arity,
and (if the predicate has more than one mode) by the mode number
(the first declared mode is mode 0, the second is mode 1, and so on).
These three or four components are separated by underscores.
The statistics predicate takes three arguments.
The second and third are a di/uo pair of I/O states,
while the first is an output argument that contains information
about accesses to and modifications of the procedure's memo table,
both since the creation of the table,
and since the last call to this predicate.
The type of this argument is defined in the file table_builtin.m
in the Mercury standard library.
That module also contains a predicate for printing out this information
in a programmer-friendly format.

The remaining two attributes, @samp{fast_loose} and @samp{specified},
control how arguments are looked up in the memo table.
The default implementation
looks up the @emph{value} of each input argument,
and thus requires time proportional to
the number of function symbols in the input arguments.
This is the only implementation allowed for minimal model tabling,
but for predicates tabled with the @samp{loop_check} and @samp{memo} pragmas,
programmers can also choose some other tabling methods.

The @samp{fast_loose} attribute asks the compiler to generate code
that looks up only the @emph{address} of each input argument in the memo table,
which means that the time required
is linear only in the @emph{number} of input arguments, not their @emph{size}.
The tradeoff is that @samp{fast_loose}
does not recognize calls as duplicates
if they involve input arguments that are logically equal
but are stored at different locations in memory.
The following declaration calls for this variant of tabling.

@example
:- pragma memo(@var{Name}(in, in, in, out),
        [allow_reset, statistics, fast_loose]).
@end example

The @samp{specified} attribute allows programmers
to choose individually, for each input argument,
whether that argument should be looked up in the memo table
by value or by address,
or whether it should be looked up at all:

@example
:- pragma memo(@var{Name}(in, in, in, out), [allow_reset, statistics,
        specified([value, addr, promise_implied, output])]).
@end example

The @samp{specified} attribute should have an argument which is a list,
and this list should contain one element
for each argument of the predicate or function concerned
(if a function, the last element is for the return value).
For output arguments, the list element should be @samp{output}.
For input arguments, the list element may be
@samp{value}, @samp{addr} or @samp{promise_implied}.
The first calls for tabling the argument by value,
the second calls for tabling the argument by address,
and the third calls for not tabling the argument at all.
This last course of action promises that any two calls
that agree on the values of the value-tabled input arguments
and on the addresses of the address-tabled input arguments
will behave the same regardless of the values of the untabled input arguments.
In most cases, this will mean that the values of the untabled arguments
are implied by the values of the value-tabled arguments
and the addresses of the address-tabled arguments,
though the promise can also be fulfilled
if the table predicate or function does not actually use
the untabled argument for computing any of its output.
(It is ok for it to use the untabled argument
to decide what exception to throw.)

@c Experimental:
@c The @samp{specified} attribute can additionally take an argument after
@c the list, which is either @samp{hidden_arg_value} or @samp{hidden_arg_addr}.
@c If @samp{hidden_arg_addr} is specified, extra arguments introduced by the
@c compiler will be tabled by address, otherwise they are tabled by value.
@c @samp{hidden_arg_value} is assumed if neither is present.

If the tabled predicate or function has only one mode,
then this declaration can also be specified without giving the argument modes:

@example
:- pragma memo(@var{Name}/@var{Arity}, [allow_reset, statistics,
        specified([value, addr, promise_implied, output])]).
@end example

Note that a @samp{pragma minimal_model} declaration
changes the declarative semantics of the specified predicate or function:
instead of using the completion of the clauses as the basis for the semantics,
as is normally the case in Mercury,
the declarative semantics that is used is a ``minimal model'' semantics,
specifically, the perfect model semantics.
Anything which is true or false in the completion semantics
is also true or false (respectively) in the perfect model semantics,
but there are goals for which the perfect model specifies
that the result is true or false,
whereas the completion semantics leaves the result unspecified.
For these goals, the usual Mercury semantics requires the
implementation to either loop or report an error message,
but the perfect model semantics requires a particular answer to be returned.
In particular, the perfect model semantics says that
any call that is not true in @emph{all} models is false.

Programmers should therefore use a @samp{pragma minimal_model} declaration
only in cases where their intended interpretation for a procedure
coincides with the perfect model for that procedure.
Fortunately, however, this is usually what programmers intend.

@c XXX give an example

For more information on tabling, see K. Sagonas's PhD thesis
@c XXX this citation doesn't come out properly in DVI format
@cite{The SLG-WAM: A Search-Efficient Engine for Well-Founded Evaluation
of Normal Logic Programs.} @xref{[4]}.
The operational semantics
of procedures with a @samp{pragma minimal_model} declaration
corresponds to what Sagonas calls ``SLGd resolution''.

In the general case,
the execution mechanism required by minimal model tabling is quite complicated,
requiring the ability to delay goals and then wake them up again.
The Mercury implementation uses a technique
based on copying relevant parts of the stack to the heap when delaying goals.
It is described in
@c XXX this citation may not come out properly in DVI format
@cite{Tabling in Mercury: design and implementation}
by Z. Somogyi and K. Sagonas,
Proceedings of the Eight International Symposium
on Practical Aspects of Declarative Languages.

@cartouche
@strong{Please note:}
the current implementation of tabling does not support
all the possible compilation grades
(see the ``Compilation model options'' section of the Mercury User's Guide)
allowed by the Mercury implementation.
In particular, minimal model tabling is incompatible with
high level code and the use of trailing.
@c and accurate garbage collection.
@end cartouche

@node Termination analysis
@section Termination analysis

The compiler includes a termination analyser
which can be used to prove termination of predicates and functions.
Details of the analysis is available
in ``Termination Analysis for Mercury''
by Chris Speirs, Zoltan Somogyi and Harald Sondergaard.
@xref{[1]}.
@c XXX this citation doesn't come out properly in DVI format

The analysis is based on
an algorithm proposed by Gerhard Groger and Lutz Plumer
in their paper ``Handling of mutual recursion in
automatic termination proofs for logic programs.'' @xref{[2]}.
@c XXX this citation doesn't come out properly in DVI format

For an introduction to termination analysis for logic programs,
please refer to ``Termination Analysis for Logic Programs'' by Chris Speirs.
@c XXX this citation doesn't come out properly in DVI format
@xref{[3]}.

Information about the termination properties of a predicate or function
can be given to the compiler.
Pragmas are also available to require the compiler
to prove termination of a given predicate or function,
or to give an error message if it cannot do so.

The analyser is enabled by the option @samp{--enable-termination},
which can be abbreviated to @samp{--enable-term}.
When termination analysis is enabled,
any predicates or functions
with a @samp{check_termination} pragma defined on them
will have their termination checked,
and if termination cannot be proved,
the compiler will emit an error message
detailing the reason that termination could not be proved.

The option @samp{--check-termination},
which may be abbreviated to @samp{--check-term} or @samp{--chk-term},
forces the compiler to check the termination of all predicates in the module.
It is common for the compiler to be unable to prove
termination of some predicates and functions
because they call other predicates
which could not be proved to terminate
or because they use language features (such as higher-order calls)
which cannot be usefully analysed.
In this case, the compiler only emits a warning
for these predicates and functions
if the @samp{--verbose-check-termination} option is enabled.
For every predicate or function
that the compiler cannot prove the termination of,
a warning message is emitted, but compilation continues.
The @samp{--check-termination} option
implies the @samp{--enable-termination} option.

The accuracy of the termination analysis is substantially degraded
if intermodule optimization is not enabled.
Unless intermodule optimization is enabled,
the compiler must assume that any imported predicate may not terminate.

By default, the compiler assumes that
a procedure defined using the foreign language interface
will terminate for all input if it does not call Mercury.
If it does call Mercury then by default the compiler will assume
that it may not terminate.

The foreign code attributes @samp{terminates}/@samp{does_not_terminate}
may be used to force the compiler to treat a foreign_proc
as terminating/non-terminating irrespective of whether it calls Mercury.
As a matter of style,
it is preferable to use foreign code attributes for foreign_procs
rather than the termination pragmas described below.

The following declarations can be used to inform the compiler
of the termination properties of a predicate or function.

@example
:- pragma terminates(@var{Name}/@var{Arity}).
@end example

This declaration may be used to inform the compiler
that this predicate or function is guaranteed to terminate for any input.
This is useful when the compiler cannot prove
termination of some predicates or functions
which are in turn preventing the compiler
from proving termination of other predicates or functions.
This declaration affects not only the predicate specified
but also any other predicates that are mutually recursive with it.

@example
:- pragma does_not_terminate(@var{Name}/@var{Arity}).
@end example

This declaration may be used to inform the compiler
that this predicate may not terminate.
This declaration affects not only the predicate specified
but also any other predicates that are mutually recursive with it.

@example
:- pragma check_termination(@var{Name}/@var{Arity}).
@end example

This pragma forces the compiler to prove termination of this predicate.
If it cannot prove the termination of the specified predicate or function,
then the compiler will quit with an error message.

@c XXX The `reserved tag' pragma is not documented because it is intended to
@c     be used with `any' insts, which are themselves not yet documented.
@c     Also, it is a quite low-level facility, and very
@c     implementation-specific...
@c
@c @node Reserved tag
@c @section Reserved tag
@c
@c The University of Melbourne Mercury implementation includes some fairly
@c low-level support for implementing Herbrand constraint solvers
@c (i.e. Prolog-style logic variables).
@c
@c In particular, you can use the @samp{reserve_tag} pragma
@c to tell the compiler to reserve a tag in the data representation
@c for a type.  The intent is for this tag to be used to represent
@c unbound variables with inst @samp{any}.
@c
@c The @samp{reserve_tag} pragma declaration has the following form:
@c @example
@c :- pragma reserve_tag(@var{type-name} / @var{type-arity}).
@c @end example
@c
@c The @var{type-name} and @var{type-arity} must specify the name
@c and arity of a discriminated union type defined in the same module,
@c and the @samp{reserve_tag} pragma must occur in the same section
@c (interface or implementation) of the module as the type definition.
@c
@c The effect of this declaration is that values whose primary
@c tag is zero are reserved for use in representing unbound variables.
@c Note that to actually create an unbound variable, you need to
@c use the foreign language interface code, and the code will probably
@c need to be aware of the Mercury compiler's data representation.
@c
@c The @samp{reserve_tag} pragma has the same effect to the
@c @samp{--reserve-tag} compiler option (which is documented
@c in the Mercury user's guide),
@c except that the pragma applies just to the specified type,
@c whereas the compiler option applies to discriminated union types
@c in the program.
@c
@c Note that neither the @samp{reserve_tag} pragma nor the @samp{--reserve-tag}
@c compiler option will have any useful effect if the @samp{--high-level-data}
@c option is used (e.g. for the .NET or Java back-ends).

@c XXX TO DO!
@c @node Compile-time garbage collection
@c @section Compile-time garbage collection
@c
@c The compiler includes a compile-time garbage collection system (CTGC). This
@c system consists of a structure sharing analysis, followed by a structure
@c reuse analysis.
@c
@c @node Structure sharing analysis
@c @subsection Structure sharing analysis
@c
@c The compiler includes a structure sharing analysis system.
@c
@c @node Structure reuse analysis
@c @subsection Structure reuse analysis
@c
@c The compiler includes a structure reuse analysis system.
@c

@c @node Tail recursion check
@c @section Tail recursion check
@c
@c The @samp{require_tail_recursion} pragma can be used to enable and disable
@c warnings or errors for predicates and functions that contain recursive
@c calls which are not @emph{tail} recursive.
@c
@c @example
@c :- pragma require_tail_recursion(@var{Name}/@var{Arity}, @var{Options}).
@c :- pragma require_tail_recursion(@var{Name}(@var{Modes}), @var{Options}).
@c :- pragma require_tail_recursion(@var{Name}(@var{Modes}) = @var{ReturnMode},
@c     @var{Options}).
@c @end example
@c
@c This pragma affects all modes of a predicate or function (in the first form)
@c or a specific mode of a predicate or function (the second and third forms).
@c These pragmas can be used to enable or inhibit warnings for non tail
@c recursive code.
@c
@c When tail recursion warnings are enabled using the
@c @samp{--warn-non-tail-recursion} compiler option (see the user's guide),
@c the compiler may emit warnings for predicates that the developer knows and
@c accepts aren't tail recursive.
@c These can be suppressed using the @samp{none} option in the
@c @samp{require_tail_recursion} pragma.
@c
@c @example
@c :- pragma require_tail_recursion(foo/3, [none]).
@c @end example
@c
@c When the @samp{--warn-non-tail-recursion} compiler option is not enabled
@c then the pragma can be used to explicitly enable the tail recursion check
@c for a predicate or function.
@c If you think that a predicate or function will probably recurse deeply,
@c and may exhaust the stack unless its recursive calls are all tail recursive,
@c then use this pragma on that predicate
@c to get a warning or an error
@c if any of those recursive calls are not tail recursive.
@c You may also wish to enable this warning
@c if you expect the predicate or function to be called many times,
@c even if those calls are very unlikely to exhaust the stack,
@c simply because tail recursion is more efficient than non-tail recursion.
@c
@c @example
@c :- pragma require_tail_recursion(map/3).
@c @end example
@c
@c The following options may be given:
@c
@c @table @code
@c
@c @item warn
@c Non tail recursive code should generate a compiler warning.
@c This is the default.
@c This option is incompatible with @samp{error} and @samp{none}.
@c
@c @item error
@c Non tail recursive code should generate a compiler error.
@c This option is incompatible with @samp{warn} and @samp{none}.
@c
@c @item none
@c Disable the tail recursion check for this predicate or function.
@c This option is incompatible with every other option.
@c
@c @item self_or_mutual_recursion
@c Allow the recursive calls to be self or mutually recursive.
@c The compiler will generate warnings or errors for recursive calls that are
@c not tail calls (and not later followed by a recursive call that @emph{is} a
@c tail call).
@c This is the default.
@c This option is incompatible with @samp{self_recursion_only} and @samp{none}.
@c
@c @item self_recursion_only
@c Require that all recursive calls are self-recursive.
@c In addition to @code{self_or_mutual_recursion},
@c this option causes the compiler to generate a warning or error
@c when a mutually recursive call is a @emph{tail} call, even if it can
@c optimize the tail call.
@c Some backends can optimize self recursion but not mutual recursion,
@c or mutual recursion is less efficient.
@c This option can be used to alert the programmer of code that isn't tail
@c recursive on these backends.
@c This option is incompatible with @samp{self_or_mutual_recursion} and
@c @samp{none}.
@c
@c @end table
@c
@c Note that the compiler cannot analyse recursion across module boundaries
@c or through higher order calls.
@c Therefore inter-module and higher order calls are considered to be
@c non-recursive.
@c
@c This pragma has no effect with @samp{--no-optimize-tailcalls}.
@c It also has no effect when generating Erlang code,
@c because the Erlang implementation itself implements last call optimisation.
@c
@c Issuing the pragma more than once for the same predicate or function, or a
@c mode off that predicate or function, will cause undefined behaviour.

@node Feature sets
@section Feature sets

The University of Melbourne Mercury implementation
supports a number of optional compilation model features,
such as @ref{Trailing} or @ref{Tabled evaluation}.
Feature sets allow the programmer to assert that a module requires
the presence of one or more optional features in the compilation model.
These assertions can be made
using a @samp{pragma require_feature_set} declaration.

The @samp{require_feature_set} pragma declaration has the following form:
@example
:- pragma require_feature_set(@var{Features}).
@end example

where @var{Features} is a (possibly empty) list of features.

The supported features are:
@table @asis

@item @samp{concurrency}
This specifies that the compilation model
must support concurrent execution of multiple threads.

@item @samp{single_prec_float}
This specifies that the compilation model
must use single precision floats.
This feature cannot be specified
together with the @samp{double_prec_float} feature.

@item @samp{double_prec_float},
This feature specifies tha
the compilation model must use double precision floats.
This feature cannot be specified
together with the @samp{single_prec_float} feature.

@item @samp{memo}
This feature specifies that the compilation model must support memoisation
(see @ref{Tabled evaluation}).

@item @samp{parallel_conj}
This feature specifies that the compilation model
must support parallel execution of conjunctions.
This feature cannot be specified together with the @samp{trailing} feature.

@item @samp{trailing}
This feature specifies that the compilation model
must support trailing, see @ref{Trailing}.
This feature cannot be specified
together with the @samp{parallel_conj} feature.

@item @samp{strict_sequential}
This feature specifies that
a semantics that is equivalent to the strict sequential operational semantics
must be used.

@item @samp{conservative_gc}
This feature specifies that a module
requires conservative garbage collection.
This feature is only checked when using the C backends;
it is ignored by the non-C backends.

@end table

When a module containing a @samp{pragma require_feature_set} declaration
is compiled,
the implementation checks to see that
the specified features are supported by the compilation model.
It emits an error if they are not.

A @samp{pragma require_feature_set} may only occur
in the implementation section of a module.

A @samp{pragma require_feature_set} affects
only the module in which it occurs;
in particular it does not affect any sub-modules.

If a module contains multiple @samp{pragma require_feature_set} declarations,
then the implementation should emit an error
if any of them specifies a feature
that is not supported by the compilation model.

@node Trailing
@section Trailing

In certain compilation grades
(see the ``Compilation model options'' section of the Mercury User's Guide),
the University of Melbourne Mercury implementation supports trailing.
Trailing is a means of having side-effects,
such as destructive updates to data structures, undone on backtracking.
The basic idea is that during forward execution,
whenever you perform a destructive modification
to a data structure that may still be live on backtracking,
you should record whatever information is necessary to restore it
on a stack-like data structure called the ``trail''.
Then, if a computation fails,
and execution backtracks to before those updates were performed,
the Mercury runtime engine will traverse the trail
back to the most recent choice point,
undoing all those updates.

The interface used is a set of C functions
(which are actually implemented as macros) and types.
Typically these will be called from C code
within @samp{pragma foreign_proc} or @samp{pragma foreign_code} declarations
in Mercury code.

For an example of the use of this interface,
see the module @file{extras/trailed_update/tr_array.m}
in the Mercury extras distribution.

@menu
* Choice points::
* Value trailing::
* Function trailing::
* Delayed goals and floundering::
* Avoiding redundant trailing::
@end menu

@node Choice points
@subsection Choice points

A ``choice point'' is a point in the computation
to which execution might backtrack when a goal fails or throws an exception.
The ``current'' choice point is the one that was most recently encountered;
that is also the one to which execution will branch
if the current computation fails.

When you trail an update,
the Mercury engine will ensure that
if execution ever backtracks to the choice point
that was current at the time of trailing,
then the update will be undone.

If the Mercury compiler determines that
it will never need to backtrack to a particular choice point,
then it will ``prune'' away that choice point.
If a choice point is pruned,
the trail entries for those updates will not necessarily be discarded,
because in general they may still be necessary
in case we backtrack to a prior choice point.

@node Value trailing
@subsection Value trailing

The simplest form of trailing is value trailing.
This allows you to trail updates to memory
and have the Mercury runtime engine automatically undo them on backtracking.

@table @b
@item @bullet{} @code{MR_trail_value()}
Prototype:
@example
void MR_trail_value(MR_Word *@var{address}, MR_Word @var{value});
@end example

Ensures that if future execution backtracks to the
current choice point, then @var{value} will be placed in @var{address}.
@sp 1
@item @bullet{} @code{MR_trail_current_value()}
Prototype:
@example
void MR_trail_current_value(MR_Word *@var{address});
@end example

Ensures that if future execution backtracks to the
current choice point, the value currently in @var{address}
will be restored.

@samp{MR_trail_current_value(@var{address})} is equivalent to
@samp{MR_trail_value(@var{address}, *@var{address})}.

@end table

Note that @var{address} must be word aligned
for both @code{MR_trail_current_value()} and @code{MR_trail_value()}.
(The address of Mercury data structures
that have been passed to C via the foreign language interface
are guaranteed to be appropriately aligned.)

@node Function trailing
@subsection Function trailing

For more complicated uses of trailing,
you can store the address of a C function on the trail
and have the Mercury runtime call your function back
whenever future execution backtracks to the current choice point or earlier,
or whenever that choice point is pruned,
because execution commits to never backtracking over that point,
or whenever that choice point is garbage collected.

Note the garbage collector in the current Mercury implementation
does not garbage-collect the trail;
this case is mentioned
only so that we can cater for possible future extensions.

@table @b
@item @bullet{} @code{MR_trail_function()}
Prototype:
@example
typedef enum @{
        MR_undo,
        MR_exception,
        MR_retry,
        MR_commit,
        MR_solve,
        MR_gc
@} MR_untrail_reason;

void MR_trail_function(
        void (*@var{untrail_func})(void *, MR_untrail_reason),
        void *@var{value}
);
@end example
@noindent
A call to @samp{MR_trail_function(@var{untrail_func}, @var{value})}
adds an entry to the function trail.
The Mercury implementation ensures that
if future execution ever backtracks to the current choicepoint,
or backtracks past the current choicepoint to some earlier choicepoint,
then @code{(*@var{untrail_func})(@var{value}, @var{reason})} will be called,
where @var{reason} will be @samp{MR_undo}
if the backtracking was due to a goal failing,
@samp{MR_exception} if the backtracking was due
to a goal throwing an exception,
or @samp{MR_retry} if the backtracking was due
to the use of the ``retry'' command in @samp{mdb}, the Mercury debugger,
or any similar user request in a debugger.
The Mercury implementation also ensures that
if the current choice point is pruned
because execution commits to never backtracking to it,
then @code{(*@var{untrail_func})(@var{value}, MR_commit)} will be called.
It also ensures that
if execution requires that the current goal be solvable,
then @code{(*@var{untrail_func})(@var{value}, MR_solve)} will be called.
This happens in calls to @code{solutions/2}, for example.
(@code{MR_commit} is used for ``hard'' commits,
i.e.@: when we commit to a solution and prune away the alternative solutions;
@code{MR_solve} is used for ``soft'' commits,
i.e.@: when we must commit to a solution
but do not prune away all the alternatives.)

MR_gc is currently not used ---
it is reserved for future use.

@end table

Typically if the @var{untrail_func} is called
with @var{reason} being @samp{MR_undo}, @samp{MR_exception},
or @samp{MR_retry},
then it should undo the effects of the update(s) specified by @var{value},
and then free any resources associated with that trail entry.
If it is called with @var{reason} being @samp{MR_commit} or @samp{MR_solve},
then it should not undo the update(s);
instead, it may check for floundering (see the next section).
In the @samp{MR_commit} case it may, in some cases, be possible
to also free resources associated with the trail entry.
If it is called with anything else (such as @samp{MR_gc}),
then it should probably abort execution with an error message.

Note that the address of the C function passed as the first argument of
@code{MR_trail_function()} must be word aligned.

@node Delayed goals and floundering
@subsection Delayed goals and floundering

Another use for the function trail is check for floundering
in the presence of delayed goals.

Often, when implementing certain kinds of constraint solvers,
it may not be possible
to actually solve all of the constraints at the time they are added.
Instead, it may be necessary
to simply delay their execution until a later time,
in the hope the constraints may become solvable
when more information is available.
If you do implement a constraint solver with these properties,
then at certain points in the computation
--- for example, after executing a negated goal ---
it is important for the system to check
that there are no outstanding delayed goals which might cause failure,
before execution commits to this execution path.
If there are any such delayed goals, the computation is said to ``flounder''.
If the check for floundering was omitted,
then it could lead to unsound behaviour,
such as a negation failing
even though logically speaking it ought to have succeeded.

The check for floundering can be implemented using the function trail,
by simply calling @samp{MR_trail_function()} to add a function trail entry
whenever you create a delayed goal,
and putting the appropriate check for floundering
in the @samp{MR_commit} and @samp{MR_solve} cases of your function.
The Mercury extras distribution includes an example of this:
see the @samp{ML_var_untrail_func()} function
in the file @file{extras/trailed_update/var.m}.)
If your function does detect floundering,
then it should print an error message and then abort execution.

@node Avoiding redundant trailing
@subsection Avoiding redundant trailing

If a mutable data structure is updated multiple times,
and each update is recorded on the trail using the functions described above,
then some of this trailing may be redundant.
It is generally not necessary to record enough information
to recover the original state of the data structure
for @emph{every} update on the trail;
instead, it is enough to record
the original state of each updated data structure just once
for each choice point occurring after the data structure is allocated,
rather than once for each update.

The functions described below provide a means to avoid redundant trailing.

@table @b
@item @bullet{} @code{MR_ChoicepointId}
Declaration:
@example
typedef @dots{} MR_ChoicepointId;
@end example

The type @code{MR_ChoicepointId} is an abstract type
used to hold the identity of a choice point.
Values of this type can be compared
using C's @samp{==} operator or using @samp{MR_choicepoint_newer()}.
@sp 1
@item @bullet{} @code{MR_current_choicepoint_id()}
Prototype:
@example
MR_ChoicepointId MR_current_choicepoint_id(void);
@end example

@code{MR_current_choicepoint_id()} returns a value
indicating the identity of the most recent choice point;
that is, the point to which execution would backtrack
if the current computation failed.
The value remains meaningful if the choicepoint is pruned away by a commit,
but is not meaningful
after backtracking past the point where the choicepoint was created
(since choicepoint ids may be reused after backtracking).
@sp 1
@item @bullet{} @code{MR_null_choicepoint_id()}
Prototype:
@example
MR_ChoicepointId MR_null_choicepoint_id(void);
@end example

@code{MR_null_choicepoint_id()} returns a ``null'' value that is distinct
from any value ever returned by @code{MR_current_choicepoint_id}.
(Note that @code{MR_null_choicepoint_id()}
is a macro that is guaranteed to be suitable for use as a static initializer,
so that it can for example be used
to provide the initial value of a C global variable.)
@sp 1
@item @bullet{} @code{MR_choicepoint_newer()}
Prototype:
@example
bool MR_choicepoint_newer(MR_ChoicepointId, MR_ChoicepointId);
@end example

@code{MR_choicepoint_newer(@var{x}, @var{y})} true
iff the choicepoint indicated by @var{x}
is newer than (i.e.@: was created more recently than)
the choicepoint indicated by @var{y}.
The null ChoicepointId is considered older than any non-null ChoicepointId.
If either of the choice points have been backtracked over,
the behaviour is undefined.

@end table

The way these functions are generally used is as follows.
When you create a mutable data structure,
you should call @code{MR_current_choicepoint_id()}
and save the value it returns
as a @samp{prev_choicepoint} field in your data structure.
When you are about to modify your mutable data structure,
you can then call @code{MR_current_choicepoint_id()} again
and compare the result from that call
with the value saved in the @samp{prev_choicepoint} field in the data structure
using @code{MR_choicepoint_newer()}.
If the current choicepoint is newer, then you must trail the update,
and update the @samp{prev_choicepoint} field with the new value;
furthermore, you must also take care that on backtracking the
previous value of the @samp{prev_choicepoint} field in your data
structure is restored to its previous value, by trailing that update too.
But if @code{MR_current_choice_id()}
is not newer than the @code{prev_choicepoint} field,
then you can safely perform the update to your data structure
without trailing it.

If your mutable data structure is a C global variable,
then you can use @code{MR_null_choicepoint_id()}
for the initial value of the @samp{prev_choicepoint} field.
If on the other hand your mutable data structure
is created by a predicate or function that uses tabled evaluation
(@pxref{Tabled evaluation}),
then you @emph{should} use @code{MR_null_choicepoint_id()}
for the initial value of the field.
Doing so will ensure that the data will be reset to its initial value
if execution backtracks to a point
before the mutable data structure was created,
which is important because this copy of the mutable data structure
will be tabled and will therefore be produced again
if later execution attempts to create another instance of it.

For an example of avoiding redundant trailing, see the sample module below.

Note that there is a cost to this ---
you have to include an extra field in your data structure
for each part of the data structure which you might update,
you need to perform a test for each update to decide
whether or not to trail it,
and if you do need to trail the update,
then you have an extra field that you need to trail.
Whether or not the benefits from avoiding redundant trailing
outweigh these costs will depend on your application.

@example
:- module trailing_example.
:- interface.

:- type int_ref.

    % Create a new int_ref with the specified value.
    %
:- pred new_int_ref(int_ref::uo, int::in) is det.

    % update_int_ref(Ref0, Ref, OldVal, NewVal).
    % Ref0 has value OldVal and Ref has value NewVal.
    %
:- pred update_int_ref(int_ref::mdi, int_ref::muo, int::out, int::in)
    is det.

:- implementation.

:- pragma foreign_decl("C", "

typedef struct @{
    MR_ChoicepointId prev_choicepoint;
    MR_Integer data;
@} C_IntRef;

").

:- pragma foreign_type("C", int_ref, "C_IntRef *").

:- pragma foreign_proc("C",
    new_int_ref(Ref::uo, Value::in),
    [will_not_call_mercury, promise_pure],
"
    C_Intref *x = malloc(sizeof(C_IntRef));
    x->prev_choicepoint = MR_current_choicepoint_id();
    x->data = Value;
    Ref = x;
").

:- pragma foreign_proc("C",
    update_int_ref(Ref0::mdi, Ref::muo, OldValue::out, NewValue::in),
    [will_not_call_mercury, promise_pure],
"
    C_IntRef *x = Ref0;
    OldValue = x->data;

    /* Check whether we need to trail this update. */
    if (MR_choicepoint_newer(MR_current_choicepoint_id(),
        x->prev_choicepoint))
    @{
        /*
        ** Trail both x->data and x->prev_choicepoint,
        ** since we're about to update them both.
        */
        assert(sizeof(x->data) == sizeof(MR_Word));
        assert(sizeof(x->prev_choicepoint) == sizeof(MR_Word));
        MR_trail_current_value((MR_Word *)&x->data);
        MR_trail_current_value((MR_Word *)&x->prev_choicepoint);

        /*
        ** Update x->prev_choicepoint to indicate that
        ** x->data's previous value has been trailed
        ** at this choice point.
        */
        x->prev_choicepoint = MR_current_choicepoint_id();
    @}
    x->data = NewValue;
    Ref = Ref0;
").

@end example

@c @item @code{void MR_untrail_to(MR_TrailEntry *@var{old_trail_ptr}, MR_untrail_reason @var{reason});}
@c
@c Apply all the trail entries between @samp{MR_trail_ptr} and
@c @var{old_trail_ptr}, using the specified @var{reason}.
@c
@c This function is called by the Mercury engine after backtracking,
@c after a commit, or after catching an exception.
@c There is probably little need for user code to call this function,
@c but it might be needed if you're doing certain low-level things
@c such as implementing your own exception handling.

@node Bibliography
@chapter Bibliography

@menu
* [1]::         Spiers, Somogyi, and Sondergaard,
                @cite{Termination Analysis for Mercury}.
* [2]::        	Groger and Plumer, @cite{Handling of mutual recursion in
                automatic termination proofs for logic programs}.
* [3]::         Spiers, @cite{Termination Analysis for logic programs}.
* [4]::         Sagonas, @cite{The SLG-WAM: A Search-Efficient Engine
                for Well-Founded Evaluation of Normal Logic Programs}.
* [5]::         Demoen and Sagonas, @cite{CAT: the copying approach to tabling}.
@end menu

@node [1]
@unnumberedsec [1]
Chris Speirs, Zoltan Somogyi and Harald Sondergaard, @cite{Termination
Analysis for Mercury}.  In P. Van Hentenryck, editor, @cite{Static
Analysis: Proceedings of the 4th International Symposium}, Lecture
Notes in Computer Science. Springer, 1997.  A longer version is
available for download from
@uref{http://www.mercurylang.org/documentation/papers/mu_97_09.ps.gz}.

@node [2]
@unnumberedsec [2]
Gerhard Groger and Lutz Plumer, @cite{Handling of mutual recursion in
automatic termination proofs for logic programs.}  In K. Apt, editor,
@cite{The Proceedings of the Joint International Conference and Symposium on
Logic Programming}, pages 336--350.  MIT Press, 1992.

@node [3]
@unnumberedsec [3]
Chris Speirs, @cite{Termination Analysis for Logic Programs},
Technical Report 97/23, Department of Computer Science, The University
of Melbourne, Melbourne, Australia, 1997.  Available from
@uref{http://www.mercurylang.org/documentation/papers/mu_97_23.ps.gz}.

@node [4]
@unnumberedsec [4]
K. Sagonas, @cite{The SLG-WAM: A Search-Efficient Engine
for Well-Founded Evaluation of Normal Logic Programs},
PhD thesis, SUNY at Stony Brook, 1996.  Available from
@uref{http://user.it.uu.se/~kostis/Thesis/thesis.ps.gz}.

@node [5]
@unnumberedsec [5]
B. Demoen and K. Sagonas, @cite{CAT: the Copying Approach to Tabling},
In C. Palamidessi, H. Glaser and K. Meinke, editors, @cite{Principles of
Declarative Programming, 10th International Symposium, PLILP'98},
Lecture Notes in Computer Science, Springer, 1998.
Available form @uref{http://user.it.uu.se/~kostis/Papers/cat.ps.gz}.

@bye
