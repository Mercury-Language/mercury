\input texinfo
@setfilename mercury_ref.info
@settitle The Mercury Language Reference Manual

@c @ignore
@ifinfo
@format
START-INFO-DIR-ENTRY
* Mercury: (mercury_ref).        The Mercury Language Reference Manual
END-INFO-DIR-ENTRY
@end format
@end ifinfo
@c @end ignore

@c @smallbook
@c @cropmarks
@finalout
@setchapternewpage off
@ifinfo
This file documents the Mercury programming language.

Copyright (C) 1995 University of Melbourne.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@ignore
Permission is granted to process this file through Tex and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.
@end ifinfo

@titlepage
@c @finalout
@title The Mercury Language Reference Manual
@subtitle April, 1996
@author Fergus Henderson
@author Thomas Conway
@author Zoltan Somogyi
@author David Jeffery
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1995 University of Melbourne.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.
@end titlepage
@page
@c ---------------------------------------------------------------------------

@ifinfo
@node Top,,, (mercury)
@top
@end ifinfo
@menu
* Introduction::      A brief introduction to Mercury
* Syntax::            Mercury's syntax is similar to ISO Prolog
* Types::             Mercury has a strong parametric polymorphic type system
* Modes::             Modes allow you to specify the direction of data flow
* Unique modes::      Unique modes allow you to specify when there is only one
                      reference to a particular value, so the compiler can
                      safely use destructive update to modify that value
* Determinism::       Determinism declarations let you specify that a predicate
                      should never fail or should never succeed more than once
* Higher-order::      Mercury supports higher-order predicates and functions,
                      with closures, lambda expressions, and currying
* Modules::           Modules allow you to divide a program into smaller parts
* Semantics::         Declarative and operational semantics of Mercury programs
* Pragmas::           Various compiler directives, used for the C interface
                      and to control optimization.
@end menu

@node Introduction
@chapter Introduction

Mercury is a new general-purpose programming language, designed
and implemented by a small group of researchers at the University
of Melbourne, Australia.  Mercury is based on the paradigm of
purely declarative programming, and was designed to be
useful for the development of large and robust ``real-world'' applications.
It improves on existing logic programming languages by providing
increased productivity, reliability and efficiency, and by avoiding the
need for non-logical program constructs.  Mercury provides the
traditional logic programming syntax, but also allows the
syntactic convenience of user-defined functions, smoothly integrating
logic and functional programming into a single paradigm.

Mercury requires programmers to supply
type, mode and determinism declarations for the predicates
and functions they write.
The compiler checks these declarations,
and rejects the program if it cannot prove
that every predicate or function satisfies its declarations.
This improves reliability,
since many kinds of errors simply cannot happen
in successfully compiled Mercury programs.
It also improves productivity,
since the compiler pinpoints many errors
that would otherwise require manual debugging to locate.
The fact that declarations are checked by the compiler
makes them much more useful than comments
to anyone who has to maintain the program.
The compiler also exploits the guaranteed correctness of the declarations
for significantly improving the efficiency of the code it generates.

To facilitate programming-in-the-large, to allow separate compilation,
and to support encapsulation, Mercury has a simple module system.
Mercury's standard library has a variety of pre-defined modules
for common programming tasks --- see the Mercury Library Reference Manual.

@node Syntax
@chapter Syntax

@menu
* Syntax Overview::
* Tokens::
* Terms::
* Items::
* Declarations::
* Facts::
* Rules::
* Goals::
* DCG-rules::
* DCG-goals::
* Data-terms::
* Implicit quantification::
* Elimination of double negation::
@end menu

@node Syntax Overview
@section Syntax overview

Mercury's syntax is similar to the syntax of Prolog, with some
additional declarations for types, modes, determinism, the module system,
and pragmas, and with the distinction that function symbols may stand also
for invocations of user-defined functions as well as for data constructors.

A Mercury program consists of a set of modules.  Each module is a file
containing a sequence of items (declarations and clauses).  Each item
is a term followed by a period.  Each term is composed of a sequence
of tokens, and each token is composed of a sequence of characters.
Like Prolog, Mercury has the Definite Clause Grammar (DCG) notation
for clauses.

@node Tokens
@section Tokens

Tokens in Mercury are the same as in ISO Prolog.
The only difference is the @samp{#@var{line}} token, which
is used as a line number directive (see below).

The different tokens are as follows.  Tokens may be separated by
whitespace or line number directives.

@table @emph

@item line number directive
A line number directive consists of the character @samp{#},
a positive integer specifying the line number, and then a newline.
A @samp{#@var{line}} directive's only role is to
specifying the line number; it is otherwise ignored by the syntax.
Line number directives may occur anywhere a token may occur.
They are used in conjunction with the @samp{pragma source_file}
declaration to indicate that the Mercury code following was
generated by another tool; they serve to associate each line
in the Mercury code with the source file name and line number of
the original source from which the Mercury code was derived,
so that the Mercury compiler can issue more informative error
messages using the original source code locations.
A @samp{#@var{line}} directive specifies the line number
for the immediately following line.  Line numbers for lines
after that are incremented as usual, so the second line
after a @samp{#100} directive would be considered to be line
number 101.

@item string
A string is a sequence of characters enclosed in double quotes (@code{"}).
Strings may contain backslash escapes.  @samp{\a} stands for ``alert''
(a beep character), @samp{\b} for backspace, @samp{\r} for carriage-return,
@samp{\f} for form-feed, @samp{\t} for tab, @samp{\n} for newline,
@samp{\v} for vertical-tab.  An escaped backslash, single-quote, or
double-quote stands for itself.  The sequence @samp{\x} introduces
a hexadecimal escape; it must be followed by a sequence of hexadecimal
digits and then a closing backslash.  It is replaced
with the character whose character code is identified by the hexadecimal
number.  Similarly, a backslash followed by an octal digit is the
beginning of an octal escape; as with hexadecimal escapes, the sequence
of octal digits must be terminated with a closing backslash.
A backslash followed immediately by a newline is deleted; thus an
escaped newline can be used to continue a string over more than one
source line.  (String literals may also contain embedded newlines.)

@item name
A name is either an unquoted name or a quoted name.
An unquoted name is a lowercase letter followed by zero or more letters,
underscores, and digits.  A quoted name is any sequence of zero or more
characters enclosed in single quotes (@code{'}).  Quoted names can contain
backslash escapes of the same form as for strings.

@item variable
A variable is an uppercase letter or underscore followed by zero or
more letters, underscores, and digits. 
A variable token consisting of single underscore is treated
specially: each instance of @samp{_} denotes a distinct variable.
(In addition, variables starting with an underscore are presumed to be
``don't-care'' variables; the compiler will issue a warning if a
variable that does not start with an underscore occurs only once, or if
a variable starting with an underscore occurs more than once in the
same scope.)

@item integer
An integer is either a decimal, binary, octal, hexadecimal, or character-code
literal.
A decimal literal is any sequence of decimal digits.
A binary literal is @samp{0b} followed by any sequence of binary digits.
An octal literal is @samp{0o} followed by any sequence of octal digits.
A hexadecimal literal is @samp{0x} followed by any sequence of hexadecimal
digits.
A character-code literal is @samp{0'} followed by any single character.

@item float
A floating point literal consists of a sequence of decimal digits,
a decimal point and a sequence of digits (the fraction part), and
the letter @samp{E} and another sequence of decimal digits (the exponent).
The fraction part or the exponent (but not both) may be omitted.

@item open_ct
A left parenthesis, @samp{(}, that is not preceded by whitespace.

@item open
A left parenthesis, @samp{(}, that is preceded by whitespace.

@item close
A right parenthesis, @samp{)}.

@item open_list
A left square bracket, @samp{[}.

@item close_list
A right square bracket, @samp{]}.

@item open_curly
A left curly bracket, @samp{@{}.

@item close_curly
A right curly bracket, @samp{@}}.

@item ht_sep
A ``head-tail separator'', i.e. a vertical bar, @samp{|}.

@item comma
A comma, @samp{,}.

@item end
A full stop (period), @samp{.}.

@item eof
The end of file.

@end table

@node Terms
@section Terms

Syntactically, terms in Mercury are exactly the same as in ISO Prolog,
except that as an extension we permit higher-order terms, as described
below.
However, the meaning of some terms in Mercury is different to that
in Prolog.  See @xref{Data-terms}.

A term is either a variable or a functor.

A functor is an integer, a float, a string, a name, a compound term,
or a higher-order term.

A compound term is a name followed without any intervening
whitespace by an open parenthesis (i.e. an open_ct token),
a sequence of argument terms separated by commas, and a close
parenthesis.  Compound terms may also be specified using
operator notation, as in Prolog.

A higher-order term is a variable followed without any intervening
whitespace by an open parenthesis (i.e. an open_ct token),
a sequence of argument terms separated by commas, and a close
parenthesis.  A higher-order term is equivalent to a compound term
whose functor is the empty name, and whose arguments are the 
the variable followed by the arguments of the higher-order term.
That is, a term such as @code{Var(Arg1, @dots{}, ArgN)} is
parsed as @code{''(Var, Arg1, @dots{}, ArgN)},

@node Items
@section Items

Each item in a Mercury module is either a declaration or a clause.
If the top-level functor of the term is @samp{:-/1},
the item is a declaration, otherwise it is a clause.
There are three types of clauses.
If the top-level functor of the item is @samp{:-/2}, the item is a rule.
If the top-level functor is @samp{-->/2}, the item is a DCG rule.
Otherwise, the item is a fact.
There are two types of rules and facts.
If the top-level functor of the head of a rule is @samp{=/2}, the rule
is a function rule, otherwise it is a predicate rule.
If the top-level functor of the head of a fact is @samp{=/2}, the fact
is a function fact, otherwise it is a predicate fact.

@node Declarations
@section Declarations

The allowed declarations are:

@example
:- type
:- pred
:- func
:- inst
:- mode
:- pragma
:- module
:- interface
:- implementation
:- import_module
:- use_module
:- external
:- end_module
@end example

The @samp{type}, @samp{pred} and @samp{func} declarations are used for the
type system,
the @samp{inst} and @samp{mode} declarations are for the mode system,
the @samp{pragma} declarations are for the C interface, and for
compiler hints about inlining, and the remainder are for the module system. 
They are described in more detail in their respective chapters.

(The current implementation allows @samp{when/2} declarations,
but ignores them.
This helps when one wants to write a program
that is both a Mercury program and an NU-Prolog program.)

@node Facts
@section Facts

A function fact is an item of the form @samp{@var{Head} = @var{Result}}.
A predicate fact is an item of the form @samp{@var{Head}},
where the top-level functor of @var{Head}
is not @code{:-/1}, @code{:-/2}, @code{-->/2}, or @code{=/2}.
In both cases, the @var{Head} term must not be a variable.
The top-level functor of the @var{Head}
determines which predicate or function the fact belongs to;
the predicate or function must have been declared
in a preceding @samp{pred} or @samp{func} declaration in this module.
The arguments of the head must be valid data-terms.
A fact is equivalent to a rule whole body is @samp{true}.

@node Rules
@section Rules

A function rule is an item of the form
@samp{@var{Head} = @var{Result} :- @var{Body}}.
A predicate rule is an item of the form
@samp{@var{Head} :- @var{Body}} where the top-level
functor of @samp{Head} is not @code{=/2}.
In both cases, the @var{Head} term must not be a variable. 
The top-level functor of the @var{Head} determines which predicate or
function the clause belongs to; the predicate or function must have
been declared in a preceding @samp{pred} or @samp{func} declaration in
this module.
The arguments of the head must be valid data-terms.
The @var{Body} must be a valid goal.

@node Goals
@section Goals

A goal is a term of one of the following forms:

@table @asis
@item @code{some @var{Vars} @var{Goal}}
An existential quantification.
@var{Vars} must be a list of variables.
@var{Goal} must be a valid goal.

@item @code{all @var{Vars} @var{Goal}}
A universal quantification.
@var{Vars} must be a list of variables.
@var{Goal} must be a valid goal.
This is an abbreviation for @samp{not (some @var{Vars} not @var{Goal})}.

@item @code{@var{Goal1}, @var{Goal2}}
A conjunction.
@var{Goal1} and @var{Goal2} must be valid goals.

@item @code{@var{Goal1} ; @var{Goal2}}
where @var{Goal1} is not of the form @samp{Goal1a -> Goal1b}:
a disjunction.
@var{Goal1} and @var{Goal2} must be valid goals.

@item @code{true}
The empty conjunction.
Always succeeds.

@item @code{fail}
The empty disjunction.
Always fails.

@item @code{not @var{Goal}}
@itemx @code{\+ @var{Goal}}
A negation.
The two different syntaxes have identical semantics.
@var{Goal} must be a valid goal.

@item @code{@var{Goal1} => @var{Goal2}}
An implication.
This is an abbreviation for @samp{not (@var{Goal1}, not @var{Goal2})}.

@item @code{@var{Goal1} <= @var{Goal2}}
A reverse implication.
This is an abbreviation for @samp{not (@var{Goal2}, not @var{Goal1})}.

@item @code{@var{Goal1} <=> @var{Goal2}}
A logical equivalence.
This is an abbreviation for
@samp{(@var{Goal1} => @var{Goal2}), (@var{Goal1} <= @var{Goal2}}).

@item @code{if @var{CondGoal} then @var{ThenGoal} else @var{ElseGoal}}
@itemx @code{@var{CondGoal} -> @var{ThenGoal} ; @var{ElseGoal}}
An if-then-else.
The two different syntaxes have identical semantics.
@var{CondGoal}, @var{ThenGoal}, and @var{ElseGoal} must be valid goals.
Note that the ``else'' part is @emph{not} optional.

@item @code{@var{Term1} = @var{Term2}}
A unification.
@var{Term1} and @var{Term2} must be valid data-terms.

@item @code{@var{Term1} \= @var{Term2}}
An inequality. 
@var{Term1} and @var{Term2} must be valid data-terms.
This is an abbreviation for @samp{not (@var{Term1} = @var{Term2})}.

@item @code{call(Closure)}
@itemx @code{call(Closure1, Arg1)}
@itemx @code{call(Closure2, Arg1, Arg2)}
@itemx @code{call(Closure3, Arg1, Arg2, Arg3)}
@itemx @dots{}
A higher-order predicate call.  
The closure and arguments must be valid data-terms.
@samp{call(Closure)} just calls
the specified closure.  The other forms append the specified
arguments onto the argument list of the closure before calling it.
See @xref{Higher-order}.

@item @code{Var}
@itemx @code{Var(Arg1)}
@itemx @code{Var(Arg2)}
@itemx @code{Var(Arg2, Arg3)}
@itemx @dots{}
A higher-order predicate call.
@var{Var} must be a variable.
The semantics are exactly the same as for the corresponding
higher-order call using the @code{call/N} syntax, i.e.
@samp{call(Var)}, @samp{call(Var, Arg1)}, etc.

@item @code{@var{Call}}
Any goal which does not match any of the above forms
must be a predicate call.
The top-level functor of the term
determines the predicate called;
the predicate must be declared in a @code{pred} declaration
in the module or in the interface of an imported module.
The arguments must be valid data-terms.

@end table

@node DCG-rules
@section DCG-rules

DCG-rules in Mercury have identical syntax and semantics to
DCG-rules in Prolog.

A DCG-rule is an item of the form @samp{@var{Head} --> @var{Body}}.
The @var{Head} term must not be a variable.  
A DCG-rule is an abbreviation for an ordinary rule with two
additional implicit arguments appended to the arguments of @var{Head}.
These arguments are fresh variables which we shall call
@var{V_in} and @var{V_out}.
The @var{Body} must be a valid DCG-goal,
and is an abbreviation for an ordinary goal.
The next section defines a mathematical function
@samp{DCG-transform(@var{V_in}, @var{V_out}, @var{DCG-goal})}
which specifies the semantics of how DCG goals are transformed into
ordinary goals.  (The @samp{DCG-transform} function is purely for the
purposes of exposition, to define the semantics --- it is not part of the
language.)

@node DCG-goals
@section DCG-goals

A DCG-goal is a term of one of the following forms:

@table @code
@item some @var{Vars} @var{DCG-goal}
A DCG existential quantification.
@var{Vars} must be a list of variables.
@var{DCG-goal} must be a valid DCG-goal.

Semantics:
@example
transform(V_in, V_out, some Vars DCG_goal) = 
some Vars transform(V_in, V_out, DCG_goal)
@end example

@item all @var{Vars} @var{DCG-goal}
A DCG universal quantification.
@var{Vars} must be a list of variables.
@var{DCG-goal} must be a valid DCG-goal.

Semantics:
@example
transform(V_in, V_out, all Vars DCG_goal) = 
all Vars transform(V_in, V_out, DCG_goal)
@end example

@item @var{DCG-goal1}, @var{DCG-goal2}
A DCG sequence.
Intuitively, this means ``parse DCG-goal1 and then parse DCG-goal2''
or ``do DCG-goal1 and then do DCG-goal2''.
(Note that the only way this construct actually forces the desired sequencing
is by the modes of the implicit DCG arguments.)
@var{DCG-goal1} and @var{DCG-goal2} must be valid DCG-goals.

Semantics:
@c XXX too indented
@example
transform(V_in, V_out, (DCG-goal1, DCG-goal2)) =
transform(V_in, V_new, DCG_goal1), transform(V_new, V_out, DCG_goal2)
@end example
where V_new is a fresh variable.

@item @var{DCG-goal1} ; @var{DCG-goal2}
A disjunction.  @var{DCG-goal1} and @var{DCG-goal2} must be valid goals.
@var{DCG-goal1} must not be of the form @samp{DCG-goal1a -> DCG-goal1b}.
(If it is, then the goal is an if-then-else, not a disjunction.)

Semantics:
@c XXX too indented
@example
transform(V_in, V_out, (DCG_goal1 ; DCG_goal2)) =
transform(V_in, V_out, DCG_goal1) ; transform(V_in, V_out, DCG_goal2)
@end example

@item @{ @var{Goal} @}
A brace-enclosed ordinary goal.
@var{Goal} must be a valid goal.

Semantics:
@example
transform(V_in, V_out, @{ Goal @}) = (Goal, V_out = V_in)
@end example

@itemx [@var{Term}, @dots{}]
A DCG input match.
Unifies the implicit DCG input variable V_in,
which must have type @samp{list(_)},
with a list whose initial elements are the terms specified
and whose tail is the implicit DCG output variable V_out.
The terms must be valid data-terms.

Semantics:
@example
transform(V_in, V_out, [Term1, @dots{}]) = (V_in = [Term, @dots{} | V_Out])
@end example

@item []
The null DCG goal (an empty DCG input match).
Equivalent to @samp{@{ true @}}.

Semantics:
@example
transform(V_in, V_out, []) = (V_out = V_in)
@end example

@item not @var{DCG-goal}
@itemx \+ @var{DCG-goal}
A DCG negation.
The two different syntaxes have identical semantics.
@var{Goal} must be a valid goal.

Semantics:
@example
transform(V_in, V_out, not DCG_goal) =
(not transform(V_in, V_new, DCG_goal), V_out = V_in)
@end example
where V_new is a fresh variable.

@item if @var{CondGoal} then @var{ThenGoal} else @var{ElseGoal}
@itemx @var{CondGoal} -> @var{ThenGoal} ; @var{ElseGoal}
A DCG if-then-else.
The two different syntaxes have identical semantics.
@var{CondGoal}, @var{ThenGoal}, and @var{ElseGoal} must be valid DCG-goals.

Semantics:
@example
transform(V_in, V_out, if CondGoal then ThenGoal else ElseGoal) =
if transform(V_in, V_cond, CondGoal) then
        transform(V_cond, V_out, ThenGoal)
else
        transform(V_in, V_out, ElseGoal)
@end example

@item =(@var{Term})
A DCG unification.  Unifies @var{Term} with the implicit DCG argument.
@var{Term} must be a valid data-term.

Semantics:
@example
transform(V_in, V_out, =(Term)) = (Term = V_in, V_out = V_in)
@end example

@item @var{DCG-call}
Any term which does not match any of the above forms
must be a DCG predicate call.
If the term is a variable @var{Var},
it is treated as if it were @samp{call(@var{Var})}.
Then, the two implicit DCG arguments are appended to the specified arguments.

Semantics:
@example
transform(V_in, V_out, p(A1, @dots{}, AN)) =
p(A1, @dots{}, AN, V_in, V_out)
@end example

@end table

@node Data-terms
@section Data-terms

Syntactically, a data-term is just a term.

There are a couple of differences from Prolog.
The first one is that double-quoted strings are atomic in
Mercury, they are not abbreviations for lists of character codes.
The second is that Mercury terms may contain function applications,
higher-order function applications, and lambda expressions.

A data-term is either a variable, a data-functor, a higher-order
function application, or a lambda expression.

A data-functor is an integer, a float, a string, a character literal
(any single-character name), a name, or a compound data-term.
A compound data-term is a compound term whose form
does not match the form of a lambda expression or higher-order
function application and whose arguments are data-terms.
If a data-functor is a name or a compound data-term, its top-level functor
must name a function, predicate, or data constructor declared
in the program or in the interface of an imported module.

A lambda expression is a compound term of one of the following forms

@example
lambda([Var1::Mode1, Var2::Mode2, @dots{}] is Det, Goal)
pred(Var1::Mode1, Var2::Mode2, @dots{}) is Det :- Goal
func(Var1::Mode1, Var2::Mode2, @dots{}) = (Var::Mode) is Det :- Goal
func(Var1, Var2, @dots{}) = Var :- Goal
@end example

@noindent
where Var1, Var2, @dots{} are variables, Mode1, Mode2, @dots{} are
modes [@xref{Modes}], Det is a determinism [@xref{Determinism}],
and Goal is a goal [@xref{Goals}]. 
It denotes a higher-order predicate or function term
whose value is the predicate or function of the specified arguments
determined by the specified goal.
See @xref{Higher-order}.

A higher-order function application is a compound term of one
of the following two forms

@example
apply(@var{Func}, @var{Arg1}, @var{Arg2}, @dots{}, @var{ArgN})
@var{FuncVar}(@var{Arg1}, @var{Arg2}, @dots{}, @var{ArgN})
@end example

@noindent
where @var{N} >= 1, @var{Func} is a term of type
@samp{func(T1, T2, ..., Tn) = T}, @var{FuncVar} is a variable
of that type, and
@var{Arg1}, @var{Arg2}, @dots{}, @var{ArgN} are terms of types
@samp{T1}, @samp{T2}, @dots{}, @samp{Tn}. 
The type of the higher-order function application term is @var{T}.
It denotes the result of applying the specified function to the
specified arguments.  See @xref{Higher-order}.

@node Implicit quantification
@section Implicit quantification

The rule for implicit quantification in Mercury
is not the same as the usual one in mathematical logic.
In Mercury variables that do not occur in the head of a clause
are implicitly existentially quantified around their closest enclosing scope
(in a sense to be made precise in the following paragraphs).
This allows most existential quantifiers to be omitted,
and leads to more concise code.

An occurrence of a variable is @dfn{in a negated context}
if it is in a negation,
in a universal quantification,
in the condition of an if-then-else,
in an inequality,
or in a lambda expression.

Two goals are @dfn{parallel}
if they are different disjuncts of the same disjunction,
or if one is the ``else'' part of an if-then-else
and the other goal is either the ``then'' part or the condition
of the if-then-else,
or if they are the goals of disjoint (distinct and non-overlaping)
lambda expressions.

If a variable occurs in a negated context
and does not occur outside of that negated context other than in parallel goals
(and in the case of a variable in the condition of an if-then-else,
other than in the ``then'' part of the if-then-else),
then that variable is implicitly existentially quantified inside the negation.

@node Elimination of double negation
@section Elimination of double negation

The treatment of inequality, universal quantification,
implication, and logical equivalence as abbreviations
can cause the introduction of double negations
which could make otherwise well-formed code mode-incorrect.
To avoid this problem, the language specifies that
double negations are removed after syntax analysis,
before mode analysis is performed.

@node Types
@chapter Types

The type system is based on polymorphic many-sorted logic.

Certain special types are builtin, or are defined in the Mercury library:

@table @asis
@item Primitive types: @code{char}, @code{int}, @code{float}, @code{string}.
There is a special syntax for constants of type @code{int}, @code{float},
and @code{string}.  (For @code{char}, the standard syntax suffices.)

@item Predicate types: @code{pred}, @code{pred(T)}, @code{pred(T1, T2)}, @dots{}
@itemx Function types: @code{func(T1) = T}, @code{func(T1, T2) = T}, @dots{}
These higher-order function and predicate types are used to pass procedure
addresses and closures to other predicates.  See @xref{Higher-order}.

@item The universal type: @code{univ}.
The type @code{univ} is defined in the standard library module @code{std_util},
along with the predicates @code{type_to_univ/2} and @code{univ_to_type/2}.
With those predicates, any type can be converted to the universal type
and back again.
The universal type is useful for situations
where you need heterogeneous collections.

@item The ``state-of-the-world'' type: @code{io__state}.
The type @code{io__state} is defined in the standard library module @code{io},
and represents the state of the world.
Predicates which perform I/O are passed the old state of the world
and produce a new state of the world.
In this way, we can give a declarative semantics to code that performs I/O.

@end table

New types can be introduced with @samp{:- type} declarations.
There are several categories of derived types:

@itemize @bullet
@item
Discriminated unions: these encompass both enumeration and
record types in other languages.
A derived type is defined using @samp{:- type @var{type} ---> @var{body}}. 
(Note there are @emph{three} dashes in that arrow.
It should not be confused with the two-dash arrow used for DCGs
or the one-dash arrow used for if-then-else.)
If the @var{type} term is a functor of arity zero,
it names a monomorphic type.
Otherwise, it names a polymorphic type;
the arguments of the functor must be distinct type variables.
The @var{body} term is defined as
a sequence of constructor definitions separated by semi-colons.
Each constructor definition is a functor whose arguments (if any) are types.
Type definitions must be @dfn{transparent}:
all type variables occurring in the @var{body}
must also occur in the @var{type}.

Here are some examples:

@example
:- type fruit
        --->    apple
        ;       orange
        ;       banana
        ;       pear.

:- type strange
        --->    foo(int)
        ;       bar(string).

:- type employee
        --->    employee(
                       string,               % name
                       int,                  % age
                       string                % department
                ).

:- type tree
        --->    empty
        ;       leaf(int)
        ;       branch(tree, tree).

:- type list(T)
        --->    []
        ;       [T | list(T)].

:- type pair(T1, T2)
        --->    T1 - T2.
@end example

If the body of a discriminated union type definition
contains a term whose top-level functor is @code{';'/2},
the semi-colon is normally assumed to be a separator.
This makes it difficult to define a type
whose constructors include @code{';'/2}.
To allow this, curly braces can be used to quote the semi-colon.
It is then also necessary to quote curly braces.
The following example illustrates this:

@example
:- type tricky
        --->    @{ int ; int @}
        ;       @{ @{ int @} @}.
@end example

This defines a type with two constructors, @code{';'}/2 and @code{'@{@}'/1},
whose argument types are all @code{int}.

Each discriminated union type definition introduces a distinct type.
Mercury considers two discriminated union types that have the same bodies
to be distinct types (name equivalence).
Having two different types with the same name and arity in the program
is an error.
(We hope to relax this in the future, to allow types with the same name
and arity in different modules.)

@item
Equivalence types: these are type abbreviations.
They are defined using `==' as follows.
They may be polymorphic.

@example
:- type money == int.
:- type assoc_list(KeyType, ValueType)
        == list(pair(KeyType, ValueType)).
@end example

Like discriminated union type definitions,
equivalence type definitions must be transparent.

Mercury treats an equivalence type
as an abbreviation for the type on the right hand side of the definition;
the two are equivalent in all respects
in scopes where the equivalence type is visible.

@item
Abstract types: these are types whose implementation is hidden.
The type declarations

@example
:- type t1.
:- type t2(T1, T2).
@end example

@noindent
declare types @code{t1/0} and @code{t2/2} to be abstract types.
Such declarations are only useful in the interface section of a module.
This means that the type names will be exported,
but the constructors (functors) for these types will not be exported.
The implementation section of a module
must have give the definition of all the abstract types
named in the interface section of the module.
Abstract types may be defined as either discriminated union types
or as equivalence types.

@end itemize

Constructors may be overloaded among different types:
there may be any number of constructors with a given name and arity,
so long as they all have different types.
However, there must be only one constructor
with a given name, arity, and result type.
(There is no particularly good reason for this restriction;
in the future we may allow several such functors
as long as they have different argument types.)
Note that excessive overloading of constructors can slow down type checking
and can make the program confusing for human readers,
so overloading should not be over-used.

The argument types of each predicate
must be explicitly declared with a @samp{:- pred} declaration.
The argument types and return type of each function must be
explicitly declared with a @samp{:- func} declaration.
These declarations may be polymorphic.
For example:

@example
:- pred member(T, list(T)).

:- func length(list(T)) = int.
@end example

There must only be one predicate with a given name and arity in each module,
and only one function with a given name and arity in each module.
The current implementation does not support defining a function of arity
@var{N} and a predicate of arity @var{N+1} in the same module.

The compiler infers the types of data-terms, and in particular the types
of variables and overloaded constructors, functions, and predicates.
A @dfn{type assignment} is an assignment of a type
to every variable and of a particular constructor, function, or predicate
to every name in a clause.
A type assignment is @dfn{valid} if it satisfies the following conditions.

Each constructor in a clause
must have been declared in at least one visible type declaration.
The type assigned to each constructor term
must match one of the type declarations for that constructor,
and the types assigned to the arguments of that constructor
must match the argument types specified in that type declaration.

The type assigned to each function call term
must match the return type of one of the @samp{:- func} declarations
for that function, and the types assigned to the arguments of that function
must match the argument types specified in that type declaration.

The type assigned to each predicate argument must match
the type specified in one of the @samp{:- pred} declarations for that predicate.
The type assigned to each head argument in a predicate clause must exactly match
the argument type specified in the corresponding @samp{:- pred} declaration.

The type assigned to each head argument in a function clause must exactly match
the argument type specified in the corresponding @samp{:- func} declaration,
and the type assigned to the result term in a function clause must exactly
match the result type specified in the corresponding @samp{:- func} declaration.

(Here ``match'' means to be an instance of,
i.e. to be identical to for some substitution of the type parameters,
and ``exactly match'' means to be identical up to renaming of type parameters.)

One type assignment @var{A} is said to be
@dfn{more general} than another type assignment @var{B}
if there is a binding of the type parameters in A
that makes it identical (up to renaming of parameters) to B.
If there is more than one valid type assignment,
the compiler must choose the most general one.
If there are two valid type assignments which are not identical up to renaming
and neither of which is more general than the other,
then there is a type ambiguity, and compiler must report an error.
A clause is @dfn{type-correct}
if there is a unique (up to renaming) most general valid type assignment.
Every clause in a Mercury program must be type-correct.

@node Modes
@chapter Modes

The @dfn{mode} of a predicate, or function, is a mapping
from the initial state of instantiation of the arguments of the predicate,
or the arguments and result of a function,
to their final state of instantiation.
To describe states of instantiation,
we use information provided by the type system.
Types can be viewed as regular trees with two kinds of nodes:
or-nodes representing types
and and-nodes representing constructors.
The children of an or-node are the constructors
that can be used to construct terms of that type;
the children of an and-node are the types
of the arguments of the constructors.
We attach mode information to the or-nodes of type trees.

An @dfn{instantiatedness tree} is an assignment
of an @dfn{instantiatedness} --- either @dfn{free} or @dfn{bound} ---
to each or-node of a type tree,
with the constraint that all descendants of a free node must be free.

A term is @dfn{approximated by} an instantiatedness tree
if for every node in the instantiatedness tree,

@itemize @bullet
@item
if the node is ``free'',
then the corresponding node in the term (if any)
is a free variable that does not share with any other variable
(we call such variables @dfn{distinct});

@item
if the node is ``bound'',
then the corresponding node in the term (if any)
is a function symbol.

@end itemize

When an instantiatedness tree tells us that a variable is bound,
there may be several alternative function symbols to which it could be bound.
The instantiatedness tree does not tell us which of these it is bound to;
instead for each possible function symbol it tells us exactly
which arguments of the function symbol will be free and which will be bound.
The same principle applies recursively to these bound arguments.

Mercury's mode system allows users
to declare names for instantiatedness trees using declarations such as

@example
:- inst listskel = bound( [] ; [free | listskel] ).
@end example

This instantiatedness tree describes lists
whose skeleton is known but whose elements are distinct variables.
As such, it approximates the term @code{[A,B]}
but not the term @code{[H|T]} (only part of the skeleton is known),
the term @code{[A,2]} (not all elements are variables),
or the term @code{[A,A]} (the elements are not distinct variables).

As a shorthand, the mode system provides @samp{free} and @samp{ground}
as names for instantiatedness trees
all of whose nodes are free and bound respectively.
The shape of these trees is determined by
the type of the variable to which they apply.

As execution proceeds, variables may become more instantiated.
A @dfn{mode mapping} is a mapping
from an initial instantiatedness tree to a final instantiatedness tree,
with the constraint that no node of the type tree
is transformed from bound to free.
Mercury allows the user to specify mode mappings directly
by expressions such as @code{inst1 -> inst2},
or to give them a name using declarations such as

@example
:- mode m :: inst1 -> inst2.
@end example

Two standard shorthand modes are provided,
corresponding to the standard notions of inputs and outputs:

@example
:- mode in :: ground -> ground.
:- mode out :: free -> ground.
@end example

Prolog fans who want to use the symbols @samp{+} and @samp{-}
can do so by simply defining them using a mode declaration:

@example
:- mode (+) :: in.
:- mode (-) :: out.
@end example

These two modes are enough for most functions and predicates.
Nevertheless, Mercury's mode system is sufficiently
expressive to handle more complex data-flow patterns,
including those involving partially instantiated data structures.  
(The current implementation does not handle
partially instantiated data structures yet.)

For example, consider an
interface to a database that associates data with keys, and provides
read and write access to the items it stores.  To represent accesses to
the database over a network, you would need declarations such as

@example
:- type operation
        --->    lookup(key, data)
        ;       set(key, data).
:- inst request =
        bound(  lookup(ground, free)
        ;       set(ground, ground)
        ).
:- mode create_request :: free -> request.
:- mode satisfy_request :: request -> ground.
@end example

@samp{inst} and @samp{mode} declarations can be parametric.
For example, the following declaration 

@example
:- inst listskel(Inst) = bound( [] ; [Inst | listskel] ).
@end example

@noindent
defines the inst @samp{listskel(Inst)} to be a list skeleton
whose elements have inst @samp{Inst}; you can the use insts
such as @samp{listskel(listskel(free))}, which represents
the instantiation state of a list of lists of free variables.
The standard library provides the parametric modes

@example
:- mode in(Inst) :: Inst -> Inst.
:- mode out(Inst) :: free -> Inst.
@end example

@noindent
so that for example the mode @samp{create_request} defined above
could have be defined as

@example
:- mode create_request :: out(request).
@end example

A @dfn{predicate mode declaration}
assigns a mode mapping to each argument of a predicate.
A @dfn{function mode declaration}
assigns a mode mapping to each argument of a function,
and a mode mapping to the function result.
Each mode of a predicate or function is called a @dfn{procedure}.
For example, given the mode names defined by

@example
:- mode out_listskel ::
        free -> listskel.
:- mode in_listskel ::
        listskel -> listskel.
@end example

the (type and) mode declarations of the function length and predicate append
are as follows:

@example
:- func length(list(T) = int.
:- mode length(in_listskel) = out.
:- mode length(out_listskel) = in.

:- pred append(list(T), list(T), list(T)).
:- mode append(in, in, out).
:- mode append(out, out, in).
@end example

Note that functions may have more than one mode, just like predicates;
functions can be reversible.

Alternately, the mode declarations for @samp{length} could use
the standard library modes @samp{in/1} and @samp{out/1}:

@example
:- func length(list(T)) = int.
:- mode length(in(listskel)) = out.
:- mode length(out(listskel)) = in.
@end example

If a predicate or function has only one mode, the @samp{pred} and @samp{mode}
declaration can be combined:

@example
:- func length(list(T)::in) = (int::out).
:- pred append(list(T)::in, list(T)::in, list(T)::out).
@end example

If there is no mode declaration for a function, the compiler assumes
a default mode for the function in which all the arguments have mode @samp{in}
and the result of the function has mode @samp{out}.  (However, there
is no requirement that a function have such a mode; if there is any
explicit mode declaration, it overrides the default.)

A function or predicate mode declaration is an assertion by the programmer
that for all possible argument terms and (if applicable) result term
for the function or predicate
that are approximated (in our technical sense)
by the initial instantiatedness trees of the mode declaration
and all of whose free variables are distinct,
if the function or predicate succeeds then
the resulting binding of those argument terms and (if applicable)
result term will in turn be approximated
by the final instantiatedness trees of the mode declaration,
with all free variables again being distinct.
We refer to such assertions as @dfn{mode declaration constraints}.
These assertions are checked by the compiler,
which rejects programs if it cannot prove
that their mode declaration constraints are satisfied.

Note that with the usual definition of append, the mode

@example
:- mode append(in_listskel, in_listskel, out_listskel).
@end example

would not be allowed, since it would create aliasing between the
different arguments --- on success of the predicate, the list elements
would be free variables but they would not be distinct.

In Mercury it is always possible to call a procedure with an
argument that is is more bound than the initial inst specified for that
argument in the procedure's mode declaration.  In such cases, the
compiler will insert additional unifications to ensure that the
argument actually passed to the procedure will have the inst specified.
For example, if the predicate @code{p/1} has mode @samp{p(out)}, you
can still call @samp{p(X)} if @code{X} is ground.  The compiler will
transform this code to @samp{p(Y), X = Y} where @code{Y} is a fresh
variable.  It is almost as if the predicate @code{p/1} has another mode
@samp{p(in)}; we call such modes ``implied modes''.

To make this concept precise, we introduce the following definition.
A term @dfn{satisfies} an instantiatedness tree
if for every node in the instantiatedness tree,

@itemize @bullet
@item
if the node is ``free'',
then the corresponding node in the term (if any)
is either a distinct free variable,
or a function symbol.

@item
if the node is ``bound'',
then the corresponding node in the term (if any)
is a function symbol.

@end itemize

The @dfn{mode set} for a predicate or function
is the set of mode declarations for the predicate or function.
A mode set is an assertion by the programmer
that the predicate should only be called with argument terms
that satisfy the initial instantiatedness trees
of one of the mode declarations in the set
(i.e. the specified modes and the modes they imply
are the only allowed modes for this predicate or function).
We refer to the assertion associated with a mode set
as the @dfn{mode set constraint};
these are also checked by the compiler.

A predicate or function @var{p} is @dfn{well-moded
with respect to a given mode declaration}
if given that the predicates and functions called by @var{p}
all satisfy their mode declaration constraints,
there exists an ordering of the literals in the definition of @var{p}
such that

@itemize @bullet
@item
@var{p} satisfies its mode declaration constraint, and
@item
@var{p} satisfies the mode set constraint of all of the predicates and
functions it calls
@end itemize

We say that a predicate or function is well-moded
if it is well-moded with respect to
all the mode declarations in its mode set,
and we say that a program is well-moded
if all its predicates and functions are well-moded.

The mode analysis algorithm checks one procedure at a time.
It abstractly interprets the definition of the predicate or function,
keeping track of the instantiatedness of each variable,
and selecting a mode for each call and unification in the definition.
To ensure that
the mode set constraints of called predicates and functions are satisfied,
the compiler may reorder the elements of conjunctions;
it reports an error if no satisfactory order exists.
Finally it checks that
the resulting instantiatedness of the procedure's arguments
is the same as the one given by the procedure's declaration.

The mode analysis algorithm annotates each call with the mode used.

@node Unique modes
@chapter Unique modes

Mode declarations can also specify so-called ``unique modes''.
Mercury's unique modes are similar to ``linear types'' in some
functional programming languages such as Clean.  They allow you to
specify when there is only one reference to a particular value, and
when there will be no more references to that value.  If the compiler
knows there are will be more references to a value, it can perform
``compile-time garbage collection'' by automatically inserting code
to deallocate the storage associated with that value.  Even more
importantly, the compiler can also simply reuse the storage immediately,
for example by destructively updating one element of an array rather
than making a new copy of the entire array in order to change one element.
Unique modes are also the mechanism Mercury uses to provide declarative I/O.

We have not yet implemented unique modes fully, and the details are
still in a state of flux.  So the following should be considered
tentative.

@menu
* Destructive update::
* Backtrackable destructive update::
* Limitations of the current implementation::
@end menu

@node Destructive update
@section Destructive update

In addition to the insts mentioned above (@samp{free}, @samp{ground},
and @samp{bound(@dots{})}), Mercury also provides ``unique'' insts
@samp{unique} and @samp{unique(@dots{})} which are like @samp{ground}
and @samp{bound(@dots{})} respectively, except that they carry the
additional constraint that there can only be one reference to the
corresponding value.  There is also an inst @samp{dead} which means
that there are no references to the corresponding value, so the compiler
is free to generate code that reuses that value.
There are three standard modes for manipulation unique values:

@example
% unique output
:- mode uo :: free -> unique.

% unique input
:- mode ui :: unique -> unique.

% destructive input
:- mode di :: unique -> dead.
@end example

Mode @samp{uo} is used to create a unique value.
Mode @samp{ui} is used to inspect a unique value without
losing its uniqueness.
Mode @samp{di} is used to deallocate or reuse the memory
occupied by a value that will not be used.

Note that a value is not considered @samp{unique} if it might be
needed on backtracking.  This means that unique modes are generally
only useful for code whose determinism is @samp{det} or @samp{cc_multidet}
(@pxref{Determinism}).

@node Backtrackable destructive update
@section Backtrackable destructive update

@quotation
``Well it just so happens that your friend here is only @emph{mostly} dead.
@*There's a big difference between mostly dead and all dead@dots{}
@*Now, mostly dead is slightly alive.
@*Now, all dead --- well, with all dead, there's usually only
one thing that you can do.''

``What's that?''

``Go through his clothes and look for loose change!''

--- from the movie ``The Princess Bride''.
@end quotation

To allow for backtrackable destructive updates --- that is, updates
whose effect is undone on backtracking, perhaps by recording the
overwritten values on a ``trail'' so that they can be restored
after backtracking --- Mercury also provides ``mostly unique''
modes.  The insts @samp{mostly_unique} and @samp{mostly_dead}
are equivalent to @samp{unique} and @samp{dead},
except that only references which will be encountered during 
forward execution are counted - it is OK for @samp{mostly_unique} or
@samp{mostly_dead} values to be needed again on backtracking.

@node Limitations of the current implementation
@section Limitations of the current implementation

The implementation of the mode analysis algorithm is not quite complete;
as a result, it is not possible to use nested unique modes, i.e.
modes in which anything but the top level of a variable is unique.
If you do, you will get unique mode errors when you try
to get a unique field of a unique data structure.

The Mercury compiler does not (yet) reuse @samp{dead}
values.  The only destructive update in the current implementation occurs
in the library modules for I/O and arrays.  We do however plan to
implement structure reuse and compile-time garbage collection
in the very near future.

Reusing @samp{mostly_dead} values would require keeping a trail, which
might negatively impact on the performance of code which didn't use
backtrackable destructive update.  Furthermore, it wouldn't have such a
big impact as reuse of @samp{dead} values; it really pays off only for
large structures or arrays.  As a result, implementing reuse of
@samp{mostly_dead} values is a much lower priority on our
implementation schedule.

@node Determinism
@chapter Determinism

@menu
* Determinism categories::
* Determinism checking and inference::
* Replacing compile-time checking with run-time checking::
* Interfacing nondeterministic code with the real world::
* Committed choice nondeterminism::
@end menu

@node Determinism categories
@section Determinism categories

For each mode of a predicate or function,
we categorise that mode according to how many times it can succeed,
and whether or not it can fail before producing its first solution.

@itemize @bullet
@item
If all possible calls to a particular mode of a predicate or function
have exactly one solution,
then that mode is @dfn{deterministic} (@code{det}).

@item
If all possible calls to a particular mode of a predicate or function
either have no solutions or have one solution,
then that mode is @dfn{semideterministic} (@code{semidet}).

@item
If all possible calls to a particular mode of a predicate or function
have at least one solution but may have more,
then that mode is @dfn{multisolution} (@code{multi}).

@item
If some possible calls to a particular mode of a predicate or function
have no solution but other calls may have more than one solution,
then that mode is @dfn{nondeterministic} (@code{nondet}).

@item
If all possible calls to a particular mode of a predicate or function
fail without producing a solution,
then that mode has a determinism of @code{failure}.

@item
If all possible calls to a particular mode of a predicate or function
lead to a runtime error, i.e. neither succeed nor fail,
then that mode has a determinism of @code{erroneous}.
@end itemize

The determinism annotation @code{erroneous} is used on the library
predicate @samp{error/1}, but apart from that those last two determinism
annotations are generally not needed.

To summarize:

@example
                Maximum number of solutions
Can fail?       0               1               > 1
no              erroneous       det             multi
yes             failure         semidet         nondet
@end example

The determinism of each mode of a predicate or function
is indicated by an annotation on the mode declaration.
For example:

@example
:- pred append(list(T), list(T), list(T)).
:- mode append(in, in, out) is det.
:- mode append(out, out, in) is multi.
:- mode append(in, in, in) is semidet.

:- func length(list(T)) = int.
:- mode length(in) = out is det.
:- mode length(in(list_skel)) = out is det.
:- mode length(in) = in is semidet.
@end example

An annotation of @samp{det} or @samp{multidet} is an assertion that
for every value each of the inputs, there exists at least one value
of the outputs for which the predicate is true, or (in the case
of functions) for which the function term is equal to the result term.
Conversely, an annotation of @samp{det} or @samp{semidet} is an assertion
that for every value each of the inputs, there exists at most one value
of the outputs for which the predicate is true, or (in the case
of functions) for which the function term is equal to the result term.
These assertions are called the @dfn{mode-determinism assertions};
they can play a role in the semantics, because in certain 
circumstances they may allow an implementation to perform optimizations
that would not otherwise be allowed, such as optimizing away a goal
with no outputs even though it might infinitely loop.

If the mode of the predicate is given in the @code{:- pred} declaration
rather than in a separate @code{:- mode} declaration,
then the determinism annotation goes on the @code{:- pred} declaration
(and similarly for functions).
In particular, this is necessary
if a predicate does not have any argument variables.
For example:

@example
:- pred loop(int::in) is erroneous.
loop(X) :- loop(X).

:- pred p is det.
p.

:- pred q is failure.
q :- fail.
@end example

If there is no mode declaration for a function, then the default
mode for that function is considered to have been declared as @samp{det}.
If you want to write a partial function, i.e. one whose determinism
is @samp{semidet}, then you must explicitly declare the mode and determinism.

The determinism categories form this lattice:

@example
             erroneous
              /     \
          failure   det
             \     /   \
             semidet  multi
                 \     /
                  nondet
@end example

The higher up this lattice a determinism category is,
the more the compiler knows about the number of solutions
of predicates of that determinism.

@node Determinism checking and inference
@section Determinism checking and inference

The determinism of goals
is inferred from the determinism of their component parts,
according to the rules below.
The inferred determinism of a procedure is just the inferred
determinism of the procedure's body.

For procedures that are local to a module,
the determinism annotations may be omitted;
in that case, their determinism will be inferred.
(To be precise, the determinism of procedures without a determinism annotation
is defined as the least fixpoint of the transformation which,
given an initial assignment
of the determinism @code{det} to all such procedures,
applies those rules to infer
a new determinism assignment for those procedures.)

It is an error to omit the determinism annotation
for procedures that are exported from their containing module.

If a determinism annotation is supplied for a procedure,
the declared determinism is compared against the inferred determinism.
If the declared determinism is greater than or not comparable to the
inferred determinism (in the partial ordering above), it is an error.
If the declared determinism is less than the inferred determinism,
it is not an error, but the implementation may issue a warning.

The determinism category of each goal
is inferred according to the following rules.
These rules work with the two components of determinism category:
whether the goal can fail without producing a solution,
and the maximum number of solutions of the goal (0, 1, or more).
If the inference process below reports that a goal can succeed more than once,
but the goal generates no outputs that are visible from outside the goal,
the final determinism of the goal
will be based on the goal succeeding at most once,
since the compiler will implicitly prune away any duplicate solutions.

@table @asis
@item Calls
The determinism category of a call is the determinism
declared or inferred for the called mode of the called procedure.

@item Unifications
The determinism of a unification
is either @code{det}, @code{semidet}, or @code{failure},
depending on its mode.

A unification that assigns the value of one variable to another
is deterministic.
A unification that constructs a structure and assigns it to a variable
is also deterministic.
A unification that tests whether a variable has a given top function symbol
is semideterministic,
unless the compiler knows the top function symbol of that variable,
in which case its determinism is either det or failure
depending on whether the two function symbols are the same or not.
A unification that tests two variables for equality
is semideterministic,
unless the compiler knows that the two variables are aliases for one another,
in which case the unification is deterministic,
or unless the compiler knows that the two variables
have different function symbols in the same position,
in which case the unification has a determinism of failure.

The compiler knows the top function symbol of a variable
if the previous part of the predicate definition
contains a unification of the variable with a function symbol,
or if the variable's type has only one function symbol.

@item Conjunctions
The determinism of the empty conjunction (the goal @samp{true})
is @code{det}.
The conjunction @samp{(@var{A}, @var{B})} can fail
if either @var{A} or @var{B} can fail.
The conjunction can succeed at most zero times
if either @var{A} or @var{B} can succeed at most zero times.
The conjunction can succeed more than once
if either @var{A} or @var{B} can succeed more than once
and both @var{A} and @var{B} can succeed at least once.
(If e.g. @var{A} can succeed at most zero times,
then even if @var{B} can succeed many times
the maximum number of solutions of the conjunction is still zero.)
Otherwise, i.e. if both @var{A} and @var{B} succeed at most once,
the conjunction can succeed at most once.

@item Switches
A disjunction is a @emph{switch}
if each disjunct has near its start a unification that
tests the same bound variable against a different function symbol.
For example, consider the common pattern

@example
(
        L = [], empty(Out)
;
        L = [H|T], nonempty(H, T, Out)
)
@end example

If L is input to the disjunction, then the disjunction is a switch on L.

A switch can fail
if the various arms of the switch do not cover
all the function symbols in the type of the switched-on variable,
or if the code in some arms of the switch can fail,
bearing in mind that in each arm of the switch,
the unification that tests the switched-on variable
against the function symbol of that arm is considered to be deterministic.
A switch can succeed several times
if some arms of the switch can succeed several times,
possibly because there are multiple disjuncts
that test the switched-on variable against the same function symbol.
A switch can succeed at most zero times
only if all arms of the switch can succeed at most zero times.

@item Disjunctions
The determinism of the empty disjunction (the goal @samp{fail})
is @code{failure}.
A disjunction @samp{(@var{A} ; @var{B})} that is not a switch
can fail if both @var{A} and @var{B} can fail.
It can succeed at most zero times
if both @var{A} and @var{B} can succeed at most zero times.
It can succeed at most once
if one of @var{A} and @var{B} can succeed at most once
and the other can succeed at most zero times.
Otherwise, i.e. if either @var{A} or @var{B} can succeed more than once,
or if both @var{A} and @var{B} can succeed at least once,
it can succeed more than once.

@c The local determinism of a disjunction is @code{nondet} unless the
@c compiler can detect that the disjunction is actually a switch and
@c hence @dfn{index} the disjunction.
@c Precisely describing the rules for detecting switches is somewhat tricky,
@c and I won't attempt to do so, but they are
@c reasonable easy to understand in practice.
@c The compiler can index on any input variable to a disjunction
@c (not just the first head variable).  It can also index on more than
@c one variable, since after indexing on the first one, switch detection is
@c applied to all sub-disjunctions.  It can index on any functor, not
@c just the top-most one.

@item If-then-else

If the condition of an if-then-else cannot fail, the if-then-else
is equivalent to the conjunction of the condition and the ``then'' part,
and its determinism is computed accordingly.
Otherwise, 
an if-then-else can fail if either the ``then'' part or the ``else'' part
can fail.
It can succeed at most zero times
if the ``else'' part can succeed at most zero times
and if at least one of the condition and the ``then'' part
can succeed at most zero times.
It can succeed more than once
if any one of the condition, the ``then'' part and the ``else'' part
can succeed more than once.

@item Negations

If the determinism of the negated goal is @code{erroneous},
then the determinism of the negation is @code{erroneous}.
If the determinism of the negated goal is @code{failure},
the determinism of the negation is @code{det}.
If the determinism of the negated goal is @code{det} or @code{multi},
the determinism of the negation is @code{failure}.
Otherwise, the determinism of the negation is @code{semidet}.

@end table

@node Replacing compile-time checking with run-time checking
@section Replacing compile-time checking with run-time checking

Note that ``perfect'' determinism inference is an undecidable problem,
because it requires solving the halting problem.
(For instance, in the following example

@example
:- pred p(T, T).
:- mode p(in, out) is det.

p(A, B) :-
        (
                something_complicated(A, B)
        ;
                B = A
        ).
@end example

@noindent
@samp{p/0} can have more than one solution
only if @samp{something_complicated} can succeed.)
Sometimes, the rules specified by the Mercury language
for determinism inference will infer a determinism
that is not as precise as you would like.
However, it is generally easy to overcome such problems.
The way to do this is to replace the compiler's static checking
with some manual run-time checking.
For example, if you know that a particular goal should never fail,
but the compiler infers that goal to be @code{semidet},
you can check at runtime that the goal does succeed,
and if it fails, call the library predicate @samp{error/1}.

@example
:- pred q(T, T).
:- mode q(in, out) is det.

q(A, B) :-
        ( goal_that_should_never_fail(A, B0) ->
                B = B0
        ;
                error("goal_that_should_never_fail failed!")
        ).
@end example

@noindent
The predicate @code{error/1} has determinism @code{erroneous},
which means the compiler knows that it will never succeed or fail,
so the inferred determinism for the body of @code{q/2} is @code{det}.
(Checking assumptions like this is good coding style anyway.
The small amount of up-front work that Mercury requires
is paid back in reduced debugging time.)
Mercury's mode analysis knows that
computations with determinism erroneous can never succeed,
which is why it does not require the ``else'' part to generate
a value for @samp{B}.
The introduction of the new variable @samp{B0} is necessary
because the condition of an if-then-else is a negated context,
and can export the values it generates
only to the ``then'' part of the if-then-else,
not directly to the surrounding computation.
(If the surrounding computations had direct access
to values generated in conditions,
they might access them even if the condition failed.)

@node Interfacing nondeterministic code with the real world
@section Interfacing nondeterministic code with the real world

Normally, attempting to call
a @code{nondet} or @code{multi} mode of a predicate
from a predicate declared as @code{semidet} or @code{det}
will cause a determinism error.
So how can we call nondeterministic code from deterministic code?
There are several alternative possibilities.

If you just want to see if a nondeterministic goal is satisfiable or not,
without needing to know what variable bindings it produces,
then there is no problem -
determinism analysis considers @code{nondet} and @code{multi} goals
with no non-local output variables to be
@code{semidet} and @code{det} respectively.

If you want to use the values of output variables,
then you need to ask yourself
which one of possibly many solutions to a goal do you want?
If you want all of them, you need to use the predicate
@samp{solutions/2} in the standard library module @samp{std_util},
which collects all of the solutions to a goal into a list --
see @xref{Higher-order}.

If you just want one solution and don't care which,
the calling predicate should be declared @code{nondet} or @code{multi}.
The nondeterminism should then be propagated up the call tree
to the point at which it can be pruned.
In Mercury, pruning can be achieved in several ways.

The first way is the one mentioned above:
if a goal has no non-local output variables
then the implementation will only attempt to satisfy the goal once.
Any potential duplicate solutions will be implicitly pruned away.

The second way is to rely on the fact that
the implementation will only seek a single solution to @samp{main/2},
so alternative solutions to @samp{main/2}
(and hence also to @code{nondet} or @code{multi} predicates
called directly or indirectly from @samp{main/2})
are implicitly pruned away.
This is one way to achieve ``don't care'' style nondeterminism in Mercury.

The other situation in which you may want pruning
and committed choice style nondeterminism
is when you know that all the solutions returned will be equivalent.
For example, you might want to count the elements in a set
by removing them one at a time.
Removing an unspecified element from a set is a nondeterministic operation,
but no matter which order you remove them,
the computed size of the set should be the same.

We may eventually extend Mercury to allow users to write

@example
unique [X] Goal
@end example

@noindent
as a special quantifier, meaning
``there exists a unique @code{X} for which @samp{Goal} is true''.
This would allow the implementation
to prune alternative solutions for @samp{Goal}
if @samp{X} was the only output variable of @samp{Goal}.  

We would also like to allow users
to specify a user-defined equivalence relation
as the equality relation for user-defined types,
so that the @samp{unique} quantifier
could be used to express more general forms of equivalence.
For example, if you define a set type which represents sets as unsorted lists,
you would want to define a user-defined equivalence relation for that type,
which could sort the lists before comparing them.
The @samp{unique} quantifier could then be used for sets
even though the lists used to represent the sets
might not be in the same order in every solution.

However, the current implementation does not yet support
either the @samp{unique} quantifier or user-defined equivalence relations.

@node Committed choice nondeterminism
@section Committed choice nondeterminism

In addition to the determinism annotations described earlier, there are
``committed choice'' versions of @code{multi}
and @code{nondet}, called @code{cc_multi} and @code{cc_nondet}.
These can be used instead of @code{multi} or @code{nondet} if all calls
to that mode of the predicate occur in a context in which only one
solution is needed.

Such single-solution contexts are determined as follows.

@itemize @bullet
@item
The program entry point @samp{main/2} is in a single-solution context.

@item
Any goal with no output variables is in a single-solution context.

@item
If a conjunction is in a single-solution context, then 
the right-most conjunct is in a single-solution context,
and if the right-most conjunct cannot fail,
then rest of the conjunction is also in a single-solution
context.

@item
If an if-then-else is in a single-solution context, then the
``then'' part and the ``else'' part are in single-solution contexts,
and if the ``then'' part cannot fail, then condition of the
if-then-else is also in a single-solution context.

@end itemize

The compiler will check that all calls to a committed-choice
mode of a predicate do indeed occur in a single-solution context.

There are two reasons to use committed choice determinism annotations.
One reason is for efficiency: committed choice annotations allow
the compiler to generate much more efficient code.
The other reason is for doing I/O, which is allowed only in @samp{det}
or @samp{cc_multi} predicates, not in @samp{multi} predicates.

It would be nice to be able to declare a mode of a predicate as
both @samp{multi} and @samp{cc_multi}, and have the compiler call
the appropriate one depending on whether the call comes from a
single-solution context or not.  However, the current implementation
does not yet support this.

@node Higher-order
@chapter Higher-order programming

Mercury supports higher-order functions and predicates with currying,
closures, and lambda expressions. 
(To be pedantic, it would be more accurate to
say that Mercury supports higher-order procedures: in Mercury, when you
construct a higher-order predicate term, you only get one mode of
a predicate or function; if you want multiple modes, you must pass multiple
higher-order procedures.)

@menu
* Creating higher-order terms::
* Calling higher-order terms::
* Higher-order modes::
@end menu

@node Creating higher-order terms
@section Creating higher-order terms
@c NB. This section is pointed to by an error message in compiler/typecheck.m,
@c so if you change the section name, you need to update that error message.

To create a higher-order predicate or function term, you can use
a lambda expression, or, if the predicate or function has only one
mode, you can just use its name.
For example, if you have declared a predicate

@example
:- pred sum(list(int), int).
:- mode sum(in, out) is det.
@end example

@noindent
the following three unifications have the same effect:

@example
X = lambda([List::in, Length::out] is det, sum(List, Length))
Y = (pred(List::in, Length::out) is det :- sum(List, Length))
Z = sum
@end example

In the above example, the type of @samp{X}, @samp{Y}, and @samp{Z} is
@samp{pred(list(int), int)}, which means a predicate of two
arguments of types @samp{list(int)} and @samp{int} respectively.
[The syntax using @samp{lambda} is supported to enable programs to work
in both Mercury and Prolog, because the syntax using @samp{pred} and
@samp{:-} can't be easily emulated in Prolog.  When we have implemented
better debugging environments for Mercury, the syntax using @samp{lambda}
will be deprecated.]

Similarly, given

@example
:- func scalar_product(int, list(int)) = list(int).
:- mode scalar_product(in, in) = out is det.
@end example

@noindent
the following three unifications have the same effect:

@example
X = (func(Num, List) = NewList :- NewList = scalar_product(Num, List))
Y = (func(Num::in, List::in) = (NewList::out) is det
        :- NewList = scalar_product(Num, List))
Z = sum_func
@end example

In the above example, the type of @samp{X}, @samp{Y}, and @samp{Z} is
@samp{func(int, list(int)) = list(int)}, which means a function of two
arguments, whose types are @samp{int} and @samp{list(int)},
with a return type of @samp{int}.
As with @samp{:- func} declarations, if the modes and determinism
of the function are omitted in a higher-order function term, then
the modes default to @samp{in} for the arguments, @samp{out} for the
function result, and the determinism defaults to @samp{det}.

If the predicate or function has more than one mode, you must use an explicit
lambda expression to specify which mode you want.

You can also create higher-order predicate terms by "currying",
i.e. specifying the first few arguments to a predicate or function, but
leaving the remaining arguments unspecified.  For example, the
unification

@example
Sum123 = sum([1,2,3])
@end example

@noindent
binds @samp{Sum123} to a higher-order predicate term of type @samp{pred(int)}.
Similarly, the unification

@example
Double = scalar_product(2)
@end example

@noindent
binds @samp{Double} to a higher-order function term of type
@samp{func(list(int)) = list(int)}.

Note that when constructing a higher-order term, you cannot just use
the name of a builtin language construct such as @samp{=}, @samp{\=},
@samp{call}, or @samp{apply}, and nor can such constructs be curried.  
Instead, you must either use an explicit lambda expression,
or you must write a forwarding predicate or function.
For example, instead of

@example
list__filter([1,2,3], \=(2), List)
@end example

@noindent
you must write either

@example
list__filter([1,2,3], (pred(X::in) is semidet :- X \= 2), List)
@end example

@noindent
or

@example
list__filter([1,2,3], not_equal(2), List)
@end example

@noindent
where you have defined @samp{not_equal} using

@example
:- pred not_equal(T::in, T::in) is semidet.
not_equal(X, Y) :- X \= Y.
@end example

Another case when this arises is when want to curry a higher-order
term.  Suppose, for example, that you have a higher-order predicate
term @samp{OldPred} of type @samp{pred(int, char, float)}, and you want
to construct a new higher-order predicate term @samp{NewPred} of type
@samp{pred(char, float)} from @samp{OldPred} by supplying a value for
for just the first argument.  The solution is the same: use
an explicit lambda expression or a forwarding predicate.
In either case, the body of the lambda expression or the forwarding
predicate must contain a higher-order call with all the arguments
supplied.

@node Calling higher-order terms
@section Calling higher-order terms

Once you have created a higher-order predicate term (sometimes known
as a closure), the next thing you want to do is to call it.  
For predicates, you use the builtin goal call/N:

@table @asis
@item @code{call(Closure)}
@itemx @code{call(Closure1, Arg1)}
@itemx @code{call(Closure2, Arg1, Arg2)}
@itemx @dots{}
A higher-order predicate call.  @samp{call(Closure)} just calls the
specified higher-order predicate term.  The other forms append the
specified arguments onto the argument list of the closure before
calling it. 
@end table

For example, the goal

@example
call(Sum123, Result)
@end example

@noindent
would bind @samp{Result} to the sum of @samp{[1, 2, 3]}, i.e. to 6.

For functions, you use the builtin expression apply/N:

@table @asis
@item @code{apply(Closure1, Arg1)}
@itemx @code{apply(Closure2, Arg1, Arg2)}
@itemx @dots{}
A higher-order function application.  Such a term denotes the
result of invoking the specified higher-order function term with
the specified arguments.
@end table

For example, given the definition of @samp{Double} above, the goal

@example
List = apply(Double, [1, 2, 3])
@end example

@noindent
would be equivalent to

@example
List = scalar_product(2, [1, 2, 3])
@end example

@noindent
and so for a suitable implementation of the function
@samp{scalar_product/2} this would bind @samp{List} to
@samp{[2, 4, 6]}.

One extremely useful higher-order predicate in the Mercury standard
library is @code{solutions/2}, which has the following declaration:

@example
:- pred solutions(pred(T), list(T)).
:- mode solutions(pred(out) is nondet, out) is det.
@end example

The term which you pass to @samp{solutions/2} is a higher-order
predicate term.  You can pass the name of a one-argument predicate,
or you can pass a several-argument predicate with all but one
of the arguments supplied (a closure).  The declarative semantics of
@samp{solutions/2} can be defined as follows:

@example
solutions(Pred, List) is true iff
        all [X] (call(Pred, X) <=> list__member(X, List))
        and List is sorted.
@end example

@noindent
where @samp{call(Pred, X)} invokes the higher-order predicate term
@samp{Pred} with argument @samp{X},
and where @samp{list__member/2} is the standard
library predicate for list membership.  In other words,
@samp{solutions(Pred, List)} finds all the values of @samp{X}
for which @samp{call(Pred, X)} is true, collects these solutions
in a list, sorts the list, and returns that list as its result.
Here's an example: the standard library defines a predicate
@samp{list__perm(List0, List)}

@example
:- pred list__perm(list(T), list(T)).
:- mode list__perm(in, out) is nondet.
@end example

@noindent
which succeeds iff List is a permutation of List0.
Hence the following call to solutions

@example
solutions(list__perm([3,1,2]), L)
@end example

@noindent
should return all the possible permutations of the list @samp{[3,1,2]}
in sorted order:

@example
L = [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]].
@end example

See also @samp{unsorted_solutions/2} and @samp{solutions_set/2}, which
are defined in the standard library module @samp{std_util} and documented
in the Mercury Library Reference Manual.

@node Higher-order modes
@section Higher-order modes

In Mercury, the mode and determinism of a higher-order predicate or function
term are part of that term's @emph{inst}, not its @emph{type}.
This allows a single higher-order predicate to work on argument
predicates of different modes and determinism, which is particularly
useful for library predicates such as @samp{list__map} and @samp{list__foldl}.

The language contains builtin @samp{inst} values

@example
pred is @var{Determinism}
pred(@var{Mode}) is @var{Determinism}
pred(@var{Mode1}, @var{Mode2}) is @var{Determinism}
@dots{}
func(@var{Mode1}) = @var{Mode} is @var{Determinism}
func(@var{Mode1}, @var{Mode2}) = @var{Mode} is @var{Determinism}
@dots{}
@end example

These insts represent the instantiation state of variables bound
to higher-order predicate and function terms with the appropriate mode
and determinism.
For example, @samp{pred(out) is det} represents the instantion state
of being bound to a higher-order predicate term which is @samp{det}
and accepts one output argument; the term @samp{sum([1,2,3])} from the
example above is one such higher-order predicate term which matches
this instantiation state.

As a convenience, the language also contains builtin @samp{mode} values
of the same name (and they are what we have been using in the examples
up to now).  These modes map from the corresponding @samp{inst} to
itself.  It is as if they were defined by

@example
:- mode (pred is @var{Determinism}) :: in(pred is @var{Determinism}).
:- mode (pred(@var{Inst}) is @var{Determinism}) ::
    in(pred(@var{Inst}) is @var{Determinism}).
@dots{}
@end example

@noindent
using the parametric inst @samp{in/1} mentioned in @xref{Modes}
which maps an inst to itself.

If you want to define a predicate which returns a higher-order predicate
term, you would use a mode such as @samp{free -> pred(@dots{}) is @dots{}},
or @samp{out(pred(@dots{}) is @dots{})}.  For example:

@example
:- pred foo(pred(int)).
:- mode foo(free -> pred(out) is det) is det.

foo(sum([1,2,3])).
@end example

Note that in Mercury it is an error to attempt to unify two
higher-order terms.  This is because equivalence of
higher-order terms is undecidable in the general case.

For example, given the definition of @samp{foo} above, the goal

@example
        foo(lambda([X::out] is det, X = 6))
@end example

@noindent
is illegal.  If you really want to compare higher-order predicates
for equivalence, you must program it yourself; for example,
the above goal could legally be written as

@example
        P = lambda([X::out] is det, X = 6),
        foo(Q),
        all [X] (call(P, X) <=> call(Q, X)).
@end example

Note that the compiler will only catch direct attempts at higher-order
unifications; indirect attempts (via polymorphic predicates, for
example @samp{(list__append([], [P], [Q])} may result in an error at
run-time rather than at compile-time.

@node Modules
@chapter Modules

The Mercury module system is simple and straightforward. 
Each module must start with a @code{module} declaration,
specifying the name of the module. 
An @code{interface} declaration specifies
the start of the module's interface section:
this section contains declarations for the types, data constructors,
instantiation states, modes, functions and predicates exported by this module.
Mercury provides support for abstract data types,
since the definition of a type may be kept hidden,
with only the type name being exported.  
An @code{implementation} declaration specifies
the start of the module's implementation section. 
Any entities declared in this section are local to the module
and cannot be used by other modules.
The implementation section must of course contain definitions
for all abstract data types, functions and predicates exported by the module,
as well for all local types, functions and predicates.
The module may optionally end with an @code{end_module} declaration.

@c XXX should we mention multipart interfaces and implementations?
@c ===> no

If a module wishes to make use of entities exported by other modules,
then it must explicitly import those modules using one or more 
@code{import_module} or @code{use_module} declarations.
These declarations may occur either in the interface or the implementation 
section. If the imported entities are used in the interface section,
then the corresponding @code{import_module} or @code{use_module}
declaration must also be in the interface section. If the imported 
entities are only used in the implementation section, the 
@code{import_module} or @code{use_module} declaration should be in 
the implementation section.

Declarations, predicate calls, types, modes and insts
can be explicitly module qualified using the `:' operator,
i.e. @code{module:name}. This is useful both for readability and
for resolving name conflicts. Uses of entities imported using 
@code{use_module} declarations @emph{must} be explicitly module qualified.

Certain optimizations require information or source code for predicates
defined in other modules to be as effective as possible. At the moment,
inlining and higher-order specialization are the only optimizations that
the Mercury compiler can perform across module boundaries.

One module must export a predicate @samp{main}, which
must be declared as either

@example
:- pred main(io__state::di, io__state::uo) is det.
@end example

@noindent
or

@example
:- pred main(io__state::di, io__state::uo) is cc_multi.
@end example

@noindent
(or any declaration equivalent to one of the two above).

For example, here is the definition of a simple module for managing queues:

@example
:- module queue.
:- interface.

% Declare an abstract data type.

:- type queue(T).

% Declare some predicates which operate on the abstract data type.

:- pred empty_queue(queue(T)).
:- mode empty_queue(out) is det.
:- mode empty_queue(in) is semidet.

:- pred put(queue(T), T, queue(T)).
:- mode put(in, in, out) is det.

:- pred get(queue(T), T, queue(T)).
:- mode get(in, out, out) is semidet.

:- implementation.

% Queues are implemented as lists. We need the `list' module
% for the declaration of the type list(T), with its constructors
% '[]'/0 % and '.'/2, and for the declaration of the predicate
% list__append/3.

:- import_module list.

% Define the queue ADT.

:- type queue(T) == list(T).

% Declare the exported predicates.

empty_queue([]).

put(Queue0, Elem, Queue) :-
         list__append(Queue0, [Elem], Queue).

get([Elem | Queue], Elem, Queue).

:- end_module queue.

@end example

Mercury has a standard library which includes modules for
lists, stacks, queues, priority queues, sets, bags (multi-sets),
maps (dictionaries), random number generation, input/output
and filename and directory handling. 
See the Mercury Library Reference Manual for details.

The Mercury standard library has a standard naming convention in which
every entity exported by a module is prefixed by the module name and
two underscores.  We have found this convention improves the
readability and maintainability of our code, and so we recommend that
you follow it in your code too. (Eventually, these names will be converted
to names of the form @code{module:name}; this will allow you to omit the
prefix in places where it does not improve readability. A tool for the
automatic conversion of existing programs will be provided when this change
occurs.)

@node Semantics
@chapter Semantics

A legal Mercury program is one that complies with the syntax,
type, mode, determinism, and module system rules specified in earlier chapters.
If a program does not comply with those rules,
the compiler must report an error.

For each legal Mercury program,
there is an associated predicate calculus theory
whose language is specified by the type declarations in the program
and whose axioms are the completion of the clauses for all predicates
in the program,
plus the usual equality axioms extended with the completion of the
equations for all functions in the program,
plus axioms corresponding to the mode-determinism assertions
(@pxref{Determinism}),
plus axioms specifying the semantics of library predicates and functions.
The declarative semantics of a legal Mercury program
is specified by this theory.

Mercury implementations must be sound:
the answers they compute must be true in every model of the theory.
Mercury implementations are not required to be complete:
they may fail to compute an answer in finite time,
or they may exhaust the resource limitations of the execution
environment, even though an answer is provable in the theory.
However, there are certain minimum requirements that they
must satisfy with respect to completeness.

There is an operational semantics of Mercury programs called the
@dfn{strict sequential} operational semantics.  In this semantics,
the program is executed top-down, starting from @samp{main/2},
and function calls within a goal, conjunctions and disjunctions are all
executed in depth-first left-to-right order. 
Conjunctions and function calls are ``minimally'' reordered as required
by the modes:
the order is determined by selecting the first mode-correct sub-goal
(conjunct or function call),
executing that, then selecting the first of the remaining sub-goals
which is now mode-correct, executing that, and so on. 
(There is no interleaving of different individual conjuncts or function calls,
however; the sub-goals are reordered, not split and interleaved.)
Function application is strict, not lazy.

Mercury implementations are required to provide a method of processing
Mercury programs which is equivalent to the strict sequential
operational semantics.

There is another operational semantics of Mercury programs called
the @dfn{strict commutative} operational semantics.  This semantics
is equivalent to the strict sequential operation semantics except
that there is no requirement that function calls, conjunctions and disjunctions 
be executed left-to-right; they may be executed in any order.
(The order may even be different each time a particular goal
is entered.)

As well as providing the strict sequential operational semantics,
Mercury implementations may optionally provide additional
implementation-defined operational semantics, provided that
any such implementation-defined operational semantics are
at least as complete as the strict commutative operational
semantics.  An implementation-defined semantics
is ``at least as complete'' as the strict commutative 
semantics if and only if the implementation-defined 
semantics guarantees to compute an answer in finite time for
any program for which an answer would be computed in finite time for all
possible executions under the strict commutative semantics
(i.e. for all possible orderings of conjuctions and disjunctions).

Thus, to summarize, there are in fact a variety of different operational
semantics for Mercury.  In one of them, the strict sequential semantics, there
is no nondeterminism -- the behaviour is always specified exactly.
Programs are executed top-down using SLDNF (or something equivalent),
mode analysis does "minimal" reordering (in a precisely defined sense),
function calls, conjunctions and disjunctions are executed depth-first
left-to-right, and function evaluation is strict.  All implementations
are required to support the strict sequential semantics, so that a
program which works on one implementation using this semantics will be
guaranteed to work on any other implementation.  However,
implementations are also allowed to support other operational
semantics, which may have non-determinism, so long as they are sound
with respect to the declarative semantics, and so long as they meet a
minimum level of completeness (they must be at least as complete as the
strict commutative semantics, in the sense that every program which
terminates for all possible orderings must must also terminate in any
implementation-defined operational semantics).

This compromise allows Mercury to be used in several different ways.
Programmers who care more about ease of programming and portability
than about efficiency can use the strict sequential semantics, and
can then be guaranteed that if their program works on one correct
implementation, it will work on all correct implementations.  Compiler
implementors who want to write optimizing implementations that do lots
of clever code reorderings and other high-level transformations or that
want to offer parallelizing implementations which take maximum
advantage of parallelism can define different semantic models.
Programmers who care about efficiency more than portability can write
code for these implementation-defined semantic models.  Programmers who
care about efficiency @emph{and} portability can achieve this by writing
code for the commutative semantics.
Of course, this is not
quite as easy as using the strict sequential semantics, since it is
in general not sufficient to test your programs on just one
implementation if you are to be sure that it will be able to use the
maximally efficient operational semantics on any implementation.
However, if you do write code which works for all possible executions
under commutative semantics (i.e. for all possible orderings of
conjunctions and disjunctions), then you can be guaranteed that it
will work correctly on every implementation, under every possible
implementation-defined semantics.

The University of Melbourne Mercury implementation will offer eight
different semantics, which will be selected with different
combinations of the @samp{--no-reorder-conj}, @samp{--no-reorder-disj},
and @samp{--fully-strict} options.  (The @samp{--fully-strict} option
will prevent
the compiler from improving completeness by optimizing away infinite
loops or calls to @code{error/1}.)  The default semantics will be the
commutative semantics.  Enabling all of these options will give you the
the strict sequential semantics.  Enabling just some of them will give
you a semantics somewhere in between.  (At the time of writing, however,
these options had not been implemented.)

Future implementations of Mercury may wish to offer other operational semantics.
For example, they may wish to provide semantics in which function
evaluation is lazy, rather than strict; semantics with a guaranteed
fair search rule; and so forth.

@node Pragmas
@chapter Pragmas

@ifinfo
There are several uses for @code{pragma} declarations:
@end ifinfo

@menu
* C interface::                 The C interface allows C code to be called
                                from Mercury code, and vice versa.
* Inlining::                    Calls to Mercury predicates can be inlined
                                by the compiler to improve efficiency.
* Preventing Inlining::         Inlining can be avoided when undesirable.
@c * Tabling::                     Mercury predicates can be evaluated
@c                                 using a three different forms of tabled
@c                                 evaluation.

* Obsolescence::		Library developers can declare old versions
				of predicates or functions to be obsolete.
* Source file name::		The @samp{source_file} pragma and
				@samp{#@var{line}} directives provide support
				for preprocessors and other tools that
				generate Mercury code.
@end menu

@node C interface
@section C interface

@menu
* Calling C code::                      How to call C code whenever there is
                                        a call to a Mercury predicate.
* Including C headers::                 Using functions with prototypes from a
                                        non-standard header file.
* Including C code::                    Including definitions of C
					functions in your Mercury code.
* Linking with C object files::         Linking with C object files and 
                                        libraries.
* Passing data to and from C::          Exchanging simple data types between
                                        Mercury and C.
* Using C pointers::                    Maintaining a reference to C data
                                        structures in Mercury code.
@end menu

@node Calling C code
@subsection Calling C code

A declaration of the form

@example
:- pragma c_code(@var{Pred}(@var{Var1}::@var{Mode1}, @var{Var2}::@var{Mode2}, ...), may_call_mercury, @var{C_Code}).
@end example

@noindent
results in any calls to @var{Pred} with variables in modes (@var{Mode1}, 
@var{Mode2}, ...) being replaced by the C code given in @var{C_Code}.

If there is a @code{pragma c_code} declaration for a mode of a predicate,
then that mode of the predicate must be det or semidet,
there must not be any clauses for that predicate,
and there must be a @code{pragma c_code} goal for every mode of the predicate.

For example, the following piece of code gives a predicate, 
@samp{c_write_string/3}, which has a similar effect to the Mercury library 
predicate @samp{io__write_string/3}:

@example
:- pred c_write_string(string, io__state, io__state).
:- mode c_write_string(in, di, uo) is det.

:- pragma c_code(c_write_string(S::in, IO0::di, IO::uo), may_call_mercury,
        "puts(S); IO = IO0;").
@end example

If the C code does not recursively invoke Mercury code,
as in the above example, then you can use a declaration of the form

@example
:- pragma c_code(@var{Pred}(@var{Var1}::@var{Mode1}, @var{Var2}::@var{Mode2}, ...), will_not_call_mercury, @var{C_Code}).
@end example

This allows the compiler to use a more efficient calling convention.
(If you use this form, and the C code @emph{does} invoke Mercury code,
then the behaviour is undefined --- your program may misbehave or crash.)

@c XXX may assume vars of input args are defined; must assign to output args

The C code in a @code{pragma c_code} declaration
for a semidet mode of a predicate
must assign a truth value to the macro @var{SUCCESS_INDICATOR}.
SUCCESS_INDICATOR should not be used other as the target of an assignment.
(For example, it may be @code{#define}d to a register, so you should not try to
take its address.)

@c XXX must assign to output args iff SUCCESS_INDICATOR is set to true

@example
:- pred string__contains_char(string, character).
:- mode string__contains_char(in, in) is semidet.

:- pragma(c_code, string__contains_char(Str::in, Ch::in), will_not_call_mercury,
	"SUCCESS_INDICATOR = (strchr(Str, Ch) != NULL);").
@end example

@node Including C headers
@subsection Including C headers

Any macros, function prototypes, or other C declarations
that are used in @samp{c_code} pragmas must be included using a
@samp{c_header_code} declaration of the form

@example
:- pragma c_header_code(@var{HeaderCode}).
@end example

@noindent
@var{HeaderCode} can be a C @samp{#include} line, for example

@example
:- pragma c_header_code("#include <math.h>")
@end example

@noindent
or

@example
:- pragma c_header_code("#include ""tcl.h""").
@end example

@noindent
or it may contain any C declarations, for example

@example
:- pragma c_header_code("
        extern int errno;
        #define SIZE 200
        struct Employee @{
                char name[SIZE];
        @}
	extern int bar;
	extern void foo(void);
").
@end example

Mercury automatically includes certain headers such as @code{<stdio.h>},
but you should not rely on this, as the set of headers which Mercury
automatically includes is subject to change.

@node Including C code
@subsection Including C code

Definitions of C functions or global variables may be
included using a declaration of the form

@example
:- pragma c_code(@var{Code}).
@end example

For example,

@example
:- pragma c_code("
	int bar = 42;
	void foo(void) @{@}
").
@end example

Such code is copied verbatim into the generated C file.

@node Linking with C object files 
@subsection Linking with C object files 

To link an existing object file or library into the Mercury executable,
set the @samp{Mmake} variable @samp{MLLIBS} in the
@samp{Mmake} file in the directory in which you are working.  For
example add the following line to the @samp{Mmake} file:

@example
MLLIBS = my_functions.o -L/usr/local/contrib/lib -lfancy_library
@end example

As illustrated by the example, the values for @samp{MLLIBS} are similar to
those taken by the Unix linker.

@node Passing data to and from C
@subsection Passing data to and from C

For each of the Mercury types @code{int}, @code{float}, @code{char},
and @code{string}, there is a C typedef for the corresponding type in C:
@code{Integer}, @code{Float}, @code{Char}, and @code{String} respectively.

In the current implementation, @samp{Integer} is a typedef for an
integral type whose size is the same size as a pointer; @samp{Float} is
a typedef for @samp{double} (unless the program and the Mercury library
was compiled with @samp{-DUSE_SINGLE_PREC_FLOAT}, in which case it is
a typedef for @samp{float}); @samp{Char} is a typedef for @samp{char};
and @samp{String} is a typedef for @samp{Char *}.

Mercury variables of type @code{int}, @code{float}, @code{char}, or
@code{string} are passed to and from C as C variables whose type is
given by the corresponding typedef.  Mercury variables of any other
type are passed as a @samp{Word}, which in the current implementation
is a typedef for an unsigned type whose size is the same size as a pointer.

Mercury lists can be manipulated by C code using the following macros,
which are defined by the Mercury implementation.

@example
list_is_empty(list)     /* test if a list is empty */
list_head(list)         /* get the head of a list */
list_tail(list)         /* get the tail of a list */
list_empty()            /* create an empty list */
list_cons(head,tail)    /* construct a list with the given head and tail */
@end example

The @samp{list_cons} macro should only be used in C code called
using the @samp{will_not_call_mercury} calling convention.
XXX I am not sure about this - zs

XXX we need a more extensive discussion on memory allocation here

@node Using C pointers
@subsection Using C pointers

The inbuilt Mercury type @code{c_pointer} can be used to pass C pointers
between C functions which are called from Mercury.  For example:

@example
:- module pointer_example.

:- interface.

:- type complicated_c_structure.

% Initialise the abstract C structure that we pass around in Mercury.
:- pred initialise_complicated_structure(complicated_c_structure::uo) is det.

% Perform a calculation on the C structure.
:- pred do_calculation(int::in, complicated_structure::di, 
        complicated_structure::uo) is det.

:- implementation.

% Our C structure is implemented as a c_pointer.
:- type complicated_c_structure == c_pointer.

:- pragma c_header_code("
        extern struct foo *init_struct(void);
        extern struct foo *perform_calculation(int, struct foo *);
");

:- pragma c_code(initialise_complicated_structure(Structure::uo),
	may_call_mercury,
        "Structure = init_struct();").

:- pragma c_code(do_calculation(Value::in, Structure0::di, Structure::uo,
	may_call_mercury,
        "Structure = perform_calculation(Value, Structure0);").
@end example

@node Inlining
@section Inlining

A declaration of the form

@example
:- pragma inline(@var{Name}/@var{Arity}).
@end example

@noindent
is a hint to the compiler that all calls to the predicate(s) or function(s)
with name @var{Name} and arity @var{Arity} should be inlined.

The current Mercury implementation is smart enough to inline many
simple predicates even without this hint.

@node Preventing Inlining
@section Preventing Inlining

A declaration of the form

@example
:- pragma no_inline(@var{Name}/@var{Arity}).
@end example

@noindent
ensures the compiler will not inline this predicate.  This may be used
simply for performance concerns (inlining can cause unwanted code bloat
in some cases) or to prevent possibly dangerous inlining when using
low-level C code.


@c @node Tabling
@c @section Tabling
@c 
@c A declaration of the form
@c 
@c @example
@c :- pragma memo(@var{Name}/@var{Arity}).
@c @end example
@c 
@c @noindent
@c is a hint to the compiler that the predicate(s) or function(s)
@c with name @var{Name} and arity @var{Arity} should be evaluated using
@c memoing.

@node Obsolescence
@section Obsolescence

A declaration of the form

@example
:- pragma obsolete(@var{Name}/@var{Arity}).
@end example

@noindent
declares that the predicate(s) or function(s)
with name @var{Name} and arity @var{Arity} are ``obsolete'':
it instructs the compiler to issue a warning whenever the named
predicate(s) or function(s) are used.

@samp{pragma obsolete} declarations are intended for use by library
developers, to allow gradual (rather than abrupt) evolution of library
interfaces.  If a library developer changes the interface of a library
predicate, they should leave the old version of that predicate in the
library, but mark it as obsolete using a @samp{pragma obsolete}
declaration, and document how library users should modify their code to
suit the new interface.  The users of the library will then get a
warning if they use obsolete features, and can consult the library
documentation to determine how to fix their code.  Eventually, when the
library developer deems that users have had sufficient warning, they
can remove the old version entirely.

@node Source file name
@section Source file name

The @samp{source_file} pragma and @samp{#@var{line}} directives provide
support for preprocessors and other tools that generate Mercury code.
The tool can insert these directives into the generated Mercury code
to allow the Mercury compiler to report diagnostics (error and warning
messages) at the original source code location, rather than at the
location in the automatically generated Mercury code.

A @samp{source_file} pragma is a declaration of the form

@example
:- pragma source_file(@var{Name}).
@end example

@noindent
where @var{Name} is a string that specifies the name of the source file.

For example, if a preprocessor generated a file @file{foo.m} based on a
input file @file{foo.m.in}, and it copied lines 20, 30, and 31 from
@file{foo.m.in}, the following directives would ensure that any 
error or warnings for those lines copied from @file{foo.m} were reported
at their original source locations in @file{foo.m.in}.

@example
:- module foo.
:- pragma source_file("foo.m.in").
#20
% this line comes from line 20 of foo.m
#30
% this line comes from line 30 of foo.m
% this line comes from line 31 of foo.m
:- pragma source_file("foo.m").
#10
% this automatically generated line is line 10 of foo.m
@end example

Note that if a generated file contains some text which is copied from a
source file, and some which is automatically generated, it is a good
idea to use @samp{pragma source_file} and @samp{#@var{line}} directives
to reset the source file name and line number to point back to the
generated file for the automatically generated text, as in the above
example.

@contents
@bye
